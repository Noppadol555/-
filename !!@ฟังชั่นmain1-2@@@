# ===============================================
# main.py ‚Äî ‡∏£‡∏ß‡∏°‡∏ó‡∏∏‡∏Å‡∏Ñ‡∏•‡∏≤‡∏™‡πÅ‡∏•‡∏∞‡∏£‡∏±‡∏ô‡∏£‡∏∞‡∏ö‡∏ö‡πÄ‡∏ó‡∏£‡∏î‡∏´‡∏•‡∏±‡∏Å (‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏° WebSocket + APIManager)
# ===============================================

from config import GlobalConfig
import asyncio, logging, traceback, os, keyboard
import numpy as np
import pandas as pd
import torch
import time

# ==============================
# üîÑ ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ã‡∏¥‡∏á‡∏Ñ‡πå GlobalConfig ‡πÅ‡∏ö‡∏ö‡πÄ‡∏£‡∏µ‡∏¢‡∏•‡πÑ‡∏ó‡∏°‡πå
# ==============================
async def sync_global_config_loop(interval=15):
    prev_config = GlobalConfig.CONFIG.copy()
    while True:
        try:
            current_level = getattr(logging, GlobalConfig.get('log_level', 'INFO').upper(), logging.INFO)
            if logging.getLogger().level != current_level:
                logging.getLogger().setLevel(current_level)
                logging.info(f"üõ†Ô∏è ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï log level ‡πÄ‡∏õ‡πá‡∏ô {GlobalConfig.get('log_level')}")

            trade_log_file = GlobalConfig.get('trade_log_file', 'trade_log.xlsx')
            if not os.path.exists(trade_log_file):
                pd.DataFrame(columns=['Time', 'Symbol', 'Action', 'Price', 'PnL']).to_excel(trade_log_file, index=False)
                logging.info(f"üìò ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÑ‡∏ü‡∏•‡πå‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÄ‡∏ó‡∏£‡∏î‡πÉ‡∏´‡∏°‡πà: {trade_log_file}")

            for k, v in GlobalConfig.CONFIG.items():
                if prev_config.get(k) != v:
                    logging.info(f"üîÅ ‡∏Ñ‡πà‡∏≤ CONFIG '{k}' ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏à‡∏≤‡∏Å {prev_config.get(k)} ‚Üí {v}")
                    prev_config[k] = v

        except Exception as e:
            logging.warning(f"‚ö†Ô∏è GlobalConfig Sync Error: {e}")
        await asyncio.sleep(interval)


# ==============================
# üü¢ ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏£‡∏∞‡∏ö‡∏ö‡πÅ‡∏ö‡∏ö‡πÄ‡∏£‡∏µ‡∏¢‡∏•‡πÑ‡∏ó‡∏°‡πå
# ==============================
async def status_monitor_loop(ws_manager, api_manager, interval=10):
    while True:
        try:
            ws_ok = "‚úÖ" if ws_manager.is_running() else "‚ùå"
            api_ok = "‚úÖ" if api_manager and getattr(api_manager, "exchange", None) else "‚ùå"
            delay = round(time.time() - getattr(ws_manager, "last_data_time", time.time()), 1)
            symbol_count = len(getattr(ws_manager, "data", {}))
            balance = getattr(ws_manager, "balance_data", {}).get("free", 0.0)
            logging.info(
                f"‚è≥ STATUS | WebSocket={ws_ok} | API={api_ok} | Symbols={symbol_count} | Delay={delay}s | Balance={balance:.2f} USDT"
            )
        except Exception as e:
            logging.warning(f"‚ö†Ô∏è ‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏£‡∏∞‡∏ö‡∏ö‡πÑ‡∏°‡πà‡∏™‡∏°‡∏ö‡∏π‡∏£‡∏ì‡πå: {e}")
        await asyncio.sleep(interval)


# ===============================================
# üß© ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô control_loop ‚Äî ‡∏´‡∏¢‡∏∏‡∏î‡∏£‡∏∞‡∏ö‡∏ö‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏Å‡∏î 'q'
# ===============================================
async def control_loop(ws_manager, api_manager, risk_guardian):
    while GlobalConfig.get('system_running'):
        try:
            if keyboard.is_pressed('q'):
                GlobalConfig.set('system_running', False)
                logging.info("üõë ‡∏ï‡∏£‡∏ß‡∏à‡∏û‡∏ö‡∏Å‡∏≤‡∏£‡∏Å‡∏î 'q': ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏´‡∏¢‡∏∏‡∏î‡∏£‡∏∞‡∏ö‡∏ö‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏õ‡∏•‡∏≠‡∏î‡∏†‡∏±‡∏¢...")
                await ws_manager.stop()
                if hasattr(api_manager, 'exchange'):
                    await api_manager.exchange.close()
                await risk_guardian.emergency_stop()
                logging.info("‚úÖ ‡∏£‡∏∞‡∏ö‡∏ö‡∏´‡∏¢‡∏∏‡∏î‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡πÅ‡∏•‡∏∞‡∏õ‡∏¥‡∏î‡∏ó‡∏∏‡∏Å‡∏™‡πà‡∏ß‡∏ô‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏õ‡∏•‡∏≠‡∏î‡∏†‡∏±‡∏¢‡πÅ‡∏•‡πâ‡∏ß")
                break
        except Exception as e:
            logging.warning(f"‚ö†Ô∏è Control Loop Error: {e}")
        await asyncio.sleep(0.1)


# ===============================================
# üîé ‡∏ú‡∏π‡πâ‡∏ä‡πà‡∏ß‡∏¢ Orchestrator (‡πÑ‡∏°‡πà‡πÅ‡∏ï‡∏∞‡∏Ñ‡∏•‡∏≤‡∏™‡πÄ‡∏î‡∏¥‡∏° / ‡πÉ‡∏ä‡πâ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡πÉ‡∏ô‡πÑ‡∏ü‡∏•‡πå‡∏ô‡∏µ‡πâ)
# ===============================================
def _decode_action_from_discrete(discrete_pred):
    """
    ‡πÅ‡∏õ‡∏•‡∏á output ‡πÅ‡∏ö‡∏ö distribution/score ‡πÉ‡∏´‡πâ‡πÄ‡∏õ‡πá‡∏ô‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡πÄ‡∏ó‡∏£‡∏î: 0=HOLD, 1=LONG, 2=SHORT
    ‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö‡∏ó‡∏±‡πâ‡∏á‡∏£‡∏π‡∏õ [B,3] ‡∏´‡∏£‡∏∑‡∏≠ [3]
    """
    if discrete_pred is None:
        return "HOLD"
    arr = np.array(discrete_pred)
    if arr.ndim > 1:
        arr = arr[0]
    if arr.size == 0:
        return "HOLD"
    idx = int(np.argmax(arr))
    return {0: "HOLD", 1: "LONG", 2: "SHORT"}.get(idx, "HOLD")


def _extract_size_and_leverage(continuous_pred, default_size, default_lev=5):
    """
    ‡∏î‡∏∂‡∏á‡∏Ç‡∏ô‡∏≤‡∏î‡∏™‡∏±‡∏ç‡∏ç‡∏≤‡πÅ‡∏•‡∏∞‡πÄ‡∏•‡πÄ‡∏ß‡∏≠‡πÄ‡∏£‡∏à‡∏à‡∏≤‡∏Å continuous_pred ‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏õ‡∏•‡∏≠‡∏î‡∏†‡∏±‡∏¢ (‡∏°‡∏µ fallback)
    map: size_scale = clip(pred[0], 0..1), lev_scale = clip(pred[1], 0..1)
    size = default_size * (0.25 + 0.75*size_scale)  ‚Üí ‡πÑ‡∏°‡πà‡∏ô‡πâ‡∏≠‡∏¢‡πÄ‡∏Å‡∏¥‡∏ô
    lev  = int(1 + lev_scale* (GlobalConfig.get('max_leverage', 50)-1))
    """
    try:
        arr = np.array(continuous_pred)
        if arr.ndim > 1:
            arr = arr[0]
        size_scale = float(np.clip(arr[0], 0.0, 1.0)) if arr.size >= 1 else 0.5
        lev_scale = float(np.clip(arr[1], 0.0, 1.0)) if arr.size >= 2 else (default_lev / max(1, GlobalConfig.get('max_leverage', 50)))
        size = float(default_size) * (0.25 + 0.75 * size_scale)
        lev = int(1 + lev_scale * (GlobalConfig.get('max_leverage', 50) - 1))
        return max(size, 1e-6), max(1, lev)
    except Exception:
        return float(default_size), int(default_lev)


def _maybe_strategy_refine(strategy_gen, symbol, action, price, tp, sl):
    """
    ‡∏Ç‡∏≠‡∏Ñ‡∏≥‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥‡∏õ‡∏£‡∏±‡∏ö‡∏Å‡∏•‡∏¢‡∏∏‡∏ó‡∏ò‡πå‡∏à‡∏≤‡∏Å StrategyGenerator ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ‡πÄ‡∏°‡∏ò‡∏≠‡∏î‡∏ó‡∏µ‡πà‡πÄ‡∏Ç‡πâ‡∏≤‡∏Å‡∏±‡∏ô‡πÑ‡∏î‡πâ
    ‡∏à‡∏∞‡∏Ñ‡∏∑‡∏ô‡∏Ñ‡πà‡∏≤ (tp, sl) ‡∏ó‡∏µ‡πà‡∏õ‡∏£‡∏±‡∏ö‡πÅ‡∏•‡πâ‡∏ß ‡∏´‡∏£‡∏∑‡∏≠‡∏Ç‡∏≠‡∏á‡πÄ‡∏î‡∏¥‡∏°‡∏ñ‡πâ‡∏≤‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ
    """
    try:
        # ‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö‡∏ä‡∏∑‡πà‡∏≠‡πÄ‡∏°‡∏ò‡∏≠‡∏î‡∏ó‡∏µ‡πà‡∏≠‡∏≤‡∏à‡∏ï‡πà‡∏≤‡∏á‡∏Å‡∏±‡∏ô‡πÉ‡∏ô‡πÇ‡∏õ‡∏£‡πÄ‡∏à‡∏Å‡∏ï‡πå
        for name in ("refine", "compose", "suggest", "generate"):
            f = getattr(strategy_gen, name, None)
            if callable(f):
                out = f(symbol=symbol, action=action, price=price, take_profit=tp, stop_loss=sl)
                if isinstance(out, dict):
                    tp = float(out.get("take_profit", tp))
                    sl = float(out.get("stop_loss", sl))
                break
    except Exception:
        pass
    return tp, sl


def _risk_approved(risk_guardian, symbol, action, size, lev):
    """
    ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏™‡∏µ‡πà‡∏¢‡∏á‡∏Å‡πà‡∏≠‡∏ô‡∏™‡πà‡∏á‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÄ‡∏°‡∏ò‡∏≠‡∏î approve_trade ‡πÉ‡∏´‡πâ‡∏≠‡∏ô‡∏∏‡∏°‡∏±‡∏ï‡∏¥‡∏ú‡πà‡∏≤‡∏ô
    """
    try:
        f = getattr(risk_guardian, "approve_trade", None)
        if callable(f):
            return bool(f(symbol, action, size=size, leverage=lev))
        return True
    except Exception:
        return True


# ==============================
# üß† ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏´‡∏•‡∏±‡∏Å (MAIN)
# ==============================
async def main():
    logging.info("‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö‡∏Å‡∏≤‡∏£‡πÄ‡∏ó‡∏£‡∏î‡∏î‡πâ‡∏ß‡∏¢ CONFIG ‡∏à‡∏≤‡∏Å GlobalConfig")

    # ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ log level
    log_level_str = GlobalConfig.get('log_level', 'INFO').upper()
    logging.getLogger().setLevel(getattr(logging, log_level_str, logging.INFO))

    # ‚úÖ ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏≠‡∏¥‡∏ô‡∏™‡πÅ‡∏ï‡∏ô‡∏ã‡πå‡∏´‡∏•‡∏±‡∏Å‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
    api_manager = APIManager()
    ws_manager = WebSocketManager(exchange=api_manager.exchange, time_offset=api_manager.time_offset)
    trader = UnifiedQuantumTrader(GlobalConfig.get('input_dim'))
    risk_guardian = RiskGuardian()
    env = MultiMarketEnv(ws_manager=ws_manager, exchange=api_manager.exchange)
    env.trader = trader

    trader.replay_buffer = None
    risk_guardian.env = env
    strategy_gen = StrategyGenerator(trader, env, risk_guardian)
    resource_manager = IntelligentResourceManager()
    kpi_optimizer = KPIOptimizer()
    risk_allocator = DynamicRiskAllocator()
    kpi_tracker = KPITracker()
    bug_fixer = AutomaticBugFixer()

    await ws_manager.fetch_all_usdt_pairs()
    await ws_manager.start()

    trader.current_symbols = ws_manager.all_usdt_pairs[: GlobalConfig.get('madrl_agent_count')]
    env.symbols = trader.current_symbols
    env.simulator.update_symbols(env.symbols)
    trader.madrl.update_symbols(env.symbols)

    # ‚úÖ ‡∏™‡∏£‡πâ‡∏≤‡∏á Tasks background
    asyncio.create_task(resource_manager.monitor_resources())
    asyncio.create_task(status_monitor_loop(ws_manager, api_manager))
    asyncio.create_task(sync_global_config_loop())
    asyncio.create_task(api_manager.monitor_trailing_orders())  # ‚úÖ ‡πÄ‡∏û‡∏¥‡πà‡∏° Trailing Manager
    asyncio.create_task(control_loop(ws_manager, api_manager, risk_guardian))

    # ‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏¢‡πâ‡∏≠‡∏ô‡∏´‡∏•‡∏±‡∏á
    for symbol in env.symbols:
        await env.load_historical_data(symbol)

    # ‡πÄ‡∏õ‡∏¥‡∏î‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏£‡∏∞‡∏ö‡∏ö
    GlobalConfig.set('system_running', True)
    trader.positions = {}

    # ============================================================
    # üîÅ MAIN TRADING LOOP (‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏° APIManager) ‚Äî AI Orchestrator
    # ============================================================
    while GlobalConfig.get('system_running'):
        try:
            mode = "üß™ ‡πÄ‡∏ó‡∏£‡∏î‡∏à‡∏≥‡∏•‡∏≠‡∏á" if GlobalConfig.get('dry_run') else "üí∞ ‡πÄ‡∏ó‡∏£‡∏î‡∏à‡∏£‡∏¥‡∏á"

            for symbol in env.symbols:
                # 1) ‚úÖ ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î‡∏à‡∏≤‡∏Å WebSocket
                ws_rec = ws_manager.data.get(symbol, {})
                current_price = ws_rec.get("close", 0.0)
                if not current_price:
                    continue

                # 2) ‚úÖ ‡πÄ‡∏ï‡∏£‡∏µ‡∏¢‡∏° state ‡πÉ‡∏´‡πâ‡πÇ‡∏°‡πÄ‡∏î‡∏• UQT
                state_data = np.array([[
                    ws_rec.get("close", 0.0),
                    ws_rec.get("volume", 0.0),
                    ws_rec.get("funding_rate", 0.0),
                    ws_rec.get("depth", 0.0),
                ]], dtype=np.float32)

                # 3) ‚úÖ ‡πÉ‡∏´‡πâ AI ‡∏û‡∏¢‡∏≤‡∏Å‡∏£‡∏ì‡πå (‡∏£‡∏ß‡∏°‡πÇ‡∏°‡πÄ‡∏î‡∏•‡∏¢‡πà‡∏≠‡∏¢‡∏†‡∏≤‡∏¢‡πÉ‡∏ô UQT ‡∏ï‡∏≤‡∏°‡∏ó‡∏µ‡πà‡πÄ‡∏à‡πâ‡∏≤‡∏ô‡∏≤‡∏¢‡∏≠‡∏≠‡∏Å‡πÅ‡∏ö‡∏ö‡πÑ‡∏ß‡πâ)
                discrete_pred, continuous_pred = trader.predict(state_data)

                # 4) ‚úÖ ‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏õ‡πá‡∏ô action ‡∏ó‡∏µ‡πà‡πÄ‡∏Ç‡πâ‡∏≤‡πÉ‡∏à‡πÑ‡∏î‡πâ
                if hasattr(trader, "decode_action") and callable(getattr(trader, "decode_action")):
                    try:
                        action = trader.decode_action(discrete_pred)
                    except Exception:
                        action = _decode_action_from_discrete(discrete_pred)
                else:
                    action = _decode_action_from_discrete(discrete_pred)

                # 5) ‚úÖ sizing & leverage ‡∏à‡∏≤‡∏Å continuous_pred (‡∏°‡∏µ fallback)
                base_size = GlobalConfig.get('trade_amount', 0.01)
                default_lev = GlobalConfig.get('default_leverage', 5)
                order_size, lev = _extract_size_and_leverage(continuous_pred, base_size, default_lev)

                # 6) ‚úÖ ‡∏ï‡∏±‡πâ‡∏á TP/SL ‡∏û‡∏∑‡πâ‡∏ô‡∏ê‡∏≤‡∏ô ‡πÅ‡∏•‡∏∞‡∏Ç‡∏≠ StrategyGenerator ‡∏õ‡∏£‡∏±‡∏ö (‡∏ñ‡πâ‡∏≤‡∏°‡∏µ)
                tp = float(current_price) * (1 + GlobalConfig.get('tp_ratio', 0.01))
                sl = float(current_price) * (1 - GlobalConfig.get('sl_ratio', 0.01))
                tp, sl = _maybe_strategy_refine(strategy_gen, symbol, action, current_price, tp, sl)

                # 7) ‚úÖ ‡∏ï‡∏£‡∏ß‡∏à‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏™‡∏µ‡πà‡∏¢‡∏á‡∏Å‡πà‡∏≠‡∏ô‡∏™‡πà‡∏á‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏à‡∏£‡∏¥‡∏á
                if not _risk_approved(risk_guardian, symbol, action, order_size, lev):
                    logging.info(f"{mode} | ‚õî ‡∏õ‡∏è‡∏¥‡πÄ‡∏™‡∏ò‡∏Å‡∏≤‡∏£‡πÄ‡∏ó‡∏£‡∏î (RiskGuardian) | {symbol} | action={action} | size={order_size:.6f} | lev={lev}x")
                    continue

                # 8) ‚úÖ Trailing parameters (‡∏à‡∏≤‡∏Å config)
                trailing_callback = GlobalConfig.get('trailing_callback_rate', 0.005)
                if action == "LONG":
                    trailing_tp = current_price * (1 + trailing_callback)
                    trailing_sl = current_price * (1 - trailing_callback)
                    logging.info(
                        f"{mode} | üü¢ LONG OPEN | {symbol} @ {current_price:.4f} | size={order_size:.6f} | Lev={lev}x "
                        f"| TP={tp:.4f} | SL={sl:.4f} | TR_TP={trailing_tp:.4f} | TR_SL={trailing_sl:.4f}"
                    )
                    await api_manager.execute_limit_order(
                        symbol, "buy", order_size, current_price,
                        take_profit=tp, stop_loss=sl,
                        trailing_tp=trailing_tp, trailing_sl=trailing_sl,
                        leverage=lev
                    )

                elif action == "SHORT":
                    trailing_tp = current_price * (1 - trailing_callback)
                    trailing_sl = current_price * (1 + trailing_callback)
                    logging.info(
                        f"{mode} | üî¥ SHORT OPEN | {symbol} @ {current_price:.4f} | size={order_size:.6f} | Lev={lev}x "
                        f"| TP={tp:.4f} | SL={sl:.4f} | TR_TP={trailing_tp:.4f} | TR_SL={trailing_sl:.4f}"
                    )
                    await api_manager.execute_limit_order(
                        symbol, "sell", order_size, current_price,
                        take_profit=tp, stop_loss=sl,
                        trailing_tp=trailing_tp, trailing_sl=trailing_sl,
                        leverage=lev
                    )

                elif action == "CLOSE_LONG":
                    logging.info(f"{mode} | üü£ CLOSE LONG | {symbol} @ {current_price:.4f} | size={order_size:.6f}")
                    await api_manager.close_position(symbol, "buy", order_size)

                elif action == "CLOSE_SHORT":
                    logging.info(f"{mode} | üü£ CLOSE SHORT | {symbol} @ {current_price:.4f} | size={order_size:.6f}")
                    await api_manager.close_position(symbol, "sell", order_size)

                else:
                    logging.info(f"{mode} | ‚ö™ HOLD | {symbol} | Price={current_price:.4f}")

            await asyncio.sleep(60)

        except Exception as e:
            if await bug_fixer.analyze_and_fix(e, trader, env):
                logging.info("‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏ö‡∏±‡πä‡∏Å‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à ‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏ï‡πà‡∏≠")
                continue
            logging.critical(f"‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡∏£‡πâ‡∏≤‡∏¢‡πÅ‡∏£‡∏á: {e}")
            traceback.print_exc()
            await risk_guardian.emergency_stop()
            break


if __name__ == "__main__":
    asyncio.run(main())
