# ===============================================
# APIManager Class
# จัดการการเชื่อมต่อ API กับ Binance Futures
# ใช้ GlobalConfig สำหรับค่าพารามิเตอร์ทั้งหมด
# ===============================================

# ติดตั้งไลบรารีที่ต้องใช้สำหรับคลาสนี้ (รันคำสั่งใน terminal ก่อนใช้งาน)
# pip install ccxt tenacity

import logging
import logging.handlers
import time
import asyncio
from collections import deque
from typing import Optional, Dict, Any
import ccxt.async_support as ccxt_async
from tenacity import retry, wait_exponential, stop_after_attempt
#from config import GlobalConfig

# การตั้งค่าระบบบันทึก log เฉพาะสำหรับคลาสนี้
log_level_str = GlobalConfig.get('log_level', 'INFO').upper()
log_level = getattr(logging, log_level_str, logging.INFO)
logging.basicConfig(
    level=log_level,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.handlers.RotatingFileHandler('apimanager.log', maxBytes=10*1024*1024, backupCount=5),
        logging.StreamHandler()
    ]
)

class APIManager:
    """จัดการการเชื่อมต่อและคำสั่งผ่าน Binance Futures API"""

    def __init__(self):
        self.weight_used: int = 0
        self.weight_limit: int = GlobalConfig.get('rate_limit_per_minute')
        self.last_reset: float = time.time()
        self.is_rate_limited: bool = False
        self.ban_until: float = 0
        self.request_count: int = 0
        self.rate_limit_status: Dict[str, int] = {}
        self.kpi_priority_weight: float = 0
        self.api_call_timestamps: deque = deque(maxlen=GlobalConfig.get('rate_limit_per_minute'))
        self.time_offset: int = 0
        self.last_time_sync: float = time.time()
        self.max_leverage_per_symbol: Dict[str, int] = GlobalConfig.get('max_leverage_per_symbol', {})
        self.trailing_orders: Dict[str, Dict[str, Any]] = {}
        self.markets: Optional[Dict] = None
        self.exchange = ccxt_async.binance({
            'apiKey': GlobalConfig.get('binance_api_key'),
            'secret': GlobalConfig.get('binance_api_secret'),
            'enableRateLimit': True,
            'timeout': GlobalConfig.get('api_timeout') * 1000,
            'options': {
                'defaultType': 'future',
                'adjustForTimeDifference': True
            },
            'rateLimit': int(60000 / GlobalConfig.get('rate_limit_per_minute'))
        })

    async def close(self):
        """ปิดการเชื่อมต่อ exchange"""
        if self.exchange:
            await self.exchange.close()

    async def sync_time_with_exchange(self) -> bool:
        """ซิงโครไนซ์เวลากับเซิร์ฟเวอร์ Binance"""
        if GlobalConfig.get('dry_run'):
            logging.info("จำลองการซิงค์เวลา: timeOffset = 0")
            self.time_offset = 0
            self.last_time_sync = time.time()
            return True
        await self.rate_limit_control()
        try:
            server_time = await self.exchange.fetch_time()
            local_time = int(time.time() * 1000)
            self.time_offset = server_time - local_time
            self.last_time_sync = time.time()
            logging.info(f"ซิงค์เวลาสำเร็จ: timeOffset = {self.time_offset} มิลลิวินาที")
            return True
        except Exception as e:
            logging.error(f"ซิงค์เวลาล้มเหลว: {e}")
            self.time_offset = 0
            return False

    async def get_adjusted_timestamp(self) -> int:
        """คืนค่า timestamp ที่ปรับตาม timeOffset (มิลลิวินาที)"""
        return int(time.time() * 1000) + self.time_offset

    async def update_weight(self, response: Any):
        """อัพเดทน้ำหนัก API และรีเซ็ตทุก 60 วินาที"""
        if time.time() - self.last_reset >= 60:
            self.weight_used = 0
            self.rate_limit_status = {}
            self.last_reset = time.time()

    async def rate_limit_control(self):
        """ควบคุม rate limit เพื่อป้องกันการถูกแบนจาก Binance"""
        now = time.time()
        if now - self.last_time_sync >= GlobalConfig.get('sync_time_interval'):
            await self.sync_time_with_exchange()
        if self.is_rate_limited and now < self.ban_until:
            wait_time = self.ban_until - now
            logging.warning(f"ถูกจำกัด IP รอ {wait_time:.2f} วินาที")
            await asyncio.sleep(wait_time)
            self.is_rate_limited = False
        if self.weight_used >= self.weight_limit * 0.9:
            wait_time = 60 - (now - self.last_reset)
            if wait_time > 0:
                logging.warning(f"น้ำหนัก API ใกล้เต็ม รอ {wait_time:.2f} วินาที")
                await asyncio.sleep(wait_time)
            self.weight_used = 0
            self.last_reset = now
        self.api_call_timestamps.append(now)
        self.request_count += 1
        if len(self.api_call_timestamps) >= self.weight_limit:
            wait_time = (60 / self.weight_limit) - (now - self.api_call_timestamps[0])
            if wait_time > 0:
                await asyncio.sleep(wait_time)

    async def optimize_api_usage(self, kpi_tracker: Optional[Any] = None):
        """ปรับการใช้งาน API ตาม KPI และน้ำหนักที่ใช้"""
        if self.weight_used > self.weight_limit * 0.5:
            logging.info("ปรับ interval การเรียก API ช้าลงเนื่องจากน้ำหนักใช้งานเกินครึ่ง")
        if kpi_tracker and hasattr(kpi_tracker, 'total_profit') and kpi_tracker.total_profit < GlobalConfig.get('min_daily_kpi'):
            self.kpi_priority_weight += 0.1
            logging.info(f"เพิ่มน้ำหนัก priority สำหรับ KPI: {self.kpi_priority_weight:.2f}")
        self.request_count = 0

    @retry(wait=wait_exponential(multiplier=1, min=4, max=60), stop=stop_after_attempt(GlobalConfig.get('max_api_retries')))
    async def fetch_max_leverage(self) -> Dict[str, int]:
        """ดึงข้อมูล leverage สูงสุดสำหรับแต่ละเหรียญ"""
        await self.rate_limit_control()
        if GlobalConfig.get('dry_run'):
            logging.info("จำลองการดึง max_leverage")
            return self.max_leverage_per_symbol
        try:
            info = await self.exchange.fetch_exchange_info(params={'recvWindow': 5000, 'timestamp': await self.get_adjusted_timestamp()})
            max_leverage = {}
            for symbol_info in info['symbols']:
                symbol = symbol_info['symbol']
                if symbol.endswith('USDT'):
                    max_lev = 125
                    for filt in symbol_info.get('filters', []):
                        if filt['filterType'] == 'LEVERAGE_BRACKET':
                            brackets = filt.get('brackets', [])
                            if brackets:
                                max_lev = max(br.get('initialLeverage', 125) for br in brackets)
                            break
                    max_leverage[symbol] = int(max_lev)
            self.max_leverage_per_symbol = max_leverage
            GlobalConfig.set('max_leverage_per_symbol', max_leverage)
            await self.update_weight(info)
            logging.info(f"ดึง max_leverage สำเร็จ: {len(max_leverage)} เหรียญ")
            return max_leverage
        except Exception as e:
            logging.error(f"ดึง max_leverage ล้มเหลว: {e}")
            raise

    async def set_margin_mode(self, symbol: str) -> Optional[Dict]:
        """ตั้งค่า margin mode (CROSS หรือ ISOLATED) สำหรับเหรียญ"""
        mode = GlobalConfig.get('margin_mode').upper() if GlobalConfig.get('margin_mode').upper() in ['CROSS', 'ISOLATED'] else 'CROSS'
        await self.rate_limit_control()
        if GlobalConfig.get('dry_run'):
            logging.info(f"จำลองการตั้ง margin mode สำหรับ {symbol} เป็น {mode}")
            return {'status': 'success'}
        try:
            response = await self.exchange.set_margin_mode(mode.lower(), symbol, params={'type': 'future', 'recvWindow': 5000, 'timestamp': await self.get_adjusted_timestamp()})
            await self.update_weight(response)
            logging.info(f"ตั้ง margin mode สำหรับ {symbol} เป็น {mode} สำเร็จ")
            return response
        except Exception as e:
            logging.error(f"ตั้ง margin mode สำหรับ {symbol} ล้มเหลว: {e}")
            return None

    async def set_leverage(self, symbol: str, leverage: int) -> Optional[Dict]:
        """ตั้งค่า leverage โดยจำกัดระหว่าง min_leverage และ max_leverage"""
        max_lev = self.max_leverage_per_symbol.get(symbol, 125)
        adjusted_leverage = max(GlobalConfig.get('min_leverage'), min(int(leverage), max_lev))
        await self.rate_limit_control()
        if GlobalConfig.get('dry_run'):
            logging.info(f"จำลองการตั้ง leverage สำหรับ {symbol} เป็น {adjusted_leverage}")
            return {'status': 'success'}
        try:
            response = await self.exchange.set_leverage(adjusted_leverage, symbol, params={'type': 'future', 'recvWindow': 5000, 'timestamp': await self.get_adjusted_timestamp()})
            await self.update_weight(response)
            logging.info(f"ตั้ง leverage สำหรับ {symbol} เป็น {adjusted_leverage} สำเร็จ")
            return response
        except Exception as e:
            logging.error(f"ตั้ง leverage สำหรับ {symbol} ล้มเหลว: {e}")
            return None

    async def create_limit_order_with_trailing(self, symbol: str, side: str, amount: float, price: float, callback_rate: Optional[float] = None, activation_price: Optional[float] = None) -> Optional[Dict]:
        """สร้าง limit order พร้อม Trailing Stop Loss และ Take Profit"""
        callback_rate = callback_rate or GlobalConfig.get('trailing_callback_rate')
        await self.rate_limit_control()
        if GlobalConfig.get('dry_run'):
            logging.info(f"จำลองการสร้าง limit order พร้อม trailing SL/TP สำหรับ {symbol}: {side} {amount} @{price}, callback {callback_rate}%")
            return {'order_id': 'simulated_order_id', 'sl_order_id': 'simulated_sl_id', 'tp_order_id': 'simulated_tp_id', 'status': 'success'}
        try:
            order_params = {
                'timeInForce': 'GTC',
                'recvWindow': 5000,
                'timestamp': await self.get_adjusted_timestamp()
            }
            order = await self.exchange.create_order(symbol, 'limit', side.lower(), amount, price, order_params)
            await self.update_weight(order)
            logging.info(f"สร้าง limit order สำหรับ {symbol} สำเร็จ: ID {order['id']}")
            opposite_side = 'sell' if side.lower() == 'buy' else 'buy'
            sl_params = {
                'type': 'TRAILING_STOP_MARKET',
                'callbackRate': callback_rate,
                'reduceOnly': True,
                'recvWindow': 5000,
                'timestamp': await self.get_adjusted_timestamp()
            }
            if activation_price:
                sl_params['activationPrice'] = activation_price if side.lower() == 'buy' else price * (1 + callback_rate / 100)
            sl_order = await self.exchange.create_order(symbol, 'market', opposite_side, amount, None, sl_params)
            await self.update_weight(sl_order)
            tp_params = {
                'type': 'TRAILING_STOP_MARKET',
                'callbackRate': callback_rate,
                'reduceOnly': True,
                'recvWindow': 5000,
                'timestamp': await self.get_adjusted_timestamp()
            }
            if activation_price:
                tp_params['activationPrice'] = activation_price if side.lower() == 'sell' else price * (1 - callback_rate / 100)
            tp_order = await self.exchange.create_order(symbol, 'market', opposite_side, amount, None, tp_params)
            await self.update_weight(tp_order)
            self.trailing_orders[symbol] = {
                'order_id': order['id'],
                'sl_order_id': sl_order['id'],
                'tp_order_id': tp_order['id'],
                'last_price': price,
                'side': side.lower(),
                'amount': amount
            }
            logging.info(f"สร้าง trailing SL/TP สำเร็จ: SL ID {sl_order['id']}, TP ID {tp_order['id']}")
            return {
                'order_id': order['id'],
                'sl_order_id': sl_order['id'],
                'tp_order_id': tp_order['id'],
                'status': 'success'
            }
        except Exception as e:
            logging.error(f"สร้าง limit order พร้อม trailing SL/TP สำหรับ {symbol} ล้มเหลว: {e}")
            return None

    async def update_trailing_orders(self, symbol: str, current_price: float, volatility: Optional[float] = None) -> bool:
        """อัพเดท Trailing Stop Loss และ Take Profit ตามราคาปัจจุบันและความผันผวน"""
        if symbol not in self.trailing_orders:
            return False
        callback_rate = GlobalConfig.get('trailing_callback_rate')
        if volatility:
            vol_threshold = GlobalConfig.get('min_volatility_threshold', 0.005)
            callback_rate = max(callback_rate, min(2.0, callback_rate * (1 + volatility / vol_threshold)))
        order_info = self.trailing_orders[symbol]
        side = order_info['side']
        amount = order_info['amount']
        opposite_side = 'sell' if side == 'buy' else 'buy'
        try:
            await self.cancel_order(symbol, order_info['sl_order_id'])
            await self.cancel_order(symbol, order_info['tp_order_id'])
            sl_params = {
                'type': 'TRAILING_STOP_MARKET',
                'callbackRate': callback_rate,
                'reduceOnly': True,
                'recvWindow': 5000,
                'timestamp': await self.get_adjusted_timestamp()
            }
            sl_order = await self.exchange.create_order(symbol, 'market', opposite_side, amount, None, sl_params)
            await self.update_weight(sl_order)
            tp_params = {
                'type': 'TRAILING_STOP_MARKET',
                'callbackRate': callback_rate,
                'reduceOnly': True,
                'recvWindow': 5000,
                'timestamp': await self.get_adjusted_timestamp()
            }
            tp_order = await self.exchange.create_order(symbol, 'market', opposite_side, amount, None, tp_params)
            await self.update_weight(tp_order)
            self.trailing_orders[symbol].update({
                'sl_order_id': sl_order['id'],
                'tp_order_id': tp_order['id'],
                'last_price': current_price
            })
            logging.info(f"อัพเดท trailing SL/TP สำหรับ {symbol} สำเร็จ: SL ID {sl_order['id']}, TP ID {tp_order['id']}")
            return True
        except Exception as e:
            logging.error(f"อัพเดท trailing SL/TP สำหรับ {symbol} ล้มเหลว: {e}")
            return False

    async def create_limit_order(self, symbol: str, side: str, amount: float, price: float, params: Dict = {}) -> Optional[Dict]:
        """สร้าง limit order ธรรมดา"""
        await self.rate_limit_control()
        if GlobalConfig.get('dry_run'):
            logging.info(f"จำลองการสร้าง limit order สำหรับ {symbol}: {side} {amount} @{price}")
            return {'id': 'simulated_order_id', 'status': 'success'}
        try:
            full_params = {**params, 'recvWindow': 5000, 'timestamp': await self.get_adjusted_timestamp()}
            order = await self.exchange.create_order(symbol, 'limit', side.lower(), amount, price, full_params)
            await self.update_weight(order)
            logging.info(f"สร้าง limit order สำหรับ {symbol} สำเร็จ: ID {order['id']}")
            return order
        except Exception as e:
            logging.error(f"สร้าง limit order สำหรับ {symbol} ล้มเหลว: {e}")
            return None

    async def create_stop_order(self, symbol: str, side: str, amount: float, stop_price: float, params: Dict = {'reduceOnly': True}) -> Optional[Dict]:
        """สร้าง stop order (Stop Loss)"""
        full_params = {
            **params,
            'type': 'STOP_MARKET',
            'stopPrice': stop_price,
            'recvWindow': 5000,
            'timestamp': await self.get_adjusted_timestamp()
        }
        await self.rate_limit_control()
        if GlobalConfig.get('dry_run'):
            logging.info(f"จำลองการสร้าง stop order สำหรับ {symbol}: {side} @{stop_price}")
            return {'id': 'simulated_stop_id', 'status': 'success'}
        try:
            order = await self.exchange.create_order(symbol, 'market', side.lower(), amount, None, full_params)
            await self.update_weight(order)
            logging.info(f"สร้าง stop order สำหรับ {symbol} สำเร็จ: ID {order['id']}")
            return order
        except Exception as e:
            logging.error(f"สร้าง stop order สำหรับ {symbol} ล้มเหลว: {e}")
            return None

    async def create_take_profit_order(self, symbol: str, side: str, amount: float, tp_price: float, params: Dict = {'reduceOnly': True}) -> Optional[Dict]:
        """สร้าง take profit order"""
        full_params = {
            **params,
            'type': 'TAKE_PROFIT_MARKET',
            'stopPrice': tp_price,
            'recvWindow': 5000,
            'timestamp': await self.get_adjusted_timestamp()
        }
        await self.rate_limit_control()
        if GlobalConfig.get('dry_run'):
            logging.info(f"จำลองการสร้าง take profit order สำหรับ {symbol}: {side} @{tp_price}")
            return {'id': 'simulated_tp_id', 'status': 'success'}
        try:
            order = await self.exchange.create_order(symbol, 'market', side.lower(), amount, None, full_params)
            await self.update_weight(order)
            logging.info(f"สร้าง take profit order สำหรับ {symbol} สำเร็จ: ID {order['id']}")
            return order
        except Exception as e:
            logging.error(f"สร้าง take profit order สำหรับ {symbol} ล้มเหลว: {e}")
            return None

    async def update_order(self, symbol: str, order_id: str, params: Dict) -> Optional[Dict]:
        """อัพเดทคำสั่งที่มีอยู่"""
        await self.rate_limit_control()
        if GlobalConfig.get('dry_run'):
            logging.info(f"จำลองการอัพเดท order ID {order_id} สำหรับ {symbol}")
            return {'status': 'success'}
        try:
            full_params = {**params, 'recvWindow': 5000, 'timestamp': await self.get_adjusted_timestamp()}
            response = await self.exchange.edit_order(order_id, symbol, None, None, None, None, full_params)
            await self.update_weight(response)
            logging.info(f"อัพเดท order ID {order_id} สำหรับ {symbol} สำเร็จ")
            return response
        except Exception as e:
            logging.error(f"อัพเดท order ID {order_id} ล้มเหลว: {e}")
            return None

    async def cancel_order(self, symbol: str, order_id: str) -> Optional[Dict]:
        """ยกเลิกคำสั่ง"""
        await self.rate_limit_control()
        if GlobalConfig.get('dry_run'):
            logging.info(f"จำลองการยกเลิก order ID {order_id} สำหรับ {symbol}")
            return {'status': 'success'}
        try:
            params = {'recvWindow': 5000, 'timestamp': await self.get_adjusted_timestamp()}
            response = await self.exchange.cancel_order(order_id, symbol, params=params)
            await self.update_weight(response)
            logging.info(f"ยกเลิก order ID {order_id} สำหรับ {symbol} สำเร็จ")
            if symbol in self.trailing_orders and (order_id == self.trailing_orders[symbol].get('sl_order_id') or order_id == self.trailing_orders[symbol].get('tp_order_id')):
                del self.trailing_orders[symbol]
            return response
        except Exception as e:
            logging.error(f"ยกเลิก order ID {order_id} ล้มเหลว: {e}")
            return None

    async def check_symbol_exists(self, symbol: str) -> bool:
        """ตรวจสอบว่าเหรียญมีอยู่ใน Binance Futures"""
        await self.rate_limit_control()
        try:
            if self.markets is None:
                self.markets = await self.exchange.load_markets(params={'recvWindow': 5000, 'timestamp': await self.get_adjusted_timestamp()})
            return symbol in self.markets
        except Exception as e:
            logging.error(f"ตรวจสอบ symbol {symbol} ล้มเหลว: {e}")
            return False

    async def check_balance(self, asset: str = 'USDT') -> Dict:
        """ตรวจสอบยอดเงินในบัญชี Futures"""
        await self.rate_limit_control()
        if GlobalConfig.get('dry_run'):
            return {'free': 1000.0, 'total': 1000.0}
        try:
            balance = await self.exchange.fetch_balance(params={'type': 'future', 'recvWindow': 5000, 'timestamp': await self.get_adjusted_timestamp()})
            await self.update_weight(balance)
            return balance.get(asset, {'free': 0, 'total': 0})
        except Exception as e:
            logging.error(f"ตรวจสอบ balance ล้มเหลว: {e}")
            return {'free': 0, 'total': 0}

    async def predict_usage(self) -> float:
        """คาดการณ์การใช้งาน API ในอนาคต (60 วินาทีข้างหน้า)"""
        usage_history = [self.weight_used] * 60
        return sum(usage_history) / len(usage_history) if usage_history else 0
