# =============================================== 
# APIManager Class (Clean Logging + Limit Trading + TP/SL + Trailing + Auto Update + Live Config Sync)
# ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ API ‡∏Å‡∏±‡∏ö Binance Futures (‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö dry_run ‡∏™‡∏î‡∏à‡∏≤‡∏Å GlobalConfig)
# ===============================================

# pip install -U ccxt tenacity pandas

import logging
import logging.handlers
import time
import asyncio
from collections import deque
from typing import Optional, Dict, Any, List
import ccxt.async_support as ccxt_async
from tenacity import retry, wait_exponential, stop_after_attempt
import pandas as pd
from config import GlobalConfig


# ---------------- Logging ----------------
log_level_str = GlobalConfig.get('log_level', 'INFO').upper()
log_level = getattr(logging, log_level_str, logging.INFO)
logging.basicConfig(
    level=log_level,
    format="%(asctime)s - %(levelname)s - %(message)s",
    handlers=[
        logging.handlers.RotatingFileHandler('apimanager.log', maxBytes=10 * 1024 * 1024, backupCount=5),
        logging.StreamHandler()
    ]
)


class APIManager:
    """‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡πÅ‡∏•‡∏∞‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏ú‡πà‡∏≤‡∏ô Binance Futures API"""

    def __init__(self):
        self._load_config()
        self.weight_used = 0
        self.last_reset = time.time()
        self.is_rate_limited = False
        self.ban_until = 0
        self.api_call_timestamps = deque(maxlen=self.rate_limit)
        self.last_time_sync = time.time()
        self.markets: Optional[Dict] = None
        self.trailing_orders: Dict[str, Dict[str, Any]] = {}

        # ‚úÖ ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ Binance Futures
        self.exchange = self._create_exchange()

        # ‚úÖ ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏ï‡∏±‡∏ß‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö config ‡∏™‡∏î
        asyncio.create_task(self._monitor_config_changes())
        logging.info(f"üîÑ Real-Time Sync Enabled | Margin Mode = {self.margin_mode.upper()} | DryRun = {self.dry_run}")

    # ============================================================
    # CONFIG HANDLING
    # ============================================================
    def _load_config(self):
        """‡πÇ‡∏´‡∏•‡∏î‡∏Ñ‡πà‡∏≤‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏à‡∏≤‡∏Å GlobalConfig"""
        try:
            self.api_key = GlobalConfig.get('binance_api_key')
            self.api_secret = GlobalConfig.get('binance_api_secret')
            self.dry_run = GlobalConfig.get('dry_run', False)
            self.max_api_retries = GlobalConfig.get('max_api_retries', 10)
            self.api_timeout = GlobalConfig.get('api_timeout', 30)
            self.rate_limit = GlobalConfig.get('rate_limit_per_minute', 2400)
            self.margin_mode = GlobalConfig.get('margin_mode', 'isolated')
            self.min_leverage = GlobalConfig.get('min_leverage', 50)
            self.trailing_callback_rate = GlobalConfig.get('trailing_callback_rate', 0.5)
            self.trailing_update_interval = GlobalConfig.get('trailing_update_interval', 60)
            self.sync_time_interval = GlobalConfig.get('sync_time_interval', 3600)
            self.futures_weight = GlobalConfig.get('futures_weight', 0.9)
        except Exception as e:
            logging.error(f"‚ö†Ô∏è Config Load Error: {e}")

    async def _monitor_config_changes(self):
        """‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÅ‡∏•‡∏∞‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏Ñ‡πà‡∏≤‡∏à‡∏≤‡∏Å GlobalConfig ‡πÅ‡∏ö‡∏ö‡πÄ‡∏£‡∏µ‡∏¢‡∏•‡πÑ‡∏ó‡∏°‡πå"""
        last_snapshot = {}
        while True:
            try:
                current = {
                    'dry_run': GlobalConfig.get('dry_run', False),
                    'margin_mode': GlobalConfig.get('margin_mode', 'isolated'),
                    'api_timeout': GlobalConfig.get('api_timeout', 30),
                    'rate_limit_per_minute': GlobalConfig.get('rate_limit_per_minute', 2400),
                    'trailing_callback_rate': GlobalConfig.get('trailing_callback_rate', 0.5),
                    'trailing_update_interval': GlobalConfig.get('trailing_update_interval', 60),
                }

                for key, new_value in current.items():
                    old_value = last_snapshot.get(key)
                    if old_value is not None and old_value != new_value:
                        setattr(self, key if key != 'rate_limit_per_minute' else 'rate_limit', new_value)
                        logging.info(f"üîÅ [Config Sync] {key} ‡∏ñ‡∏π‡∏Å‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô: {old_value} ‚Üí {new_value}")
                        if key in ['api_timeout', 'margin_mode']:
                            self._reconnect_exchange()
                    last_snapshot[key] = new_value
            except Exception as e:
                logging.warning(f"‚ö†Ô∏è Config Monitor Error: {e}")
            await asyncio.sleep(5)

    def _reconnect_exchange(self):
        """‡∏£‡∏µ‡∏™‡∏£‡πâ‡∏≤‡∏á connection ‡πÉ‡∏´‡∏°‡πà‡πÄ‡∏°‡∏∑‡πà‡∏≠ config ‡∏™‡∏≥‡∏Ñ‡∏±‡∏ç‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô"""
        try:
            asyncio.create_task(self.exchange.close())
        except Exception:
            pass
        self.exchange = self._create_exchange()
        logging.info("‚ôªÔ∏è Exchange Reconnected with updated configuration")

    def _create_exchange(self):
        """‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ Binance Futures ‡∏ú‡πà‡∏≤‡∏ô ccxt"""
        return ccxt_async.binance({
            'apiKey': self.api_key,
            'secret': self.api_secret,
            'enableRateLimit': True,
            'timeout': self.api_timeout * 1000,
            'options': {
                'defaultType': 'future',
                'adjustForTimeDifference': True,
                'defaultMarginMode': self.margin_mode
            },
            'rateLimit': int(60000 / self.rate_limit)
        })

    # ============================================================
    # BASIC FUNCTIONS
    # ============================================================
    async def close(self):
        if self.exchange:
            await self.exchange.close()

    async def sync_time_with_exchange(self) -> bool:
        """‡∏ã‡∏¥‡∏á‡πÇ‡∏Ñ‡∏£‡πÑ‡∏ô‡∏ã‡πå‡πÄ‡∏ß‡∏•‡∏≤"""
        if self.dry_run:
            self.last_time_sync = time.time()
            logging.info("üß™ ‡∏à‡∏≥‡∏•‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏ã‡∏¥‡∏á‡∏Ñ‡πå‡πÄ‡∏ß‡∏•‡∏≤: timeOffset = 0")
            return True
        await self.rate_limit_control()
        try:
            server_time = await self.exchange.fetch_time()
            local_time = int(time.time() * 1000)
            self.time_offset = server_time - local_time
            self.last_time_sync = time.time()
            logging.info(f"üïí Sync OK | Offset={self.time_offset} ms")
            return True
        except Exception as e:
            logging.warning(f"‚ö†Ô∏è Sync Time Failed: {e}")
            self.time_offset = 0
            return False

    async def rate_limit_control(self):
        now = time.time()
        if now - self.last_time_sync >= self.sync_time_interval:
            await self.sync_time_with_exchange()
        if self.is_rate_limited and now < self.ban_until:
            await asyncio.sleep(self.ban_until - now)
            self.is_rate_limited = False
        if self.weight_used >= self.rate_limit * 0.9:
            wait_time = 60 - (now - self.last_reset)
            if wait_time > 0:
                logging.info(f"‚è≥ API Cooldown {wait_time:.2f}s")
                await asyncio.sleep(wait_time)
            self.weight_used = 0
            self.last_reset = now
        self.api_call_timestamps.append(now)

    # ============================================================
    # HISTORICAL DATA
    # ============================================================
    @retry(wait=wait_exponential(multiplier=1, min=3, max=60), stop=stop_after_attempt(5))
    async def fetch_all_usdt_historical(
        self, timeframe: str = "1h", limit: int = 1000,
        since: Optional[int] = None, delay_per_request: float = 0.2
    ) -> Dict[str, pd.DataFrame]:
        """‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏¢‡πâ‡∏≠‡∏ô‡∏´‡∏•‡∏±‡∏á‡∏ó‡∏∏‡∏Å‡∏Ñ‡∏π‡πà USDT"""
        await self.rate_limit_control()
        results = {}
        try:
            if not self.markets:
                self.markets = await self.exchange.load_markets(params={'type': 'future'})
            usdt_pairs = [s for s in self.markets if s.endswith('/USDT')]
            total = len(usdt_pairs)
            logging.info(f"üìä ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏¢‡πâ‡∏≠‡∏ô‡∏´‡∏•‡∏±‡∏á {total} ‡πÄ‡∏´‡∏£‡∏µ‡∏¢‡∏ç (tf={timeframe})")

            for idx, symbol in enumerate(usdt_pairs, 1):
                try:
                    data = await self.exchange.fetch_ohlcv(symbol, timeframe=timeframe, limit=limit, since=since)
                    df = pd.DataFrame(data, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
                    df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms', utc=True)
                    results[symbol] = df
                    logging.debug(f"[{idx}/{total}] {symbol}: {len(df)} rows")
                except Exception as e:
                    logging.warning(f"[{idx}/{total}] ‚ö†Ô∏è {symbol}: {e}")
                await asyncio.sleep(delay_per_request)

            logging.info(f"‚úÖ ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏¢‡πâ‡∏≠‡∏ô‡∏´‡∏•‡∏±‡∏á‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à {len(results)} ‡πÄ‡∏´‡∏£‡∏µ‡∏¢‡∏ç")
            return results
        except Exception as e:
            logging.error(f"‚ùå Fetch Historical Error: {e}")
            return {}

    # ============================================================
    # ORDER MANAGEMENT (‡∏õ‡∏£‡∏±‡∏ö‡πÉ‡∏´‡πâ‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡∏ï‡∏≤‡∏° Binance Futures API v2)
    # ============================================================
    async def execute_limit_order(
        self, symbol: str, side: str, amount: float,
        price: float, take_profit: float = None, stop_loss: float = None,
        trailing_tp: float = None, trailing_sl: float = None,
        leverage: int = 20
    ):
        """‚úÖ ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á Limit Order ‡∏û‡∏£‡πâ‡∏≠‡∏° TP, SL, Trailing"""
        await self.rate_limit_control()
        leverage = max(leverage, self.min_leverage)

        if self.dry_run:
            logging.info(f"üß™ [DryRun] ‡∏à‡∏≥‡∏•‡∏≠‡∏á‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á: {side.upper()} {symbol} {amount}@{price}")
            return None

        try:
            await self.exchange.set_leverage(leverage, symbol)
            await self.exchange.set_margin_mode(self.margin_mode, symbol)

            params = {
                "reduceOnly": False,
                "positionSide": "LONG" if side.lower() == "buy" else "SHORT",
                "workingType": "MARK_PRICE",
                "timeInForce": "GTC",
                "type": "future"
            }

            order = await self.exchange.create_order(
                symbol=symbol,
                type="LIMIT",
                side=side.lower(),
                amount=amount,
                price=price,
                params=params
            )

            logging.info(f"‚úÖ Limit {side.upper()} {symbol} @ {price} | Lev={leverage}x | Margin={self.margin_mode.upper()}")

            if take_profit:
                await self._create_tp(symbol, side, amount, take_profit)
            if stop_loss:
                await self._create_sl(symbol, side, amount, stop_loss)

            if trailing_tp or trailing_sl:
                self.trailing_orders[symbol] = {
                    "side": side,
                    "amount": amount,
                    "tp": trailing_tp,
                    "sl": trailing_sl,
                    "last_update": time.time()
                }
                logging.info(f"üåÄ ‡∏ï‡∏±‡πâ‡∏á Trailing Order: TP={trailing_tp}, SL={trailing_sl}")
            return order
        except Exception as e:
            logging.error(f"‚ùå Limit Order Error: {e}")
            return None

    async def _create_tp(self, symbol: str, side: str, amount: float, price: float):
        """Take-Profit Market Order"""
        opposite = "sell" if side.lower() == "buy" else "buy"
        try:
            await self.exchange.create_order(
                symbol=symbol,
                type="TAKE_PROFIT_MARKET",
                side=opposite,
                amount=amount,
                params={
                    "stopPrice": round(price, 2),
                    "reduceOnly": True,
                    "closePosition": True,
                    "workingType": "MARK_PRICE",
                    "positionSide": "LONG" if side.lower() == "buy" else "SHORT"
                }
            )
            logging.info(f"üéØ ‡∏ï‡∏±‡πâ‡∏á Take-Profit {symbol} ‡∏ó‡∏µ‡πà {price}")
        except Exception as e:
            logging.warning(f"‚ö†Ô∏è TP Error {symbol}: {e}")

    async def _create_sl(self, symbol: str, side: str, amount: float, price: float):
        """Stop-Loss Market Order"""
        opposite = "sell" if side.lower() == "buy" else "buy"
        try:
            await self.exchange.create_order(
                symbol=symbol,
                type="STOP_MARKET",
                side=opposite,
                amount=amount,
                params={
                    "stopPrice": round(price, 2),
                    "reduceOnly": True,
                    "closePosition": True,
                    "workingType": "MARK_PRICE",
                    "positionSide": "LONG" if side.lower() == "buy" else "SHORT"
                }
            )
            logging.info(f"üõë ‡∏ï‡∏±‡πâ‡∏á Stop-Loss {symbol} ‡∏ó‡∏µ‡πà {price}")
        except Exception as e:
            logging.warning(f"‚ö†Ô∏è SL Error {symbol}: {e}")

    # ============================================================
    # TRAILING MANAGEMENT
    # ============================================================
    async def monitor_trailing_orders(self):
        """‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÅ‡∏•‡∏∞‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï Trailing Orders ‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥"""
        while True:
            try:
                for symbol, info in list(self.trailing_orders.items()):
                    side = info['side']
                    tp = info.get('tp')
                    sl = info.get('sl')

                    ticker = await self.exchange.fetch_ticker(symbol)
                    price = ticker['last']

                    if tp and ((side == "buy" and price > tp) or (side == "sell" and price < tp)):
                        new_tp = price * (1 + self.trailing_callback_rate / 100 if side == "buy" else 1 - self.trailing_callback_rate / 100)
                        info['tp'] = new_tp
                        await self._create_tp(symbol, side, info['amount'], new_tp)
                        logging.info(f"üîÅ ‡∏õ‡∏£‡∏±‡∏ö TP ‡πÉ‡∏´‡∏°‡πà {symbol} ‚Üí {new_tp:.4f}")

                    if sl and ((side == "buy" and price < sl) or (side == "sell" and price > sl)):
                        new_sl = price * (1 - self.trailing_callback_rate / 100 if side == "buy" else 1 + self.trailing_callback_rate / 100)
                        info['sl'] = new_sl
                        await self._create_sl(symbol, side, info['amount'], new_sl)
                        logging.info(f"üîÅ ‡∏õ‡∏£‡∏±‡∏ö SL ‡πÉ‡∏´‡∏°‡πà {symbol} ‚Üí {new_sl:.4f}")
                await asyncio.sleep(self.trailing_update_interval)
            except Exception as e:
                logging.error(f"‚ö†Ô∏è Trailing Monitor Error: {e}")
                await asyncio.sleep(10)

    # ============================================================
    # CLOSE POSITION
    # ============================================================
    async def close_position(self, symbol: str, side: str, amount: float):
        opposite = "sell" if side.lower() == "buy" else "buy"
        if self.dry_run:
            logging.info(f"üß™ [DryRun] ‡∏à‡∏≥‡∏•‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏õ‡∏¥‡∏î‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞ {side.upper()} {symbol}")
            return True
        try:
            await self.exchange.create_order(
                symbol=symbol,
                type="MARKET",
                side=opposite,
                amount=amount,
                params={
                    "reduceOnly": True,
                    "closePosition": True,
                    "positionSide": "LONG" if side.lower() == "buy" else "SHORT"
                }
            )
            logging.info(f"üö™ ‡∏õ‡∏¥‡∏î‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞ {side.upper()} {symbol}")
        except Exception as e:
            logging.error(f"‚ùå ‡∏õ‡∏¥‡∏î‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß {symbol}: {e}")
