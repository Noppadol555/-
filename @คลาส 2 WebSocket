# ===============================================
# websocket_manager.py  (Auto Fetch All USDT Pairs for Binance Futures ‚Ä¢ Safe Funding Rate)
# ===============================================

import json
import asyncio
import time
import logging
import logging.handlers
import sqlite3
import websockets
import aiohttp
from datetime import timedelta
from tenacity import retry, wait_exponential, stop_after_attempt
from config import GlobalConfig

# --------------------------- Logging ---------------------------
logging.basicConfig(
    level=getattr(logging, GlobalConfig.get("log_level", "INFO")),
    format="%(asctime)s - %(levelname)s - %(message)s",
    handlers=[
        logging.handlers.RotatingFileHandler(
            "websocketmanager.log", maxBytes=10 * 1024 * 1024, backupCount=5
        ),
        logging.StreamHandler(),
    ],
)

FSTREAM_BASE = "wss://fstream.binance.com"
DSTREAM_BASE = "wss://dstream.binance.com"


class WebSocketManager:
    """WebSocket Manager ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Binance Futures (‡∏û‡∏£‡πâ‡∏≠‡∏° funding_rate ‡∏õ‡∏•‡∏≠‡∏î‡∏†‡∏±‡∏¢)"""

    def __init__(self, exchange=None, time_offset: int = 0):
        self.public_base = FSTREAM_BASE
        self.backup_base = DSTREAM_BASE
        self.exchange = exchange
        self.time_offset = time_offset

        self.running = False
        self.subscribed_symbols = set()
        self.reconnect_attempts = 0
        self.max_reconnects = int(GlobalConfig.get("max_reconnects", 10))

        self.data = {}
        self.cache = {}
        self.listen_key = None
        self.start_time = None
        self.last_data_time = time.time()
        self.all_usdt_pairs = []
        self.balance_data = {"free": 0.0, "locked": 0.0}

        # --------- SQLite ---------
        self.db_conn = sqlite3.connect(
            GlobalConfig.get("db_path", "market.db"),
            timeout=10,
            check_same_thread=False  # ‚úÖ ‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô sqlite lock ‡∏Ç‡πâ‡∏≤‡∏° thread
        )
        self._init_db()

    # --------------------------- DB ---------------------------
    def _init_db(self):
        c = self.db_conn.cursor()
        c.execute(
            """CREATE TABLE IF NOT EXISTS ws_data (
                symbol TEXT,
                timestamp REAL,
                close REAL,
                volume REAL,
                funding_rate REAL,
                depth REAL
            )"""
        )
        self.db_conn.commit()

    async def _commit_safe(self):
        """‚úÖ commit ‡πÅ‡∏ö‡∏ö‡πÑ‡∏°‡πà‡∏ö‡∏•‡πá‡∏≠‡∏Ñ event loop"""
        try:
            await asyncio.to_thread(self.db_conn.commit)
        except Exception as e:
            logging.error(f"Commit failed: {e}")

    # ---------------------- Fetch all USDT pairs ----------------------
    async def fetch_all_usdt_pairs(self):
        """‡∏î‡∏∂‡∏á‡∏Ñ‡∏π‡πà‡πÄ‡∏´‡∏£‡∏µ‡∏¢‡∏ç‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏ó‡∏µ‡πà‡∏•‡∏á‡∏ó‡πâ‡∏≤‡∏¢‡∏î‡πâ‡∏ß‡∏¢ USDT ‡∏à‡∏≤‡∏Å Binance Futures"""
        url = "https://fapi.binance.com/fapi/v1/exchangeInfo"
        try:
            async with aiohttp.ClientSession() as session:
                async with session.get(url, timeout=aiohttp.ClientTimeout(total=15)) as resp:
                    data = await resp.json()
                    symbols = [
                        s["symbol"]
                        for s in data.get("symbols", [])
                        if s.get("contractType") == "PERPETUAL" and s["symbol"].endswith("USDT")
                    ]
                    self.all_usdt_pairs = sorted(symbols)
                    logging.info(f"‚úÖ ‡∏î‡∏∂‡∏á‡∏Ñ‡∏π‡πà‡πÄ‡∏´‡∏£‡∏µ‡∏¢‡∏ç USDT ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î {len(symbols)} ‡∏Ñ‡∏π‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à")
        except Exception as e:
            logging.error(f"‚ùå ‡∏î‡∏∂‡∏á‡∏Ñ‡∏π‡πà‡πÄ‡∏´‡∏£‡∏µ‡∏¢‡∏ç USDT ‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß: {e}")
            self.all_usdt_pairs = ["BTCUSDT", "ETHUSDT"]

    # ---------------------- Safe getter ----------------------
    def get_symbol_data(self, symbol: str) -> dict:
        """‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• symbol ‡∏û‡∏£‡πâ‡∏≠‡∏° fallback ‡∏õ‡∏•‡∏≠‡∏î‡∏†‡∏±‡∏¢ (‡∏Å‡∏±‡∏ô KeyError ‡∏ó‡∏∏‡∏Å‡∏Å‡∏£‡∏ì‡∏µ)"""
        d = self.data.get(symbol, {})
        return {
            "timestamp": d.get("timestamp", time.time()),
            "close": d.get("close", 0.0),
            "volume": d.get("volume", 0.0),
            "funding_rate": d.get("funding_rate", 0.0),
            "depth": d.get("depth", {}),
        }

    # üü¢ ‡∏Ñ‡∏∑‡∏ô‡∏Ñ‡πà‡∏≤‡∏£‡∏≤‡∏Ñ‡∏≤‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î
    def get_latest_price(self, symbol: str) -> float:
        try:
            return float(self.data.get(symbol, {}).get("close", 0.0))
        except Exception:
            return 0.0

    # üü¢ ‡∏Ñ‡∏∑‡∏ô‡∏Ñ‡πà‡∏≤‡∏¢‡∏≠‡∏î‡πÄ‡∏á‡∏¥‡∏ô‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î
    def get_latest_balance(self) -> float:
        try:
            return float(self.balance_data.get("free", GlobalConfig.get("initial_balance", 100.0)))
        except Exception:
            return GlobalConfig.get("initial_balance", 100.0)

    # ---------------------- ListenKey ----------------------
    async def create_listen_key(self) -> str | None:
        try:
            api_key = GlobalConfig.get("binance_api_key")
            if not api_key:
                logging.warning("‚ö†Ô∏è ‡πÑ‡∏°‡πà‡∏°‡∏µ BINANCE API KEY ‡πÉ‡∏ô config; ‡∏Ç‡πâ‡∏≤‡∏° user stream")
                return None
            async with aiohttp.ClientSession() as session:
                async with session.post(
                    "https://fapi.binance.com/fapi/v1/listenKey",
                    headers={"X-MBX-APIKEY": api_key},
                    timeout=aiohttp.ClientTimeout(total=10),
                ) as resp:
                    data = await resp.json()
                    self.listen_key = data.get("listenKey")
                    if self.listen_key:
                        logging.info(f"‡∏™‡∏£‡πâ‡∏≤‡∏á listenKey ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à: {self.listen_key[:10]}...")
                    return self.listen_key
        except Exception as e:
            logging.error(f"‡∏™‡∏£‡πâ‡∏≤‡∏á listenKey ‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß: {e}")
            return None

    async def keep_alive_loop(self):
        while self.running:
            await asyncio.sleep(1800)
            if not self.listen_key:
                continue
            try:
                api_key = GlobalConfig.get("binance_api_key")
                async with aiohttp.ClientSession() as session:
                    await session.put(
                        "https://fapi.binance.com/fapi/v1/listenKey",
                        headers={"X-MBX-APIKEY": api_key},
                        timeout=aiohttp.ClientTimeout(total=10),
                    )
                logging.debug("keep alive user stream ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à")
            except Exception as e:
                logging.error(f"keep alive user stream ‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß: {e}")

    async def _listen_user_stream(self, listen_key: str):
        url = f"{FSTREAM_BASE}/ws/{listen_key}"
        try:
            async with websockets.connect(url, ping_interval=20, ping_timeout=20) as ws:
                logging.info("‚úÖ ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ user stream ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à")
                while self.running:
                    raw = await ws.recv()
                    data = json.loads(raw)
                    await self._handle_user_data(data)
        except Exception as e:
            logging.error(f"user stream ‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß: {e}")

    # ---------------------- Public stream helpers ----------------------
    async def update_symbols(self, symbols: list[str]):
        new = {s.lower() + "@ticker" for s in symbols}
        self.subscribed_symbols = set(list(new)[:1024])
        logging.info(f"üì° ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏£‡∏≤‡∏¢‡∏Å‡∏≤‡∏£‡∏™‡∏±‡∏ç‡∏•‡∏±‡∏Å‡∏©‡∏ì‡πå {len(self.subscribed_symbols)} streams")

    def _build_public_url(self, base: str) -> str:
        streams = "/".join(sorted(self.subscribed_symbols))
        return f"{base}/stream?streams={streams}"

    # ---------------------- Main start ----------------------
    @retry(wait=wait_exponential(multiplier=1, min=3, max=60), stop=stop_after_attempt(10))
    async def start(self):
        await self.fetch_all_usdt_pairs()
        if not self.all_usdt_pairs:
            logging.error("‚ùå ‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏Ñ‡∏π‡πà USDT ‡πÉ‡∏î‡πÜ")
            return

        chunks = [self.all_usdt_pairs[i:i + 1024] for i in range(0, len(self.all_usdt_pairs), 1024)]
        for idx, chunk in enumerate(chunks):
            asyncio.create_task(self._start_chunk(chunk, idx))

    async def _start_chunk(self, symbols: list[str], group_idx: int = 0):
        await self.update_symbols(symbols)
        self.running = True
        self.start_time = time.time()

        asyncio.create_task(self.monitor_status_loop(10))
        asyncio.create_task(self.keep_alive_loop())

        if await self.create_listen_key():
            asyncio.create_task(self._listen_user_stream(self.listen_key))

        bases = [self.public_base, self.backup_base]
        idx = 0
        reconnects = 0

        while self.running:
            url = self._build_public_url(bases[idx])
            try:
                async with websockets.connect(url, ping_interval=20, ping_timeout=20) as ws:
                    logging.info(f"‚úÖ [{group_idx}] ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à {len(symbols)} ‡∏Ñ‡∏π‡πà")
                    while self.running:
                        try:
                            raw = await asyncio.wait_for(ws.recv(), timeout=30)
                            data = json.loads(raw)
                            await self._handle_public_message(data)
                        except asyncio.TimeoutError:
                            pong_waiter = await ws.ping()  # ‚úÖ ping ‡∏à‡∏£‡∏¥‡∏á
                            await pong_waiter
                            logging.debug(f"[{group_idx}] waiting data...")
            except Exception as e:
                reconnects += 1
                logging.warning(f"[{group_idx}] reconnect {reconnects} : {e}")
                await asyncio.sleep(min(5 * reconnects, 60))
                idx = (idx + 1) % len(bases)

    # ---------------------- Handlers ----------------------
    async def _handle_public_message(self, payload: dict):
        try:
            msg = payload.get("data", payload)
            symbol = msg.get("s")
            if not symbol:
                return

            price = float(msg.get("c", 0))
            vol = float(msg.get("v", 0))
            ts = time.time()
            self.last_data_time = ts  # ‚úÖ ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡πÄ‡∏ß‡∏•‡∏≤‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏£‡∏¥‡∏á

            funding_rate = await self._safe_fetch_funding_rate(symbol)
            self.data[symbol] = {
                "timestamp": ts,
                "close": price,
                "volume": vol,
                "funding_rate": funding_rate,
                "depth": {},
            }
            self.cache[symbol] = self.data[symbol]

            self.db_conn.execute(
                "INSERT INTO ws_data (symbol, timestamp, close, volume, funding_rate, depth) VALUES (?, ?, ?, ?, ?, ?)",
                (symbol, ts, price, vol, funding_rate, 0),
            )
            # ‚úÖ ‡πÉ‡∏ä‡πâ commit ‡πÅ‡∏ö‡∏ö async ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÑ‡∏°‡πà‡∏ö‡∏•‡πá‡∏≠‡∏Ñ event loop
            await self._commit_safe()

            logging.info(f"üìà {symbol} = {price:.2f} | Vol={vol:.2f} | FR={funding_rate:.6f}")
        except Exception as e:
            logging.error(f"‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô _handle_public_message: {e}")

    async def _safe_fetch_funding_rate(self, symbol: str) -> float:
        """‡∏î‡∏∂‡∏á funding rate ‡∏à‡∏≤‡∏Å Binance Futures ‡πÅ‡∏ö‡∏ö‡∏õ‡∏•‡∏≠‡∏î‡∏†‡∏±‡∏¢ (‡∏Ñ‡∏∑‡∏ô‡∏Ñ‡πà‡∏≤ 0.0 ‡∏ñ‡πâ‡∏≤‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß)"""
        try:
            url = f"https://fapi.binance.com/fapi/v1/premiumIndex?symbol={symbol}"
            async with aiohttp.ClientSession() as session:
                async with session.get(url, timeout=aiohttp.ClientTimeout(total=5)) as resp:
                    if resp.status == 200:
                        data = await resp.json()
                        return float(data.get("lastFundingRate", 0.0))
        except Exception:
            pass
        return 0.0

    async def _handle_user_data(self, data: dict):
        try:
            et = data.get("e")
            if et == "ACCOUNT_UPDATE":
                for b in data.get("a", {}).get("B", []):
                    if b.get("a") == "USDT":
                        self.balance_data["free"] = float(b.get("wb", 0.0))
                        self.balance_data["locked"] = float(b.get("cw", 0.0))
                        logging.info(f"üí∞ free={b.get('wb')} locked={b.get('cw')}")
            elif et == "ORDER_TRADE_UPDATE":
                o = data.get("o", {})
                logging.info(f"üìä {o.get('s')} {o.get('S')} {o.get('X')} @ {o.get('p')}")
        except Exception as e:
            logging.error(f"‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô _handle_user_data: {e}")

    # ---------------------- Monitor & Fallback ----------------------
    async def monitor_status_loop(self, interval: int = 10):
        while True:
            self.is_running()
            await asyncio.sleep(interval)

    def is_running(self) -> bool:
        uptime = timedelta(seconds=int(time.time() - self.start_time)) if self.start_time else timedelta(0)
        delay = time.time() - self.last_data_time
        if self.running:
            logging.info(f"‚úÖ ‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏õ‡∏Å‡∏ï‡∏¥ | Delay={delay:.1f}s | Uptime={uptime}")
        else:
            logging.warning("üõë ‡∏´‡∏¢‡∏∏‡∏î‡∏ó‡∏≥‡∏á‡∏≤‡∏ô")
        return self.running

    async def use_fallback_data(self, symbols: list[str]):
        now = time.time()
        for s in symbols:
            self.data[s] = {"timestamp": now, "close": 0.0, "volume": 0.0, "funding_rate": 0.0, "depth": {}}
        logging.warning("‚ö†Ô∏è ‡πÉ‡∏ä‡πâ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≥‡∏•‡∏≠‡∏á‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡∏£‡∏∞‡∏ö‡∏ö‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏ï‡πà‡∏≠")
