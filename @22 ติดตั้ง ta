# ===============================================
# indicator_calculator.py
# ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å WebSocketManager ‡πÅ‡∏•‡∏∞‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì Indicators ‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥
# ===============================================

# ‡∏ï‡∏¥‡∏î‡∏ï‡∏±‡πâ‡∏á‡πÑ‡∏•‡∏ö‡∏£‡∏≤‡∏£‡∏µ‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡πÉ‡∏ä‡πâ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ñ‡∏•‡∏≤‡∏™‡∏ô‡∏µ‡πâ (‡∏£‡∏±‡∏ô‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡πÄ‡∏´‡∏•‡πà‡∏≤‡∏ô‡∏µ‡πâ‡πÉ‡∏ô terminal ‡∏Å‡πà‡∏≠‡∏ô‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô)
# pip install ta pandas aiohttp

import asyncio
import pandas as pd
import ta
import time
import logging
from config import GlobalConfig
from websocket_manager import WebSocketManager


class IndicatorCalculator:
    """‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏≠‡∏¥‡∏ô‡∏î‡∏¥‡πÄ‡∏Ñ‡πÄ‡∏ï‡∏≠‡∏£‡πå‡∏´‡∏•‡∏≤‡∏¢ Timeframe ‡πÇ‡∏î‡∏¢‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å WebSocketManager ‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥"""

    def __init__(self, ws_manager: WebSocketManager):
        self.ws_manager = ws_manager
        self.multi_tf_data = {}
        self.last_update = 0
        # ‚úÖ ‡∏î‡∏∂‡∏á‡∏Ñ‡πà‡∏≤‡∏ä‡πà‡∏ß‡∏á‡πÄ‡∏ß‡∏•‡∏≤ (timeframes) ‡∏à‡∏≤‡∏Å GlobalConfig ‡πÄ‡∏ä‡πà‡∏ô ["1m","5m","1h"]
        self.multi_tf_list = GlobalConfig.get("multi_tf_list", ["1m", "5m", "1h"])
        self.sync_interval = int(GlobalConfig.get("indicator_sync_interval", 60))
        asyncio.create_task(self._auto_sync_loop())

    # ===============================================
    # üîÅ Auto Sync ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏à‡∏≤‡∏Å WebSocketManager
    # ===============================================
    async def _auto_sync_loop(self):
        """‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï multi_tf_data ‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥‡∏à‡∏≤‡∏Å WebSocketManager ‡∏ï‡∏≤‡∏° config"""
        await asyncio.sleep(2)
        while True:
            try:
                self._sync_from_ws_manager()
                await asyncio.sleep(self.sync_interval)
            except Exception as e:
                logging.error(f"Indicator sync error: {e}")
                await asyncio.sleep(10)

    def _sync_from_ws_manager(self):
        """‡∏™‡∏£‡πâ‡∏≤‡∏á multi_tf_data ‡∏à‡∏≤‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏™‡∏î‡πÉ‡∏ô ws_manager.data"""
        now = time.time()
        if now - self.last_update < self.sync_interval:
            return

        self.multi_tf_data = {tf: {} for tf in self.multi_tf_list}
        base_data = self.ws_manager.data.copy()

        for symbol, d in base_data.items():
            # ‚úÖ ‡∏à‡∏≥‡∏•‡∏≠‡∏á‡πÅ‡∏ó‡πà‡∏á‡πÄ‡∏ó‡∏µ‡∏¢‡∏ô (OHLCV) ‡∏à‡∏≤‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡∏°‡∏µ
            price = d.get("close", 0.0)
            vol = d.get("volume", 0.0)
            # ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÅ‡∏ï‡πà‡∏•‡∏∞ timeframe ‚Äî ‡∏™‡∏£‡πâ‡∏≤‡∏á DataFrame ‡∏à‡∏≥‡∏•‡∏≠‡∏á‡πÅ‡∏ó‡πà‡∏á‡πÄ‡∏ó‡∏µ‡∏¢‡∏ô‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î
            for tf in self.multi_tf_list:
                df = pd.DataFrame({
                    "open": [price * 0.999],
                    "high": [price * 1.001],
                    "low": [price * 0.998],
                    "close": [price],
                    "volume": [vol],
                })
                self.multi_tf_data[tf][symbol] = df

        self.last_update = now
        logging.info(f"‚úÖ ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï multi_tf_data ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à ({len(base_data)} symbols)")

    # ===============================================
    # üìä ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì Indicators
    # ===============================================
    def calculate_indicators(self, symbol: str):
        """‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì indicators ‡∏à‡∏≤‡∏Å multi_tf_data ‡∏ó‡∏∏‡∏Å timeframe"""
        indicators = {}
        if not self.multi_tf_data:
            logging.warning("‚ö†Ô∏è multi_tf_data ‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• (‡∏£‡∏≠ WebSocketManager ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï)")
            return indicators

        for tf in self.multi_tf_list:
            df = self.multi_tf_data.get(tf, {}).get(symbol, pd.DataFrame())
            if df.empty or "close" not in df:
                logging.debug(f"‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• {symbol} ‡πÉ‡∏ô timeframe {tf}")
                continue

            close = df["close"].values
            high = df["high"].values if "high" in df else close
            low = df["low"].values if "low" in df else close
            volume = df["volume"].values if "volume" in df else [0]

            indicators[tf] = {
                "ATR": ta.volatility.AverageTrueRange(pd.Series(high), pd.Series(low), pd.Series(close))
                .average_true_range()
                .iloc[-1]
                if len(close) >= 14 else 0,
                "RSI": ta.momentum.RSIIndicator(pd.Series(close)).rsi().iloc[-1] if len(close) >= 14 else 50,
                "MACD": ta.trend.MACD(pd.Series(close)).macd().iloc[-1] if len(close) >= 26 else 0,
                "EMA": ta.trend.EMAIndicator(pd.Series(close), window=20).ema_indicator().iloc[-1]
                if len(close) >= 20 else close[-1],
                "BB_upper": ta.volatility.BollingerBands(pd.Series(close)).bollinger_hband().iloc[-1]
                if len(close) >= 20 else close[-1],
                "BB_lower": ta.volatility.BollingerBands(pd.Series(close)).bollinger_lband().iloc[-1]
                if len(close) >= 20 else close[-1],
                "SMA": ta.trend.SMAIndicator(pd.Series(close), window=20).sma_indicator().iloc[-1]
                if len(close) >= 20 else close[-1],
                "Stoch_RSI": ta.momentum.StochasticRSIIndicator(pd.Series(close)).stochrsi().iloc[-1]
                if len(close) >= 14 else 0.5,
                "OBV": ta.volume.OnBalanceVolumeIndicator(pd.Series(close), pd.Series(volume))
                .on_balance_volume()
                .iloc[-1]
                if len(close) > 1 else volume[-1],
                "Volume": float(volume[-1]),
            }

        return indicators

    # ===============================================
    # üß© ‡∏î‡∏∂‡∏á multi_tf_data (‡∏†‡∏≤‡∏¢‡∏ô‡∏≠‡∏Å‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡∏î‡∏π)
    # ===============================================
    def get_multi_tf_data(self):
        return self.multi_tf_data
