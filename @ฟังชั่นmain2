# ===============================================
# main.py — รวมทุกคลาสและรันระบบเทรดหลัก (เชื่อม WebSocket + APIManager)
# ===============================================

from config import GlobalConfig
import asyncio, logging, traceback
import numpy as np
import pandas as pd
import torch
import time


# ==============================
# 🟢 ฟังก์ชันตรวจสอบสถานะระบบแบบเรียลไทม์
# ==============================
async def status_monitor_loop(ws_manager, api_manager, interval=10):
    while True:
        try:
            ws_ok = "✅" if ws_manager.is_running() else "❌"
            api_ok = "✅" if api_manager and getattr(api_manager, "exchange", None) else "❌"
            delay = round(time.time() - ws_manager.last_data_time, 1)
            symbol_count = len(ws_manager.data)
            balance = getattr(ws_manager, "balance_data", {}).get("free", 0.0)
            logging.info(
                f"⏳ STATUS | WebSocket={ws_ok} | API={api_ok} | Symbols={symbol_count} | Delay={delay}s | Balance={balance:.2f} USDT"
            )
        except Exception as e:
            logging.warning(f"⚠️ สถานะระบบไม่สมบูรณ์: {e}")
        await asyncio.sleep(interval)


# ==============================
# 🧠 ฟังก์ชัน Auto Trailing Stop/Take Profit (จำลอง)
# ==============================
async def auto_update_trailing(strategy, current_price):
    try:
        trailing_callback = GlobalConfig.get('trailing_callback_rate', 0.005)
        if not strategy.get("trailing_stop") or not strategy.get("trailing_take_profit"):
            return strategy

        action = strategy.get("action")
        entry = strategy.get("entry_price", current_price)
        stop_loss = strategy.get("stop_loss")
        take_profit = strategy.get("take_profit")

        if action in ["LONG", "BUY"]:
            if current_price > entry * (1 + trailing_callback):
                new_sl = max(stop_loss, current_price * (1 - trailing_callback))
                new_tp = max(take_profit, current_price * (1 + trailing_callback))
                strategy["stop_loss"], strategy["take_profit"] = new_sl, new_tp
                mode = "🧪 เทรดจำลอง" if GlobalConfig.get("dry_run") else "💰 เทรดจริง"
                logging.info(f"{mode} | 🟢🟢 Trailing LONG | {strategy['symbol']} | SL={new_sl:.4f} | TP={new_tp:.4f}")

        elif action in ["SHORT", "SELL"]:
            if current_price < entry * (1 - trailing_callback):
                new_sl = min(stop_loss, current_price * (1 + trailing_callback))
                new_tp = min(take_profit, current_price * (1 - trailing_callback))
                strategy["stop_loss"], strategy["take_profit"] = new_sl, new_tp
                mode = "🧪 เทรดจำลอง" if GlobalConfig.get("dry_run") else "💰 เทรดจริง"
                logging.info(f"{mode} | 🔴🔴 Trailing SHORT | {strategy['symbol']} | SL={new_sl:.4f} | TP={new_tp:.4f}")

    except Exception as e:
        logging.warning(f"⚠️ Auto Trailing Error: {e}")

    return strategy


# ==============================
# 📡 ฟังก์ชัน Real Trailing Sync สำหรับเทรดจริง
# ==============================
async def sync_real_trailing_orders(ws_manager, api_manager, trader, interval=30):
    trailing_callback = GlobalConfig.get('trailing_callback_rate', 0.005)
    while True:
        try:
            if not trader.positions:
                await asyncio.sleep(interval)
                continue

            for symbol, pos in trader.positions.items():
                side = pos.get("side", "FLAT")
                entry_price = pos.get("entry_price", 0)
                if entry_price <= 0:
                    continue

                current_price = ws_manager.data.get(symbol, {}).get("close")
                if not current_price:
                    continue

                # ✅ ตรวจสอบทิศทางและอัปเดต SL/TP ผ่าน API แบบเรียลไทม์
                if side == "LONG" and current_price > entry_price * (1 + trailing_callback):
                    new_sl = current_price * (1 - trailing_callback)
                    new_tp = current_price * (1 + trailing_callback)
                    await api_manager.update_stop_take_profit(symbol, new_sl, new_tp)
                    logging.info(f"💰 เทรดจริง | 🟢🟢 Trailing LONG | {symbol} | SL={new_sl:.4f} | TP={new_tp:.4f}")

                elif side == "SHORT" and current_price < entry_price * (1 - trailing_callback):
                    new_sl = current_price * (1 + trailing_callback)
                    new_tp = current_price * (1 - trailing_callback)
                    await api_manager.update_stop_take_profit(symbol, new_sl, new_tp)
                    logging.info(f"💰 เทรดจริง | 🔴🔴 Trailing SHORT | {symbol} | SL={new_sl:.4f} | TP={new_tp:.4f}")

        except Exception as e:
            logging.warning(f"⚠️ Real Trailing Sync Error: {e}")

        await asyncio.sleep(interval)


# ==============================
# ฟังก์ชันหลักของระบบเทรด
# ==============================
async def main():
    logging.info("เริ่มต้นระบบการเทรดด้วย CONFIG จาก GlobalConfig")

    api_manager = APIManager()
    ws_manager = WebSocketManager(exchange=api_manager.exchange, time_offset=api_manager.time_offset)
    trader = UnifiedQuantumTrader(GlobalConfig.get('input_dim'))
    risk_guardian = RiskGuardian()
    env = MultiMarketEnv(ws_manager=ws_manager, exchange=api_manager.exchange)
    env.trader = trader

    trader.replay_buffer = ReplayBuffer()
    risk_guardian.env = env
    strategy_gen = StrategyGenerator(trader, env, risk_guardian)
    resource_manager = IntelligentResourceManager()
    kpi_optimizer = KPIOptimizer()
    risk_allocator = DynamicRiskAllocator()
    kpi_tracker = KPITracker()
    bug_fixer = AutomaticBugFixer()

    await ws_manager.fetch_all_usdt_pairs()
    await ws_manager.start()

    trader.current_symbols = ws_manager.all_usdt_pairs[: GlobalConfig.get('madrl_agent_count')]
    env.symbols = trader.current_symbols
    env.simulator.update_symbols(env.symbols)
    trader.madrl.update_symbols(env.symbols)

    asyncio.create_task(resource_manager.monitor_resources())
    asyncio.create_task(status_monitor_loop(ws_manager, api_manager))
    asyncio.create_task(sync_real_trailing_orders(ws_manager, api_manager, trader))  # ✅ Trailing จริง

    for symbol in env.symbols:
        await env.load_historical_data(symbol)

    control_task = asyncio.create_task(control_loop())

    try:
        GlobalConfig.set('system_running', True)
    except Exception:
        GlobalConfig.CONFIG['system_running'] = True

    step_count = 0
    trader.positions = {}

    while GlobalConfig.get('system_running'):
        try:
            mode = "🧪 เทรดจำลอง" if GlobalConfig.get('dry_run') else "💰 เทรดจริง"

            # === ตัวอย่าง Log ของคำสั่งเปิด/ปิด ===
            for symbol in env.symbols:
                current_price = ws_manager.data.get(symbol, {}).get("close", 0)
                if not current_price:
                    continue
                # จำลองการเปิด/ปิดสถานะตัวอย่าง
                action = np.random.choice(["LONG", "SHORT", "CLOSE_LONG", "CLOSE_SHORT", "HOLD"])
                lev = np.random.randint(1, 100)
                tp = current_price * 1.01
                sl = current_price * 0.99

                if action == "LONG":
                    logging.info(f"{mode} | 🟢 LONG OPEN | {symbol} @ {current_price:.2f} | Lev={lev}x | TP={tp:.2f} | SL={sl:.2f}")
                elif action == "SHORT":
                    logging.info(f"{mode} | 🔴 SHORT OPEN | {symbol} @ {current_price:.2f} | Lev={lev}x | TP={tp:.2f} | SL={sl:.2f}")
                elif action == "CLOSE_LONG":
                    logging.info(f"{mode} | 🟣 CLOSE LONG | {symbol} @ {current_price:.2f}")
                elif action == "CLOSE_SHORT":
                    logging.info(f"{mode} | 🟣 CLOSE SHORT | {symbol} @ {current_price:.2f}")
                else:
                    logging.info(f"{mode} | ⚪ HOLD | {symbol} | Price={current_price:.2f}")

            await asyncio.sleep(60)

        except Exception as e:
            if await bug_fixer.analyze_and_fix(e, trader, env):
                logging.info("แก้ไขบั๊กสำเร็จ ทำงานต่อ")
                continue
            logging.critical(f"ข้อผิดพลาดร้ายแรง: {e}")
            traceback.print_exc()
            await risk_guardian.emergency_stop()
            break

    control_task.cancel()


if __name__ == "__main__":
    asyncio.run(main())
