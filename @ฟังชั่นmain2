# ===============================================
# main.py â€” à¸£à¸§à¸¡à¸—à¸¸à¸à¸„à¸¥à¸²à¸ªà¹à¸¥à¸°à¸£à¸±à¸™à¸£à¸°à¸šà¸šà¹€à¸—à¸£à¸”à¸«à¸¥à¸±à¸ (à¹€à¸Šà¸·à¹ˆà¸­à¸¡ WebSocket + APIManager)
# ===============================================

from config import GlobalConfig
import asyncio, logging, traceback
import numpy as np
import pandas as pd
import torch
import time


# ==============================
# ðŸŸ¢ à¸Ÿà¸±à¸‡à¸à¹Œà¸Šà¸±à¸™à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¸ªà¸–à¸²à¸™à¸°à¸£à¸°à¸šà¸šà¹à¸šà¸šà¹€à¸£à¸µà¸¢à¸¥à¹„à¸—à¸¡à¹Œ
# ==============================
async def status_monitor_loop(ws_manager, api_manager, interval=10):
    while True:
        try:
            ws_ok = "âœ…" if ws_manager.is_running() else "âŒ"
            api_ok = "âœ…" if api_manager and getattr(api_manager, "exchange", None) else "âŒ"
            delay = round(time.time() - ws_manager.last_data_time, 1)
            symbol_count = len(ws_manager.data)
            balance = getattr(ws_manager, "balance_data", {}).get("free", 0.0)
            logging.info(
                f"â³ STATUS | WebSocket={ws_ok} | API={api_ok} | Symbols={symbol_count} | Delay={delay}s | Balance={balance:.2f} USDT"
            )
        except Exception as e:
            logging.warning(f"âš ï¸ à¸ªà¸–à¸²à¸™à¸°à¸£à¸°à¸šà¸šà¹„à¸¡à¹ˆà¸ªà¸¡à¸šà¸¹à¸£à¸“à¹Œ: {e}")
        await asyncio.sleep(interval)


# ==============================
# ðŸ§  à¸Ÿà¸±à¸‡à¸à¹Œà¸Šà¸±à¸™ Auto Trailing Stop/Take Profit (à¸ˆà¸³à¸¥à¸­à¸‡)
# ==============================
async def auto_update_trailing(strategy, current_price):
    try:
        trailing_callback = GlobalConfig.get('trailing_callback_rate', 0.005)
        if not strategy.get("trailing_stop") or not strategy.get("trailing_take_profit"):
            return strategy

        action = strategy.get("action")
        entry = strategy.get("entry_price", current_price)
        stop_loss = strategy.get("stop_loss")
        take_profit = strategy.get("take_profit")

        if action in ["LONG", "BUY"]:
            if current_price > entry * (1 + trailing_callback):
                new_sl = max(stop_loss, current_price * (1 - trailing_callback))
                new_tp = max(take_profit, current_price * (1 + trailing_callback))
                strategy["stop_loss"], strategy["take_profit"] = new_sl, new_tp
                mode = "ðŸ§ª à¹€à¸—à¸£à¸”à¸ˆà¸³à¸¥à¸­à¸‡" if GlobalConfig.get("dry_run") else "ðŸ’° à¹€à¸—à¸£à¸”à¸ˆà¸£à¸´à¸‡"
                logging.info(f"{mode} | ðŸŸ¢ðŸŸ¢ Trailing LONG | {strategy['symbol']} | SL={new_sl:.4f} | TP={new_tp:.4f}")

        elif action in ["SHORT", "SELL"]:
            if current_price < entry * (1 - trailing_callback):
                new_sl = min(stop_loss, current_price * (1 + trailing_callback))
                new_tp = min(take_profit, current_price * (1 - trailing_callback))
                strategy["stop_loss"], strategy["take_profit"] = new_sl, new_tp
                mode = "ðŸ§ª à¹€à¸—à¸£à¸”à¸ˆà¸³à¸¥à¸­à¸‡" if GlobalConfig.get("dry_run") else "ðŸ’° à¹€à¸—à¸£à¸”à¸ˆà¸£à¸´à¸‡"
                logging.info(f"{mode} | ðŸ”´ðŸ”´ Trailing SHORT | {strategy['symbol']} | SL={new_sl:.4f} | TP={new_tp:.4f}")

    except Exception as e:
        logging.warning(f"âš ï¸ Auto Trailing Error: {e}")

    return strategy


# ==============================
# ðŸ“¡ à¸Ÿà¸±à¸‡à¸à¹Œà¸Šà¸±à¸™ Real Trailing Sync à¸ªà¸³à¸«à¸£à¸±à¸šà¹€à¸—à¸£à¸”à¸ˆà¸£à¸´à¸‡
# ==============================
async def sync_real_trailing_orders(ws_manager, api_manager, trader, interval=30):
    trailing_callback = GlobalConfig.get('trailing_callback_rate', 0.005)
    while True:
        try:
            if not trader.positions:
                await asyncio.sleep(interval)
                continue

            for symbol, pos in trader.positions.items():
                side = pos.get("side", "FLAT")
                entry_price = pos.get("entry_price", 0)
                if entry_price <= 0:
                    continue

                current_price = ws_manager.data.get(symbol, {}).get("close")
                if not current_price:
                    continue

                # âœ… à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¸—à¸´à¸¨à¸—à¸²à¸‡à¹à¸¥à¸°à¸­à¸±à¸›à¹€à¸”à¸• SL/TP à¸œà¹ˆà¸²à¸™ API à¹à¸šà¸šà¹€à¸£à¸µà¸¢à¸¥à¹„à¸—à¸¡à¹Œ
                if side == "LONG" and current_price > entry_price * (1 + trailing_callback):
                    new_sl = current_price * (1 - trailing_callback)
                    new_tp = current_price * (1 + trailing_callback)
                    await api_manager.update_stop_take_profit(symbol, new_sl, new_tp)
                    logging.info(f"ðŸ’° à¹€à¸—à¸£à¸”à¸ˆà¸£à¸´à¸‡ | ðŸŸ¢ðŸŸ¢ Trailing LONG | {symbol} | SL={new_sl:.4f} | TP={new_tp:.4f}")

                elif side == "SHORT" and current_price < entry_price * (1 - trailing_callback):
                    new_sl = current_price * (1 + trailing_callback)
                    new_tp = current_price * (1 - trailing_callback)
                    await api_manager.update_stop_take_profit(symbol, new_sl, new_tp)
                    logging.info(f"ðŸ’° à¹€à¸—à¸£à¸”à¸ˆà¸£à¸´à¸‡ | ðŸ”´ðŸ”´ Trailing SHORT | {symbol} | SL={new_sl:.4f} | TP={new_tp:.4f}")

        except Exception as e:
            logging.warning(f"âš ï¸ Real Trailing Sync Error: {e}")

        await asyncio.sleep(interval)


# ==============================
# à¸Ÿà¸±à¸‡à¸à¹Œà¸Šà¸±à¸™à¸«à¸¥à¸±à¸à¸‚à¸­à¸‡à¸£à¸°à¸šà¸šà¹€à¸—à¸£à¸”
# ==============================
async def main():
    logging.info("à¹€à¸£à¸´à¹ˆà¸¡à¸•à¹‰à¸™à¸£à¸°à¸šà¸šà¸à¸²à¸£à¹€à¸—à¸£à¸”à¸”à¹‰à¸§à¸¢ CONFIG à¸ˆà¸²à¸ GlobalConfig")

    api_manager = APIManager()
    ws_manager = WebSocketManager(exchange=api_manager.exchange, time_offset=api_manager.time_offset)
    trader = UnifiedQuantumTrader(GlobalConfig.get('input_dim'))
    risk_guardian = RiskGuardian()
    env = MultiMarketEnv(ws_manager=ws_manager, exchange=api_manager.exchange)
    env.trader = trader

    trader.replay_buffer = ReplayBuffer()
    risk_guardian.env = env
    strategy_gen = StrategyGenerator(trader, env, risk_guardian)
    resource_manager = IntelligentResourceManager()
    kpi_optimizer = KPIOptimizer()
    risk_allocator = DynamicRiskAllocator()
    kpi_tracker = KPITracker()
    bug_fixer = AutomaticBugFixer()

    await ws_manager.fetch_all_usdt_pairs()
    await ws_manager.start()

    trader.current_symbols = ws_manager.all_usdt_pairs[: GlobalConfig.get('madrl_agent_count')]
    env.symbols = trader.current_symbols
    env.simulator.update_symbols(env.symbols)
    trader.madrl.update_symbols(env.symbols)

    asyncio.create_task(resource_manager.monitor_resources())
    asyncio.create_task(status_monitor_loop(ws_manager, api_manager))
    asyncio.create_task(sync_real_trailing_orders(ws_manager, api_manager, trader))  # âœ… Trailing à¸ˆà¸£à¸´à¸‡

    for symbol in env.symbols:
        await env.load_historical_data(symbol)

    control_task = asyncio.create_task(control_loop())

    try:
        GlobalConfig.set('system_running', True)
    except Exception:
        GlobalConfig.CONFIG['system_running'] = True

    step_count = 0
    trader.positions = {}

    while GlobalConfig.get('system_running'):
        try:
            mode = "ðŸ§ª à¹€à¸—à¸£à¸”à¸ˆà¸³à¸¥à¸­à¸‡" if GlobalConfig.get('dry_run') else "ðŸ’° à¹€à¸—à¸£à¸”à¸ˆà¸£à¸´à¸‡"

            # === à¸•à¸±à¸§à¸­à¸¢à¹ˆà¸²à¸‡ Log à¸‚à¸­à¸‡à¸„à¸³à¸ªà¸±à¹ˆà¸‡à¹€à¸›à¸´à¸”/à¸›à¸´à¸” ===
            for symbol in env.symbols:
                current_price = ws_manager.data.get(symbol, {}).get("close", 0)
                if not current_price:
                    continue
                # à¸ˆà¸³à¸¥à¸­à¸‡à¸à¸²à¸£à¹€à¸›à¸´à¸”/à¸›à¸´à¸”à¸ªà¸–à¸²à¸™à¸°à¸•à¸±à¸§à¸­à¸¢à¹ˆà¸²à¸‡
                action = np.random.choice(["LONG", "SHORT", "CLOSE_LONG", "CLOSE_SHORT", "HOLD"])
                lev = np.random.randint(1, 100)
                tp = current_price * 1.01
                sl = current_price * 0.99

                if action == "LONG":
                    logging.info(f"{mode} | ðŸŸ¢ LONG OPEN | {symbol} @ {current_price:.2f} | Lev={lev}x | TP={tp:.2f} | SL={sl:.2f}")
                elif action == "SHORT":
                    logging.info(f"{mode} | ðŸ”´ SHORT OPEN | {symbol} @ {current_price:.2f} | Lev={lev}x | TP={tp:.2f} | SL={sl:.2f}")
                elif action == "CLOSE_LONG":
                    logging.info(f"{mode} | ðŸŸ£ CLOSE LONG | {symbol} @ {current_price:.2f}")
                elif action == "CLOSE_SHORT":
                    logging.info(f"{mode} | ðŸŸ£ CLOSE SHORT | {symbol} @ {current_price:.2f}")
                else:
                    logging.info(f"{mode} | âšª HOLD | {symbol} | Price={current_price:.2f}")

            await asyncio.sleep(60)

        except Exception as e:
            if await bug_fixer.analyze_and_fix(e, trader, env):
                logging.info("à¹à¸à¹‰à¹„à¸‚à¸šà¸±à¹Šà¸à¸ªà¸³à¹€à¸£à¹‡à¸ˆ à¸—à¸³à¸‡à¸²à¸™à¸•à¹ˆà¸­")
                continue
            logging.critical(f"à¸‚à¹‰à¸­à¸œà¸´à¸”à¸žà¸¥à¸²à¸”à¸£à¹‰à¸²à¸¢à¹à¸£à¸‡: {e}")
            traceback.print_exc()
            await risk_guardian.emergency_stop()
            break

    control_task.cancel()


if __name__ == "__main__":
    asyncio.run(main())
