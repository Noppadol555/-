# ===============================================
# APIManager Class (Clean Logging)
# ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ API ‡∏Å‡∏±‡∏ö Binance Futures
# ===============================================

# pip install ccxt tenacity pandas

import logging
import logging.handlers
import time
import asyncio
from collections import deque
from typing import Optional, Dict, Any, List
import ccxt.async_support as ccxt_async
from tenacity import retry, wait_exponential, stop_after_attempt
import pandas as pd
from config import GlobalConfig


# ---------------- Logging ----------------
log_level_str = GlobalConfig.get('log_level', 'INFO').upper()
log_level = getattr(logging, log_level_str, logging.INFO)
logging.basicConfig(
    level=log_level,
    format="%(asctime)s - %(levelname)s - %(message)s",
    handlers=[
        logging.handlers.RotatingFileHandler('apimanager.log', maxBytes=10 * 1024 * 1024, backupCount=5),
        logging.StreamHandler()
    ]
)


class APIManager:
    """‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡πÅ‡∏•‡∏∞‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏ú‡πà‡∏≤‡∏ô Binance Futures API"""

    def __init__(self):
        self.weight_used = 0
        self.weight_limit = GlobalConfig.get('rate_limit_per_minute')
        self.last_reset = time.time()
        self.is_rate_limited = False
        self.ban_until = 0
        self.api_call_timestamps = deque(maxlen=self.weight_limit)
        self.time_offset = 0
        self.last_time_sync = time.time()
        self.markets: Optional[Dict] = None

        self.exchange = ccxt_async.binance({
            'apiKey': GlobalConfig.get('binance_api_key'),
            'secret': GlobalConfig.get('binance_api_secret'),
            'enableRateLimit': True,
            'timeout': GlobalConfig.get('api_timeout') * 1000,
            'options': {'defaultType': 'future', 'adjustForTimeDifference': True},
            'rateLimit': int(60000 / self.weight_limit)
        })

    # ============================================================
    # ‡∏û‡∏∑‡πâ‡∏ô‡∏ê‡∏≤‡∏ô
    # ============================================================

    async def close(self):
        if self.exchange:
            await self.exchange.close()

    async def sync_time_with_exchange(self) -> bool:
        """‡∏ã‡∏¥‡∏á‡πÇ‡∏Ñ‡∏£‡πÑ‡∏ô‡∏ã‡πå‡πÄ‡∏ß‡∏•‡∏≤"""
        if GlobalConfig.get('dry_run'):
            self.time_offset = 0
            self.last_time_sync = time.time()
            logging.info("üß™ ‡∏à‡∏≥‡∏•‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏ã‡∏¥‡∏á‡∏Ñ‡πå‡πÄ‡∏ß‡∏•‡∏≤: timeOffset = 0")
            return True
        await self.rate_limit_control()
        try:
            server_time = await self.exchange.fetch_time()
            local_time = int(time.time() * 1000)
            self.time_offset = server_time - local_time
            self.last_time_sync = time.time()
            logging.info(f"üïí Sync OK | Offset={self.time_offset} ms")
            return True
        except Exception as e:
            logging.warning(f"‚ö†Ô∏è Sync Time Failed: {e}")
            self.time_offset = 0
            return False

    async def get_adjusted_timestamp(self) -> int:
        return int(time.time() * 1000) + self.time_offset

    async def update_weight(self, response: Any):
        if time.time() - self.last_reset >= 60:
            self.weight_used = 0
            self.last_reset = time.time()

    async def rate_limit_control(self):
        now = time.time()
        if now - self.last_time_sync >= GlobalConfig.get('sync_time_interval'):
            await self.sync_time_with_exchange()
        if self.is_rate_limited and now < self.ban_until:
            await asyncio.sleep(self.ban_until - now)
            self.is_rate_limited = False
        if self.weight_used >= self.weight_limit * 0.9:
            wait_time = 60 - (now - self.last_reset)
            if wait_time > 0:
                logging.info(f"‚è≥ API Cooldown {wait_time:.2f}s")
                await asyncio.sleep(wait_time)
            self.weight_used = 0
            self.last_reset = now
        self.api_call_timestamps.append(now)

    # ============================================================
    # ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏¢‡πâ‡∏≠‡∏ô‡∏´‡∏•‡∏±‡∏á
    # ============================================================

    @retry(wait=wait_exponential(multiplier=1, min=3, max=60), stop=stop_after_attempt(5))
    async def fetch_all_usdt_historical(
        self, timeframe: str = "1h", limit: int = 1000,
        since: Optional[int] = None, delay_per_request: float = 0.2
    ) -> Dict[str, pd.DataFrame]:
        """‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏¢‡πâ‡∏≠‡∏ô‡∏´‡∏•‡∏±‡∏á‡∏ó‡∏∏‡∏Å‡∏Ñ‡∏π‡πà USDT"""
        await self.rate_limit_control()
        results = {}
        try:
            if not self.markets:
                self.markets = await self.exchange.load_markets(params={'type': 'future'})
            usdt_pairs = [s for s in self.markets if s.endswith('/USDT')]
            total = len(usdt_pairs)
            logging.info(f"üìä ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏¢‡πâ‡∏≠‡∏ô‡∏´‡∏•‡∏±‡∏á {total} ‡πÄ‡∏´‡∏£‡∏µ‡∏¢‡∏ç (tf={timeframe})")

            for idx, symbol in enumerate(usdt_pairs, 1):
                try:
                    data = await self.exchange.fetch_ohlcv(symbol, timeframe=timeframe, limit=limit, since=since)
                    df = pd.DataFrame(data, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
                    df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms', utc=True)
                    results[symbol] = df
                    logging.debug(f"[{idx}/{total}] {symbol}: {len(df)} rows")
                except Exception as e:
                    logging.warning(f"[{idx}/{total}] ‚ö†Ô∏è {symbol}: {e}")
                await asyncio.sleep(delay_per_request)

            logging.info(f"‚úÖ ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏¢‡πâ‡∏≠‡∏ô‡∏´‡∏•‡∏±‡∏á‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à {len(results)} ‡πÄ‡∏´‡∏£‡∏µ‡∏¢‡∏ç")
            return results
        except Exception as e:
            logging.error(f"‚ùå Fetch Historical Error: {e}")
            return {}

    # ============================================================
    # ‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á API (‡πÑ‡∏°‡πà‡∏°‡∏µ log ‡∏ã‡πâ‡∏≥‡∏Å‡∏±‡∏ö main)
    # ============================================================

    async def create_limit_order_with_trailing(self, symbol: str, side: str, amount: float, price: float, callback_rate: float = 0.005):
        """‡∏™‡∏£‡πâ‡∏≤‡∏á Limit + Trailing"""
        await self.rate_limit_control()
        if GlobalConfig.get('dry_run'):
            return True
        try:
            api_symbol = symbol.replace("/", "")
            params = {
                "symbol": api_symbol,
                "side": side.upper(),
                "type": "TRAILING_STOP_MARKET",
                "quantity": amount,
                "activationPrice": price,
                "callbackRate": round(callback_rate * 100, 2),
                "recvWindow": 5000,
                "timestamp": await self.get_adjusted_timestamp()
            }
            order = await self.exchange.fapiPrivate_post_order(params)
            await self.update_weight(order)
            return order
        except Exception as e:
            logging.error(f"API Error: create_limit_order_with_trailing({symbol}) ‚Üí {e}")
            return None

    async def create_stop_order(self, symbol: str, side: str, amount: float, stop_price: float, params: Optional[dict] = None):
        """‡∏™‡∏£‡πâ‡∏≤‡∏á Stop-Market"""
        await self.rate_limit_control()
        if GlobalConfig.get('dry_run'):
            return True
        try:
            api_symbol = symbol.replace("/", "")
            body = {
                "symbol": api_symbol,
                "side": side.upper(),
                "type": "STOP_MARKET",
                "stopPrice": round(stop_price, 2),
                "closePosition": True,
                "reduceOnly": True,
                "recvWindow": 5000,
                "timestamp": await self.get_adjusted_timestamp()
            }
            if params:
                body.update(params)
            order = await self.exchange.fapiPrivate_post_order(body)
            await self.update_weight(order)
            return order
        except Exception as e:
            logging.error(f"API Error: create_stop_order({symbol}) ‚Üí {e}")
            return None

    async def update_stop_take_profit(self, symbol: str, stop_price: float, take_price: float):
        """‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï Stop-Loss / Take-Profit ‡πÅ‡∏ö‡∏ö‡πÄ‡∏£‡∏µ‡∏¢‡∏•‡πÑ‡∏ó‡∏°‡πå"""
        await self.rate_limit_control()
        if GlobalConfig.get('dry_run'):
            return True
        try:
            api_symbol = symbol.replace("/", "")
            await self.exchange.fapiPrivate_post_order({
                "symbol": api_symbol,
                "side": "SELL",
                "type": "STOP_MARKET",
                "stopPrice": round(stop_price, 2),
                "closePosition": True,
                "reduceOnly": True,
                "recvWindow": 5000,
                "timestamp": await self.get_adjusted_timestamp()
            })
            await self.exchange.fapiPrivate_post_order({
                "symbol": api_symbol,
                "side": "SELL",
                "type": "TAKE_PROFIT_MARKET",
                "stopPrice": round(take_price, 2),
                "closePosition": True,
                "reduceOnly": True,
                "recvWindow": 5000,
                "timestamp": await self.get_adjusted_timestamp()
            })
            return True
        except Exception as e:
            logging.error(f"API Error: update_stop_take_profit({symbol}) ‚Üí {e}")
            return False
