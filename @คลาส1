# ===============================================
# APIManager Class
# ‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ API ‡∏Å‡∏±‡∏ö Binance Futures
# ‡πÉ‡∏ä‡πâ GlobalConfig ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ñ‡πà‡∏≤‡∏û‡∏≤‡∏£‡∏≤‡∏°‡∏¥‡πÄ‡∏ï‡∏≠‡∏£‡πå‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
# ===============================================

# ‡∏ï‡∏¥‡∏î‡∏ï‡∏±‡πâ‡∏á‡πÑ‡∏•‡∏ö‡∏£‡∏≤‡∏£‡∏µ‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡πÉ‡∏ä‡πâ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ñ‡∏•‡∏≤‡∏™‡∏ô‡∏µ‡πâ (‡∏£‡∏±‡∏ô‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡πÉ‡∏ô terminal ‡∏Å‡πà‡∏≠‡∏ô‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô)
# pip install ccxt tenacity pandas

import os
import logging
import logging.handlers
import time
import asyncio
from collections import deque
from typing import Optional, Dict, Any, List
import ccxt.async_support as ccxt_async
from tenacity import retry, wait_exponential, stop_after_attempt
import pandas as pd
from config import GlobalConfig  # ‚úÖ ‡πÉ‡∏´‡πâ‡∏ã‡∏¥‡∏á‡∏Ñ‡πå‡∏Å‡∏±‡∏ö GlobalConfig ‡∏Ç‡∏≠‡∏á‡πÄ‡∏à‡πâ‡∏≤‡∏ô‡∏≤‡∏¢‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡πÅ‡∏•‡πâ‡∏ß

# ---------------- Logging ----------------
log_level_str = GlobalConfig.get('log_level', 'INFO').upper()
log_level = getattr(logging, log_level_str, logging.INFO)
logging.basicConfig(
    level=log_level,
    format="%(asctime)s - %(levelname)s - %(message)s",
    handlers=[
        logging.handlers.RotatingFileHandler('apimanager.log', maxBytes=10 * 1024 * 1024, backupCount=5),
        logging.StreamHandler()
    ]
)


class APIManager:
    """‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠‡πÅ‡∏•‡∏∞‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏ú‡πà‡∏≤‡∏ô Binance Futures API"""

    def __init__(self):
        self.weight_used: int = 0
        self.weight_limit: int = GlobalConfig.get('rate_limit_per_minute')
        self.last_reset: float = time.time()
        self.is_rate_limited: bool = False
        self.ban_until: float = 0
        self.request_count: int = 0
        self.rate_limit_status: Dict[str, int] = {}
        self.kpi_priority_weight: float = 0
        self.api_call_timestamps: deque = deque(maxlen=GlobalConfig.get('rate_limit_per_minute'))
        self.time_offset: int = 0
        self.last_time_sync: float = time.time()
        self.max_leverage_per_symbol: Dict[str, int] = GlobalConfig.get('max_leverage_per_symbol', {})
        self.trailing_orders: Dict[str, Dict[str, Any]] = {}
        self.markets: Optional[Dict] = None

        # ---------- ‡∏™‡∏£‡πâ‡∏≤‡∏á Binance Futures Exchange ----------
        self.exchange = ccxt_async.binance({
            'apiKey': GlobalConfig.get('binance_api_key'),
            'secret': GlobalConfig.get('binance_api_secret'),
            'enableRateLimit': True,
            'timeout': GlobalConfig.get('api_timeout') * 1000,
            'options': {
                'defaultType': 'future',
                'adjustForTimeDifference': True
            },
            'rateLimit': int(60000 / GlobalConfig.get('rate_limit_per_minute'))
        })

    # ============================================================
    # ‡∏û‡∏∑‡πâ‡∏ô‡∏ê‡∏≤‡∏ô
    # ============================================================

    async def close(self):
        """‡∏õ‡∏¥‡∏î‡∏Å‡∏≤‡∏£‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏ï‡πà‡∏≠ exchange"""
        if self.exchange:
            await self.exchange.close()

    async def sync_time_with_exchange(self) -> bool:
        """‡∏ã‡∏¥‡∏á‡πÇ‡∏Ñ‡∏£‡πÑ‡∏ô‡∏ã‡πå‡πÄ‡∏ß‡∏•‡∏≤‡∏Å‡∏±‡∏ö‡πÄ‡∏ã‡∏¥‡∏£‡πå‡∏ü‡πÄ‡∏ß‡∏≠‡∏£‡πå Binance"""
        if GlobalConfig.get('dry_run'):
            logging.info("‡∏à‡∏≥‡∏•‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏ã‡∏¥‡∏á‡∏Ñ‡πå‡πÄ‡∏ß‡∏•‡∏≤: timeOffset = 0")
            self.time_offset = 0
            self.last_time_sync = time.time()
            return True
        await self.rate_limit_control()
        try:
            server_time = await self.exchange.fetch_time()
            local_time = int(time.time() * 1000)
            self.time_offset = server_time - local_time
            self.last_time_sync = time.time()
            logging.info(f"‡∏ã‡∏¥‡∏á‡∏Ñ‡πå‡πÄ‡∏ß‡∏•‡∏≤‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à: offset = {self.time_offset} ms")
            return True
        except Exception as e:
            logging.error(f"‡∏ã‡∏¥‡∏á‡∏Ñ‡πå‡πÄ‡∏ß‡∏•‡∏≤‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß: {e}")
            self.time_offset = 0
            return False

    async def get_adjusted_timestamp(self) -> int:
        """‡∏Ñ‡∏∑‡∏ô‡∏Ñ‡πà‡∏≤ timestamp ‡∏ó‡∏µ‡πà‡∏õ‡∏£‡∏±‡∏ö‡∏ï‡∏≤‡∏° timeOffset"""
        return int(time.time() * 1000) + self.time_offset

    async def update_weight(self, response: Any):
        """‡∏≠‡∏±‡∏û‡πÄ‡∏î‡∏ó‡∏ô‡πâ‡∏≥‡∏´‡∏ô‡∏±‡∏Å API"""
        if time.time() - self.last_reset >= 60:
            self.weight_used = 0
            self.rate_limit_status = {}
            self.last_reset = time.time()

    async def rate_limit_control(self):
        """‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏°‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ API"""
        now = time.time()
        if now - self.last_time_sync >= GlobalConfig.get('sync_time_interval'):
            await self.sync_time_with_exchange()
        if self.is_rate_limited and now < self.ban_until:
            await asyncio.sleep(self.ban_until - now)
            self.is_rate_limited = False
        if self.weight_used >= self.weight_limit * 0.9:
            wait_time = 60 - (now - self.last_reset)
            if wait_time > 0:
                logging.warning(f"‡∏ô‡πâ‡∏≥‡∏´‡∏ô‡∏±‡∏Å API ‡πÉ‡∏Å‡∏•‡πâ‡πÄ‡∏ï‡πá‡∏° ‡∏£‡∏≠ {wait_time:.2f} ‡∏ß‡∏¥")
                await asyncio.sleep(wait_time)
            self.weight_used = 0
            self.last_reset = now
        self.api_call_timestamps.append(now)

    # ============================================================
    # üî• ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡πÉ‡∏´‡∏°‡πà: ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏¢‡πâ‡∏≠‡∏ô‡∏´‡∏•‡∏±‡∏á‡∏ó‡∏∏‡∏Å‡∏Ñ‡∏π‡πà USDT
    # ============================================================

    @retry(wait=wait_exponential(multiplier=1, min=3, max=60), stop=stop_after_attempt(5))
    async def fetch_all_usdt_historical(
        self,
        timeframe: str = "1h",
        limit: int = 1000,
        since: Optional[int] = None,
        delay_per_request: float = 0.2
    ) -> Dict[str, pd.DataFrame]:
        """
        ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏¢‡πâ‡∏≠‡∏ô‡∏´‡∏•‡∏±‡∏á‡∏Ç‡∏≠‡∏á‡∏ó‡∏∏‡∏Å‡πÄ‡∏´‡∏£‡∏µ‡∏¢‡∏ç‡∏ó‡∏µ‡πà‡∏à‡∏±‡∏ö‡∏Ñ‡∏π‡πà USDT ‡∏à‡∏≤‡∏Å Binance Futures
        ‡∏Ñ‡∏∑‡∏ô‡∏Ñ‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô dict ‡∏Ç‡∏≠‡∏á {symbol: DataFrame}
        """
        await self.rate_limit_control()
        results: Dict[str, pd.DataFrame] = {}

        try:
            # ---------- ‡πÇ‡∏´‡∏•‡∏î‡∏ï‡∏•‡∏≤‡∏î ----------
            if not self.markets:
                self.markets = await self.exchange.load_markets(params={'type': 'future'})

            usdt_pairs: List[str] = [s for s in self.markets if s.endswith('/USDT')]
            total = len(usdt_pairs)
            logging.info(f"üìä ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏¢‡πâ‡∏≠‡∏ô‡∏´‡∏•‡∏±‡∏á {total} ‡πÄ‡∏´‡∏£‡∏µ‡∏¢‡∏ç (timeframe={timeframe})")

            for idx, symbol in enumerate(usdt_pairs, 1):
                try:
                    # ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• OHLCV
                    data = await self.exchange.fetch_ohlcv(symbol, timeframe=timeframe, limit=limit, since=since)
                    df = pd.DataFrame(data, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
                    df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms', utc=True)
                    results[symbol] = df
                    logging.info(f"[{idx}/{total}] ‚úÖ {symbol}: {len(df)} ‡πÅ‡∏ñ‡∏ß")
                except Exception as e:
                    logging.warning(f"[{idx}/{total}] ‚ö†Ô∏è ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• {symbol} ‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß: {e}")

                # ‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏° rate limit
                await asyncio.sleep(delay_per_request)

            logging.info(f"‚úÖ ‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏¢‡πâ‡∏≠‡∏ô‡∏´‡∏•‡∏±‡∏á‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î {len(results)} ‡πÄ‡∏´‡∏£‡∏µ‡∏¢‡∏ç")
            return results

        except Exception as e:
            logging.error(f"‚ùå fetch_all_usdt_historical ‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß: {e}")
            return {}

    # ============================================================
    # ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏≠‡∏∑‡πà‡∏ô (‡∏Ñ‡∏á‡πÄ‡∏î‡∏¥‡∏°‡∏ó‡∏∏‡∏Å‡∏≠‡∏¢‡πà‡∏≤‡∏á)
    # ============================================================

    async def fetch_max_leverage(self) -> Dict[str, int]:
        """‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• leverage ‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÅ‡∏ï‡πà‡∏•‡∏∞‡πÄ‡∏´‡∏£‡∏µ‡∏¢‡∏ç"""
        await self.rate_limit_control()
        if GlobalConfig.get('dry_run'):
            return self.max_leverage_per_symbol
        try:
            info = await self.exchange.fetch_exchange_info(
                params={'recvWindow': 5000, 'timestamp': await self.get_adjusted_timestamp()}
            )
            max_leverage = {}
            for symbol_info in info['symbols']:
                symbol = symbol_info['symbol']
                if symbol.endswith('USDT'):
                    max_leverage[symbol] = 125
            self.max_leverage_per_symbol = max_leverage
            GlobalConfig.set('max_leverage_per_symbol', max_leverage)
            await self.update_weight(info)
            logging.info(f"‡∏î‡∏∂‡∏á max_leverage ‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à {len(max_leverage)} ‡πÄ‡∏´‡∏£‡∏µ‡∏¢‡∏ç")
            return max_leverage
        except Exception as e:
            logging.error(f"‡∏î‡∏∂‡∏á max_leverage ‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß: {e}")
            raise

    async def check_balance(self, asset: str = 'USDT') -> Dict:
        """‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏¢‡∏≠‡∏î‡πÄ‡∏á‡∏¥‡∏ô‡πÉ‡∏ô‡∏ö‡∏±‡∏ç‡∏ä‡∏µ Futures"""
        await self.rate_limit_control()
        if GlobalConfig.get('dry_run'):
            return {'free': 1000.0, 'total': 1000.0}
        try:
            balance = await self.exchange.fetch_balance(
                params={'type': 'future', 'recvWindow': 5000, 'timestamp': await self.get_adjusted_timestamp()}
            )
            await self.update_weight(balance)
            return balance.get(asset, {'free': 0, 'total': 0})
        except Exception as e:
            logging.error(f"‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö balance ‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß: {e}")
            return {'free': 0, 'total': 0}

    async def check_symbol_exists(self, symbol: str) -> bool:
        """‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÄ‡∏´‡∏£‡∏µ‡∏¢‡∏ç‡∏°‡∏µ‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô Binance Futures"""
        await self.rate_limit_control()
        try:
            if self.markets is None:
                self.markets = await self.exchange.load_markets(params={'type': 'future'})
            return symbol in self.markets
        except Exception as e:
            logging.error(f"‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö symbol {symbol} ‡∏•‡πâ‡∏°‡πÄ‡∏´‡∏•‡∏ß: {e}")
            return False

    async def predict_usage(self) -> float:
        """‡∏Ñ‡∏≤‡∏î‡∏Å‡∏≤‡∏£‡∏ì‡πå‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô API ‡πÉ‡∏ô‡∏≠‡∏ô‡∏≤‡∏Ñ‡∏ï (60 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ‡∏Ç‡πâ‡∏≤‡∏á‡∏´‡∏ô‡πâ‡∏≤)"""
        usage_history = [self.weight_used] * 60
        return sum(usage_history) / len(usage_history) if usage_history else 0
