# ===============================================
# RiskGuardian Class (‡∏ï‡πâ‡∏ô‡∏â‡∏ö‡∏±‡∏ö + ‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á‡∏Å‡∏±‡∏ô‡∏û‡∏±‡∏á funding_rate)
# ===============================================

# ‡∏ï‡∏¥‡∏î‡∏ï‡∏±‡πâ‡∏á‡πÑ‡∏•‡∏ö‡∏£‡∏≤‡∏£‡∏µ‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡πÉ‡∏ä‡πâ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ñ‡∏•‡∏≤‡∏™‡∏ô‡∏µ‡πâ (‡∏£‡∏±‡∏ô‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡πÄ‡∏´‡∏•‡πà‡∏≤‡∏ô‡∏µ‡πâ‡πÉ‡∏ô terminal ‡∏Å‡πà‡∏≠‡∏ô‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô)
# pip install numpy collections asyncio

import numpy as np
from collections import deque
import asyncio
import logging
from config import GlobalConfig


class RiskGuardian:
    """
    ‡∏Ñ‡∏•‡∏≤‡∏™‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∞‡πÄ‡∏°‡∏¥‡∏ô‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏™‡∏µ‡πà‡∏¢‡∏á‡∏Ç‡∏≠‡∏á‡∏£‡∏∞‡∏ö‡∏ö‡πÄ‡∏ó‡∏£‡∏î:
      - ‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö drawdown ‡πÄ‡∏Å‡∏¥‡∏ô‡∏Ç‡∏µ‡∏î‡∏à‡∏≥‡∏Å‡∏±‡∏î
      - ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Å‡∏≤‡∏£‡∏Ç‡∏≤‡∏î‡∏ó‡∏∏‡∏ô‡∏ï‡πà‡∏≠ position
      - ‡∏õ‡∏£‡∏±‡∏ö dynamic risk ‡∏ï‡∏≤‡∏°‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ú‡∏±‡∏ô‡∏ú‡∏ß‡∏ô‡∏ï‡∏•‡∏≤‡∏î
      - ‡∏õ‡∏¥‡∏î position ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÄ‡∏Å‡∏¥‡∏î‡∏†‡∏≤‡∏ß‡∏∞‡∏â‡∏∏‡∏Å‡πÄ‡∏â‡∏¥‡∏ô
    """

    def __init__(
        self,
        max_drawdown=GlobalConfig.get('max_drawdown'),
        cut_loss_threshold=GlobalConfig.get('cut_loss_threshold'),
        ws_manager=None
    ):
        self.max_drawdown = max_drawdown
        self.cut_loss_threshold = cut_loss_threshold
        self.drawdown_history = deque(maxlen=1440)
        self.positions = {}
        self.total_trades = 0
        self.failed_trades = 0
        self.env = None  # ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏°‡∏à‡∏≤‡∏Å main
        self.dynamic_risk_factor = 1.0
        self.volatility_history = deque(maxlen=60)
        self.ws_manager = ws_manager

    # ==========================
    # ‡∏õ‡∏£‡∏∞‡πÄ‡∏°‡∏¥‡∏ô Drawdown ‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô
    # ==========================
    def assess_risk(self, balance, initial_balance):
        current_drawdown = (initial_balance - balance) / initial_balance
        self.drawdown_history.append(current_drawdown)
        if current_drawdown > self.max_drawdown * self.dynamic_risk_factor:
            logging.warning(
                f"‚ö†Ô∏è Drawdown ‡πÄ‡∏Å‡∏¥‡∏ô‡∏Ç‡∏µ‡∏î‡∏à‡∏≥‡∏Å‡∏±‡∏î: {current_drawdown:.2%} > "
                f"{self.max_drawdown * self.dynamic_risk_factor:.2%}"
            )
            return False
        return True

    # ==========================
    # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏™‡∏µ‡πà‡∏¢‡∏á‡∏Ç‡∏≠‡∏á position ‡πÄ‡∏î‡∏µ‡∏¢‡∏ß
    # ==========================
    def evaluate_position(self, symbol, current_price, entry_price, size, leverage, side):
        unrealized_pnl = (current_price - entry_price) * size * leverage * (1 if side == 'BUY' else -1)
        position_value = size * entry_price / leverage
        loss_ratio = -unrealized_pnl / position_value
        adjusted_threshold = self.cut_loss_threshold * self.dynamic_risk_factor
        if loss_ratio > adjusted_threshold:
            logging.warning(
                f"‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á {symbol} ‡∏Ç‡∏≤‡∏î‡∏ó‡∏∏‡∏ô‡πÄ‡∏Å‡∏¥‡∏ô {adjusted_threshold:.2%}: {loss_ratio:.2%}"
            )
            return False
        return True

    # ==========================
    # ‡∏õ‡∏£‡∏±‡∏ö dynamic risk factor ‡∏à‡∏≤‡∏Å‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ú‡∏±‡∏ô‡∏ú‡∏ß‡∏ô‡∏ï‡∏•‡∏≤‡∏î
    # ==========================
    async def update_dynamic_risk(self, ws_data):
        volatilities = []
        for symbol in ws_data:
            if 'close' in ws_data[symbol]:
                try:
                    # ‡∏ï‡∏£‡∏ß‡∏à‡πÅ‡∏•‡∏∞‡πÉ‡∏ä‡πâ funding_rate (‡∏´‡∏≤‡∏Å‡πÑ‡∏°‡πà‡∏°‡∏µ ‡πÉ‡∏´‡πâ‡πÉ‡∏ä‡πâ‡∏Ñ‡πà‡∏≤ 0.0)
                    funding_rate = ws_data[symbol].get('funding_rate', 0.0)
                    if 'funding_rate' not in ws_data[symbol]:
                        logging.debug(f"‡πÑ‡∏°‡πà‡∏°‡∏µ funding_rate ‡πÉ‡∏ô {symbol} ‚Üí ‡πÉ‡∏ä‡πâ‡∏Ñ‡πà‡∏≤ 0.0")

                    prev_close = ws_data[symbol].get('prev_close', ws_data[symbol]['close'])
                    pct_change = (ws_data[symbol]['close'] - prev_close) / ws_data[symbol]['close']
                    volatilities.append(abs(pct_change) + abs(funding_rate))
                    ws_data[symbol]['prev_close'] = ws_data[symbol]['close']

                except Exception as e:
                    logging.warning(f"‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ú‡∏±‡∏ô‡∏ú‡∏ß‡∏ô‡∏Ç‡∏≠‡∏á {symbol} ‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î: {e}")
                    continue

        if volatilities:
            avg_volatility = np.std(volatilities)
            self.volatility_history.append(avg_volatility)
            avg_vol_history = (
                np.mean(self.volatility_history)
                if self.volatility_history
                else GlobalConfig.get('min_volatility_threshold')
            )
            base_threshold = GlobalConfig.get('min_volatility_threshold', 0.001)
            self.dynamic_risk_factor = min(2.0, max(0.5, avg_vol_history / base_threshold))
            logging.debug(f"üß† ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï dynamic risk factor: {self.dynamic_risk_factor:.2f}")

    # ==========================
    # ‡∏´‡∏¢‡∏∏‡∏î‡∏£‡∏∞‡∏ö‡∏ö‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡πÅ‡∏•‡∏∞‡∏õ‡∏¥‡∏î position ‡∏ó‡∏∏‡∏Å‡∏ï‡∏±‡∏ß
    # ==========================
    async def emergency_stop(self):
        if not self.env or not self.ws_manager:
            logging.error("env ‡∏´‡∏£‡∏∑‡∏≠ ws_manager ‡πÑ‡∏°‡πà‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö emergency stop")
            return

        for symbol in list(self.positions.keys()):
            try:
                current_price = self.ws_manager.get_latest_price(symbol)
                await self.env.close_position_async(symbol, current_price)
            except Exception as e:
                logging.error(f"‚ùå ‡∏õ‡∏¥‡∏î position {symbol} ‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î: {e}")
                continue

        logging.critical("üõë ‡∏´‡∏¢‡∏∏‡∏î‡∏â‡∏∏‡∏Å‡πÄ‡∏â‡∏¥‡∏ô: ‡∏õ‡∏¥‡∏î‡∏ó‡∏∏‡∏Å‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏ö‡∏£‡πâ‡∏≠‡∏¢‡πÅ‡∏•‡πâ‡∏ß")
