"""
คำสั่งรันใน VS Code:
1. บันทึกไฟล์นี้เป็น auto_install_libs.py ในโฟลเดอร์โปรเจ็กต์
2. เปิด VS Code และเลือก Python interpreter (มุมล่างซ้าย, แนะนำ Python 3.8+)
3. เปิด terminal (Ctrl+`) และรัน: python auto_install_libs.py
   หรือกดปุ่ม Run ▶️ ใน VS Code
4. ตัวเลือกเพิ่มเติม:
   - ข้ามการติดตั้ง: python auto_install_libs.py --skip-install
   - จำลองการติดตั้ง: python auto_install_libs.py --dry-run
   - ระบุจำนวน workers: python auto_install_libs.py --max-workers 6

โค้ดนี้จะติดตั้งทุกไลบรารีที่จำเป็นและรันโค้ดโปรเจ็กต์หลักในไฟล์เดียว
"""

# นำเข้าโมดูลที่จำเป็น
import os
import sys
import subprocess
import importlib
import importlib.util
import logging
import json
from typing import Dict, Optional, Set, List, Tuple
import ast
import re
import argparse
import platform
import ctypes
import tempfile
from concurrent.futures import ThreadPoolExecutor, as_completed
from functools import lru_cache
from pathlib import Path
from urllib.request import urlopen
from urllib.error import HTTPError, URLError

# นำเข้าโมดูลเสริม (ถ้ามี)
try:
    from tqdm import tqdm
except ImportError:
    tqdm = None

try:
    from packaging import version as pkg_version
except ImportError:
    pkg_version = None

# ==================== การตั้งค่าเริ่มต้น ====================
# ตั้งค่า logging เพื่อบันทึก log ลงไฟล์และแสดงใน terminal
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(),
        logging.FileHandler("auto_installer.log")
    ]
)
logger = logging.getLogger(__name__)

# ==================== ฟังก์ชันตรวจสอบสิทธิ์ admin ====================
def is_admin() -> bool:
    """ตรวจสอบว่าสคริปต์รันด้วยสิทธิ์ admin หรือไม่"""
    try:
        if platform.system() == "Windows":
            return ctypes.windll.shell32.IsUserAnAdmin() != 0
        else:
            return os.geteuid() == 0
    except AttributeError:
        return False

# ==================== ฟังก์ชันอัพเดท pip ====================
def self_update() -> bool:
    """อัพเดท pip เป็นเวอร์ชันล่าสุด"""
    try:
        logger.info("กำลังอัพเดท pip เป็นเวอร์ชันล่าสุด")
        cmd = [sys.executable, "-m", "pip", "install", "--upgrade", "pip"]
        if not is_admin():
            cmd.append("--user")
        with tempfile.NamedTemporaryFile(mode='w+', delete=False, encoding='utf-8') as tmp_out, \
             tempfile.NamedTemporaryFile(mode='w+', delete=False, encoding='utf-8') as tmp_err:
            result = subprocess.run(cmd, stdout=tmp_out, stderr=tmp_err, text=True, check=True)
        logger.info("อัพเดท pip สำเร็จ")
        os.unlink(tmp_out.name)
        os.unlink(tmp_err.name)
        return True
    except subprocess.CalledProcessError as e:
        with open(tmp_err.name, 'r', encoding='utf-8') as f:
            error_output = f.read()
        logger.warning(f"ไม่สามารถอัพเดท pip: {error_output}")
        os.unlink(tmp_out.name)
        os.unlink(tmp_err.name)
        return False

# ==================== ฟังก์ชันจัดการการตั้งค่า ====================
def load_config(config_path: str = "install_config.json") -> Dict:
    """โหลดการตั้งค่าจากไฟล์ JSON ถ้ามี"""
    config = {
        "max_workers": 4,
        "ignore_patterns": [".venv", "__pycache__", ".git", "tests", "docs"],
        "dry_run": False,
        "cache_ttl": 3600,
        "network_timeout": 10,
        "retry_attempts": 3
    }
    if os.path.exists(config_path):
        try:
            with open(config_path, "r", encoding="utf-8") as f:
                config.update(json.load(f))
            logger.info("โหลดไฟล์ตั้งค่าสำเร็จ")
        except Exception as e:
            logger.warning(f"ไม่สามารถโหลด {config_path}: {e}")
    return config

# ==================== ฟังก์ชันจัดการ PyPI Cache ====================
def load_pypi_cache(cache_file: str = "pypi_cache.json") -> Dict[str, str]:
    """โหลดแคชเวอร์ชัน PyPI จากไฟล์ JSON"""
    if os.path.exists(cache_file):
        try:
            with open(cache_file, "r", encoding="utf-8") as f:
                return json.load(f)
        except Exception as e:
            logger.warning(f"ไม่สามารถโหลดแคช PyPI: {e}")
    return {}

def save_pypi_cache(cache: Dict[str, str], cache_file: str = "pypi_cache.json") -> None:
    """บันทึกแคชเวอร์ชัน PyPI ลงไฟล์ JSON"""
    try:
        with open(cache_file, "w", encoding="utf-8") as f:
            json.dump(cache, f)
        logger.debug(f"บันทึกแคช PyPI ไปที่ {cache_file}")
    except Exception as e:
        logger.warning(f"ไม่สามารถบันทึกแคช PyPI: {e}")

# ==================== ฟังก์ชันดึงเวอร์ชันล่าสุดจาก PyPI ====================
@lru_cache(maxsize=128)
def get_latest_version(pkg: str, timeout: int = 10, retry: int = 3) -> Optional[str]:
    """ดึงเวอร์ชันล่าสุดของแพ็กเกจจาก PyPI พร้อมแคชและ retry"""
    pypi_cache = load_pypi_cache()
    if pkg in pypi_cache:
        logger.debug(f"ใช้เวอร์ชันจากแคชสำหรับ {pkg}: {pypi_cache[pkg]}")
        return pypi_cache[pkg]

    for attempt in range(1, retry + 1):
        try:
            url = f"https://pypi.org/pypi/{pkg}/json"
            with urlopen(url, timeout=timeout) as response:
                if response.getcode() != 200:
                    raise HTTPError(url, response.getcode(), "HTTP Error", None, None)
                data = json.loads(response.read().decode('utf-8'))
                version = data["info"]["version"]
                pypi_cache[pkg] = version
                save_pypi_cache(pypi_cache)
                return version
        except (HTTPError, URLError, json.JSONDecodeError, Exception) as e:
            logger.warning(f"พยายามครั้งที่ {attempt} ล้มเหลวในการดึงเวอร์ชันของ {pkg}: {e}")
    logger.warning(f"ไม่สามารถดึงเวอร์ชันของ {pkg} หลังจากลอง {retry} ครั้ง")
    return None

# ==================== ฟังก์ชันตรวจสอบความเข้ากันได้ ====================
def check_compatibility(pkg: str, version: Optional[str], installed_libs: Dict[str, str]) -> bool:
    """ตรวจสอบความเข้ากันได้ของแพ็กเกจกับไลบรารีที่ติดตั้งแล้ว"""
    if pkg in installed_libs and version and installed_libs[pkg] != version:
        logger.warning(f"เวอร์ชันไม่ตรงสำหรับ {pkg}: ติดตั้งแล้ว {installed_libs[pkg]}, ร้องขอ {version}")
        return False
    return True

# ==================== ฟังก์ชันติดตั้งแพ็กเกจ ====================
def install_package(pkg: str, version: Optional[str] = None, dry_run: bool = False, retry: int = 3) -> bool:
    """ติดตั้งแพ็กเกจ Python พร้อมตรวจสอบเวอร์ชันและ retry"""
    try:
        spec = importlib.util.find_spec(pkg)
        if spec:
            module = importlib.import_module(pkg)
            installed_version = getattr(module, '__version__', 'unknown')
            if version and installed_version == version:
                logger.info(f"{pkg} เวอร์ชัน {installed_version} ติดตั้งแล้ว")
                return True
            elif not version:
                logger.info(f"{pkg} (เวอร์ชัน {installed_version}) ติดตั้งแล้ว")
                return True
    except ImportError:
        pass

    if dry_run:
        logger.info(f"[Dry Run] จะติดตั้ง {pkg} {version or '(ล่าสุด)'}")
        return True

    pkg_spec = f"{pkg}=={version}" if version else pkg
    scopes = ["--user", ""] if pkg == "keyboard" else [""]
    for scope in scopes:
        for attempt in range(1, retry + 1):
            logger.info(f"ติดตั้ง {pkg_spec} {'ใน user scope' if scope else ''} (พยายามครั้งที่ {attempt}/{retry})")
            try:
                with tempfile.NamedTemporaryFile(mode='w+', delete=False, encoding='utf-8') as tmp_out, \
                     tempfile.NamedTemporaryFile(mode='w+', delete=False, encoding='utf-8') as tmp_err:
                    cmd = [sys.executable, "-m", "pip", "install"]
                    if scope:
                        cmd.append(scope)
                    cmd.append(pkg_spec)
                    result = subprocess.run(cmd, stdout=tmp_out, stderr=tmp_err, text=True, check=True)
                    logger.info(f"ติดตั้ง {pkg_spec} {'ใน user scope' if scope else ''} สำเร็จ")
                    os.unlink(tmp_out.name)
                    os.unlink(tmp_err.name)
                    return True
            except subprocess.CalledProcessError as e:
                with open(tmp_err.name, 'r', encoding='utf-8') as f:
                    error_output = f.read()
                logger.warning(f"พยายามครั้งที่ {attempt} ล้มเหลวในการติดตั้ง {pkg_spec} {'ใน user scope' if scope else ''}: {error_output}")
                os.unlink(tmp_out.name)
                os.unlink(tmp_err.name)
    logger.error(f"ไม่สามารถติดตั้ง {pkg_spec} หลังจากลอง {retry} ครั้งในทุก scope")
    return False

# ==================== ฟังก์ชันตรวจสอบและติดตั้งไลบรารี ====================
def ensure_library(lib: str, version: Optional[str] = None, dry_run: bool = False, retry: int = 3) -> bool:
    """ตรวจสอบและติดตั้งไลบรารีถ้ายังไม่ได้ติดตั้ง"""
    try:
        importlib.import_module(lib)
        logger.info(f"{lib} พร้อมใช้งานแล้ว")
        return True
    except ImportError:
        return install_package(lib, version, dry_run, retry)

# ==================== ฟังก์ชันสแกน imports จากไฟล์ Python ====================
def extract_imports(file_path: str) -> Set[str]:
    """ดึงรายชื่อไลบรารีที่ import จากไฟล์ Python"""
    libraries: Set[str] = set()
    try:
        with open(file_path, "r", encoding="utf-8") as f:
            tree = ast.parse(f.read(), filename=file_path)
            for node in ast.walk(tree):
                if isinstance(node, ast.Import):
                    for name in node.names:
                        lib_name = name.name.split('.')[0]
                        libraries.add(lib_name)
                elif isinstance(node, ast.ImportFrom):
                    if node.module:
                        lib_name = node.module.split('.')[0]
                        libraries.add(lib_name)
        logger.debug(f"วิเคราะห์ {file_path}: พบ {len(libraries)} ไลบรารี")
        return libraries
    except Exception as e:
        logger.error(f"ไม่สามารถวิเคราะห์ {file_path}: {e}")
        return set()

# ==================== ฟังก์ชันสแกนโปรเจ็กต์ ====================
def scan_project_for_libraries(project_dir: str, ignore_patterns: List[str]) -> Set[str]:
    """สแกนไฟล์ Python ในโปรเจ็กต์เพื่อหาไลบรารีที่ใช้"""
    all_libraries: Set[str] = set()
    project_path = Path(project_dir)
    ignore_regex = [re.compile(pattern) for pattern in ignore_patterns]

    for file_path in project_path.rglob("*.py"):
        if str(file_path) == str(Path(sys.argv[0]).resolve()):  # ข้ามไฟล์ตัวเอง
            continue
        if any(any(regex.search(str(part)) for regex in ignore_regex) for part in file_path.parts):
            continue
        libraries = extract_imports(str(file_path))
        all_libraries.update(libraries)

    logger.info(f"พบ {len(all_libraries)} ไลบรารีในโปรเจ็กต์")
    return all_libraries

# ==================== ฟังก์ชันตรวจจับฮาร์ดแวร์ ====================
def detect_hardware() -> Tuple[str, Optional[str]]:
    """ตรวจจับประเภทฮาร์ดแวร์ (CPU, CUDA, MPS) และเวอร์ชัน CUDA ถ้ามี"""
    try:
        output = subprocess.check_output("nvidia-smi", shell=True, text=True)
        match = re.search(r"CUDA Version:\s*(\d+\.\d+)", output)
        if match:
            cuda_version = match.group(1)
            short_version = "".join(cuda_version.split("."))
            logger.info(f"ตรวจพบ CUDA เวอร์ชัน: {cuda_version}")
            return "cuda", f"cu{short_version}"
    except Exception:
        pass
    try:
        if platform.system() == "darwin" and subprocess.run("sysctl -n machdep.cpu.brand_string", shell=True, capture_output=True, text=True).returncode == 0:
            logger.info("ตรวจพบ Apple Silicon (MPS)")
            return "mps", None
    except Exception:
        pass
    logger.info("ไม่พบ CUDA หรือ MPS ใช้ CPU")
    return "cpu", None

# ==================== ฟังก์ชันติดตั้ง PyTorch และ Torch-Geometric ====================
def install_torch_and_geometric(dry_run: bool = False, retry: int = 3) -> bool:
    """ติดตั้ง PyTorch และ Torch-Geometric ให้เข้ากับฮาร์ดแวร์"""
    cuda_mapping = {
        "10.2": "cu102", "11.0": "cu110", "11.1": "cu111", "11.2": "cu112",
        "11.3": "cu113", "11.4": "cu114", "11.5": "cu115", "11.6": "cu116",
        "11.7": "cu117", "11.8": "cu118", "12.0": "cu120", "12.1": "cu121",
        "12.2": "cu122", "12.3": "cu123", "12.4": "cu124", "12.5": "cu125",
        "12.6": "cu126", "12.7": "cu127", "12.8": "cu128"
    }
    try:
        import torch
        torch_version = torch.__version__.split("+")[0]
        logger.info(f"PyTorch {torch_version} ติดตั้งแล้ว")
        device_type, cuda_short = detect_hardware()
    except ImportError:
        if dry_run:
            logger.info("[Dry Run] จะติดตั้ง PyTorch")
            return True
        device_type, cuda_short = detect_hardware()
        index_url = None
        if device_type == "cuda" and cuda_short in cuda_mapping.values():
            index_url = f"https://download.pytorch.org/whl/{cuda_short}"
        elif device_type == "cuda":
            cuda_version = cuda_short[2:] if cuda_short else None
            if cuda_version:
                cuda_version_float = float(".".join(list(cuda_version)[:2]))
                supported_versions = sorted([float(v) for v in cuda_mapping.keys()])
                closest_version = min(supported_versions, key=lambda x: abs(x - cuda_version_float))
                cuda_short = cuda_mapping[str(closest_version)]
                index_url = f"https://download.pytorch.org/whl/{cuda_short}"
                logger.info(f"เลือก CUDA เวอร์ชันใกล้เคียงที่สุด: {closest_version}")
            else:
                cuda_short = "cpu"
        elif device_type == "mps":
            index_url = None
        else:
            cuda_short = "cpu"

        pkg_spec = "torch torchvision torchaudio"
        if index_url:
            pkg_spec += f" --index-url {index_url}"
        for attempt in range(1, retry + 1):
            logger.info(f"ติดตั้ง PyTorch (พยายามครั้งที่ {attempt}/{retry})")
            try:
                with tempfile.NamedTemporaryFile(mode='w+', delete=False, encoding='utf-8') as tmp_out, \
                     tempfile.NamedTemporaryFile(mode='w+', delete=False, encoding='utf-8') as tmp_err:
                    cmd = [sys.executable, "-m", "pip", "install"] + pkg_spec.split()
                    result = subprocess.run(cmd, stdout=tmp_out, stderr=tmp_err, text=True, check=True)
                    logger.info(f"ติดตั้ง PyTorch สำเร็จ")
                    os.unlink(tmp_out.name)
                    os.unlink(tmp_err.name)
                    import torch
                    torch_version = torch.__version__.split("+")[0]
                    break
            except subprocess.CalledProcessError as e:
                with open(tmp_err.name, 'r', encoding='utf-8') as f:
                    error_output = f.read()
                logger.warning(f"พยายามครั้งที่ {attempt} ล้มเหลวในการติดตั้ง PyTorch: {error_output}")
                os.unlink(tmp_out.name)
                os.unlink(tmp_err.name)
        else:
            logger.error(f"ไม่สามารถติดตั้ง PyTorch หลังจากลอง {retry} ครั้ง")
            return False

    logger.info(f"ตรวจพบอุปกรณ์: {device_type.upper()}")

    # ติดตั้ง Torch-Geometric และ dependencies
    required_versions = read_requirements()
    pyg_version = required_versions.get("torch_geometric") or get_latest_version("torch_geometric")
    pyg_url = f"https://data.pyg.org/whl/torch-{torch_version}+{cuda_short or 'cpu' if device_type != 'mps' else 'cpu'}"
    pyg_libs = [
        "torch_scatter", "torch_sparse", "torch_cluster",
        "torch_spline_conv", "torch_geometric"
    ]
    for lib in pyg_libs:
        if dry_run:
            logger.info(f"[Dry Run] จะติดตั้ง {lib} {required_versions.get(lib) or '(ล่าสุด)'} สำหรับ {device_type}")
            continue
        version = required_versions.get(lib) or get_latest_version(lib)
        if pkg_version and version:
            latest_version = get_latest_version(lib)
            if latest_version and pkg_version.parse(version) < pkg_version.parse(latest_version):
                logger.warning(f"requirements.txt ระบุ {lib}=={version}, แต่ล่าสุดคือ {latest_version}. ติดตั้งเวอร์ชันล่าสุด")
                version = latest_version
        for attempt in range(1, retry + 1):
            try:
                ensure_library(lib, version, dry_run, retry=1)
                with tempfile.NamedTemporaryFile(mode='w+', delete=False, encoding='utf-8') as tmp_out, \
                     tempfile.NamedTemporaryFile(mode='w+', delete=False, encoding='utf-8') as tmp_err:
                    cmd = [sys.executable, "-m", "pip", "install", "-f", pyg_url]
                    if version:
                        cmd.append(f"{lib}=={version}")
                    else:
                        cmd.append(lib)
                    result = subprocess.run(cmd, stdout=tmp_out, stderr=tmp_err, text=True, check=True)
                    logger.info(f"ติดตั้ง {lib} สำหรับ {device_type} สำเร็จ")
                    os.unlink(tmp_out.name)
                    os.unlink(tmp_err.name)
                    break
            except subprocess.CalledProcessError as e:
                with open(tmp_err.name, 'r', encoding='utf-8') as f:
                    error_output = f.read()
                logger.warning(f"พยายามครั้งที่ {attempt} ล้มเหลวในการติดตั้ง {lib}: {error_output}")
                os.unlink(tmp_out.name)
                os.unlink(tmp_err.name)
        else:
            logger.error(f"ไม่สามารถติดตั้ง {lib} หลังจากลอง {retry} ครั้ง")
            return False
    return True

# ==================== ฟังก์ชันอ่าน requirements.txt ====================
def read_requirements() -> Dict[str, str]:
    """อ่านความต้องการแพ็กเกจจาก requirements.txt"""
    requirements: Dict[str, str] = {}
    if os.path.exists("requirements.txt"):
        try:
            with open("requirements.txt", "r", encoding="utf-8") as f:
                for line in f:
                    line = line.strip()
                    if line and "==" in line and not line.startswith("#"):
                        pkg, ver = line.split("==")
                        requirements[pkg.strip()] = ver.strip()
            logger.info("อ่าน requirements.txt สำเร็จ")
        except Exception as e:
            logger.warning(f"ไม่สามารถอ่าน requirements.txt: {e}")
    return requirements

# ==================== ฟังก์ชันโค้ดโปรเจ็กต์หลัก ====================
def main_project_code():
    """โค้ดโปรเจ็กต์หลัก (แทนที่ด้วยโค้ดจริงของคุณ)"""
    logger.info("เริ่มรันโค้ดโปรเจ็กต์หลัก")
    try:
        # ตัวอย่างการใช้ไลบรารีที่ติดตั้ง
        import gym
        import pandas as pd
        import numpy as np
        import torch
        import matplotlib.pyplot as plt
        from sklearn.linear_model import LinearRegression

        # ตัวอย่างโค้ด
        logger.info("ทดสอบการใช้ไลบรารี")
        env = gym.make("CartPole-v1")
        observation = env.reset()
        logger.info(f"Gym environment: {observation}")

        df = pd.DataFrame({"x": [1, 2, 3], "y": [2, 4, 6]})
        logger.info(f"Pandas DataFrame:\n{df}")

        array = np.array([1, 2, 3])
        logger.info(f"NumPy array: {array}")

        tensor = torch.tensor([1, 2, 3])
        logger.info(f"PyTorch tensor: {tensor}")

        model = LinearRegression()
        model.fit(df[["x"]], df["y"])
        logger.info(f"Scikit-learn model coefficient: {model.coef_}")

        plt.plot(df["x"], df["y"], 'o')
        plt.title("ตัวอย่างกราฟ")
        plt.xlabel("X")
        plt.ylabel("Y")
        plt.savefig("example_plot.png")
        plt.close()
        logger.info("บันทึกกราฟตัวอย่างสำเร็จ")

        # คุณสามารถแทนที่โค้ดนี้ด้วยโค้ดโปรเจ็กต์จริงของคุณ
        print("โค้ดโปรเจ็กต์หลักทำงานสำเร็จ")
    except Exception as e:
        logger.error(f"เกิดข้อผิดพลาดในโค้ดโปรเจ็กต์หลัก: {e}")
        raise

# ==================== ฟังก์ชันติดตั้งทุกไลบรารีและรันโปรเจ็กต์ ====================
def auto_install_all(project_dir: str = ".", dry_run: bool = False, max_workers: int = 4, skip_install: bool = False) -> None:
    """ติดตั้งทุกไลบรารีและรันโค้ดโปรเจ็กต์หลัก"""
    if not skip_install and not dry_run:
        self_update()

    config = load_config()
    dry_run = dry_run or config["dry_run"]
    max_workers = max_workers or config["max_workers"]
    ignore_patterns = config["ignore_patterns"]
    timeout = config["network_timeout"]
    retry = config["retry_attempts"]

    # ติดตั้ง packaging สำหรับเปรียบเทียบเวอร์ชัน
    if not pkg_version and not dry_run and not skip_install:
        ensure_library("packaging")
        from packaging import version as pkg_version

    if skip_install and not dry_run:
        logger.info("ข้ามการติดตั้งไลบรารี ไปรันโค้ดโปรเจ็กต์หลัก")
        main_project_code()
        return

    required_versions = read_requirements()
    project_libs = scan_project_for_libraries(project_dir, ignore_patterns)
    base_libs = {
        "numpy", "pandas", "scikit-learn", "joblib", "tqdm", "matplotlib",
        "seaborn", "plotly", "ccxt", "binance", "websockets", "yfinance",
        "requests", "psutil", "ta", "pandas_ta", "gym", "openpyxl",
        "keyboard", "bayesian-optimization", "darts", "packaging"
    }
    standard_libs = {
        "sys", "os", "logging", "typing", "subprocess", "importlib", "ast",
        "json", "argparse", "urllib", "re", "functools", "concurrent", "pathlib",
        "platform", "ctypes", "datetime", "asyncio", "sqlite3", "tempfile"
    }
    all_libs = base_libs.union(project_libs) - standard_libs

    installed_libs: Dict[str, str] = {}
    failed_libs: List[str] = []

    def install_with_progress(lib: str) -> bool:
        """ติดตั้งไลบรารีพร้อมเปรียบเทียบเวอร์ชัน"""
        latest_version = get_latest_version(lib, timeout=timeout, retry=retry)
        req_version = required_versions.get(lib)
        if req_version and latest_version and pkg_version:
            if pkg_version.parse(req_version) < pkg_version.parse(latest_version):
                logger.warning(f"requirements.txt ระบุ {lib}=={req_version}, แต่ล่าสุดคือ {latest_version}. ติดตั้งเวอร์ชันล่าสุด")
                version = latest_version
            else:
                version = req_version
        else:
            version = latest_version or req_version
        if not version:
            logger.error(f"ไม่สามารถหาเวอร์ชันของ {lib}")
            return False
        if check_compatibility(lib, version, installed_libs):
            success = ensure_library(lib, version, dry_run, retry)
            if success and not dry_run:
                installed_libs[lib] = version
            return success
        failed_libs.append(lib)
        return False

    logger.info(f"เริ่มติดตั้ง {len(all_libs)} ไลบรารี (Dry Run: {dry_run})")
    if not dry_run:
        with ThreadPoolExecutor(max_workers=max_workers) as executor:
            futures = {executor.submit(install_with_progress, lib): lib for lib in all_libs}
            progress = tqdm(futures, total=len(futures), desc="กำลังติดตั้ง", disable=not tqdm)
            for future in as_completed(futures):
                lib = futures[future]
                try:
                    future.result()
                except Exception as e:
                    logger.error(f"เกิดข้อผิดพลาดในการติดตั้ง {lib}: {e}")
                    failed_libs.append(lib)
                if progress:
                    progress.update(1)
            if progress:
                progress.close()

    if "torch" in all_libs or "torch_geometric" in all_libs:
        if not install_torch_and_geometric(dry_run, retry):
            failed_libs.append("torch/torch_geometric")

    if failed_libs:
        logger.warning(f"ไม่สามารถติดตั้ง: {', '.join(failed_libs)}")
    else:
        logger.info("ติดตั้งไลบรารีทั้งหมดสำเร็จ")

    # รันโค้ดโปรเจ็กต์หลัก
    if not dry_run:
        try:
            main_project_code()
            logger.info("รันโค้ดโปรเจ็กต์หลักสำเร็จ")
        except Exception as e:
            logger.error(f"รันโค้ดโปรเจ็กต์หลักล้มเหลว: {e}")

# ==================== ฟังก์ชันหลัก ====================
def main():
    """จัดการ command-line arguments และเริ่มการติดตั้งพร้อมรันโปรเจ็กต์"""
    parser = argparse.ArgumentParser(description="ติดตั้งไลบรารี Python และรันโค้ดโปรเจ็กต์โดยอัตโนมัติ")
    parser.add_argument("--project-dir", default=".", help="โฟลเดอร์โปรเจ็กต์ที่ต้องการสแกน")
    parser.add_argument("--dry-run", action="store_true", help="จำลองการติดตั้งโดยไม่ดำเนินการจริง")
    parser.add_argument("--max-workers", type=int, default=4, help="จำนวน workers สูงสุดสำหรับการติดตั้งแบบขนาน")
    parser.add_argument("--skip-install", action="store_true", help="ข้ามการติดตั้งไลบรารีและรันโค้ดโปรเจ็กต์ทันที")
    args = parser.parse_args()

    try:
        auto_install_all(args.project_dir, args.dry_run, args.max_workers, args.skip_install)
    except Exception as e:
        logger.error(f"เกิดข้อผิดพลาดในโปรแกรม: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()
