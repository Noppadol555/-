# ติดตั้งไลบรารีที่ต้องใช้สำหรับคลาสนี้ (รันคำสั่งเหล่านี้ใน terminal ก่อนใช้งาน)
# pip install websockets aiohttp sqlite3 ccxt.async_support

import json
import asyncio
import time
import logging
import logging.handlers
import sqlite3
import websockets
from collections import deque
from datetime import datetime, timedelta
import aiohttp
from tenacity import retry, wait_exponential, stop_after_attempt

# คอนฟิกเฉพาะสำหรับคลาส WebSocketManager
# การใช้งาน: ปรับค่าในนี้เพื่อควบคุมพฤติกรรม WebSocket เช่น URL, การ reconnect, การเก็บข้อมูล
CONFIG_WS = {
    'ws_url': 'wss://fstream.binance.com/ws',  # URL หลักสำหรับ WebSocket Market Streams ของ Binance Futures
    'ws_backup_url': 'wss://stream.binance.com:9443/ws',  # URL สำรองสำหรับ WebSocket
    'max_reconnects': 10,  # จำนวนครั้งสูงสุดในการ reconnect ก่อนใช้ข้อมูลสำรอง
    'reconnect_delay_max': 60,  # วินาทีสูงสุดในการรอ reconnect
    'ws_timeout': 10,  # วินาที timeout สำหรับการรับข้อความจาก WebSocket
    'db_path': 'ws_backup.db',  # Path ของฐานข้อมูล SQLite สำหรับ备份ข้อมูล WebSocket
    'cache_size_max': 1000,  # ขนาดสูงสุดของ cache สำหรับข้อมูลล่าสุด
    'data_retention_limit': 100,  # จำนวนแถวสูงสุดที่เก็บใน SQLite ต่อ symbol (สำหรับข้อมูลล่าสุด)
    'multi_tf_list': ['1m', '3m', '5m', '15m', '30m', '1h', '2h', '4h', '6h', '8h', '12h', '1d', '3d'],  # รายการ timeframe สำหรับ aggregation
    'historical_years': 5,  # จำนวนปีของข้อมูลย้อนหลังสำหรับโหมดจำลอง
    'log_level': 'INFO',  # ระดับการบันทึก log เฉพาะสำหรับ WebSocketManager
}

# การตั้งค่าระบบบันทึก log เฉพาะสำหรับคลาสนี้
logging.basicConfig(
    level=getattr(logging, CONFIG_WS['log_level']),
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.handlers.RotatingFileHandler('websocketmanager.log', maxBytes=10*1024*1024, backupCount=5),
        logging.StreamHandler()
    ]
)

class WebSocketManager:
    def __init__(self, exchange=None, time_offset=0):
        """เริ่มต้น WebSocketManager
        Args:
            exchange: อินสแตนซ์ของ ccxt.async_support.binance จาก APIManager
            time_offset: ความแตกต่างของเวลา (มิลลิวินาที) จาก APIManager
        """
        self.url = CONFIG_WS['ws_url']
        self.backup_url = CONFIG_WS['ws_backup_url']
        self.data = {}  # เก็บข้อมูลเรียลไทม์จาก WebSocket
        self.running = False
        self.subscribed_symbols = set()
        self.reconnect_attempts = 0
        self.max_reconnects = CONFIG_WS['max_reconnects']
        self.cache = {}  # Cache สำหรับข้อมูลล่าสุด
        self.all_usdt_pairs = []
        self.db_conn = sqlite3.connect(CONFIG_WS['db_path'], timeout=10)
        self.db_conn.execute("CREATE TABLE IF NOT EXISTS ws_data (symbol TEXT, timestamp REAL, close REAL, volume REAL, funding_rate REAL, depth REAL)")
        self.db_conn.execute("CREATE TABLE IF NOT EXISTS historical_data (symbol TEXT, timestamp REAL, open REAL, high REAL, low REAL, close REAL, volume REAL)")
        self.balance_data = {'free': 0, 'locked': 0}  # เก็บยอดเงินเรียลไทม์
        self.position_data = {}  # เก็บข้อมูลตำแหน่งเรียลไทม์
        self.exchange = exchange  # อ้างอิง exchange จาก APIManager
        self.time_offset = time_offset  # ใช้ time_offset จาก APIManager
        self.multi_tf_data = {tf: deque(maxlen=1000) for tf in CONFIG_WS['multi_tf_list']}  # เก็บ OHLCV aggregate ตาม timeframe
        self.last_aggregate_time = {tf: time.time() for tf in CONFIG_WS['multi_tf_list']}  # เวลา aggregate ล่าสุดต่อ timeframe

    async def fetch_all_usdt_pairs(self):
        """ดึงรายการคู่เหรียญ USDT ทั้งหมดจาก Binance Futures"""
        try:
            markets = await self.exchange.load_markets(params={'timestamp': await self.exchange.get_adjusted_timestamp(), 'recvWindow': 5000})
            self.all_usdt_pairs = [s for s in markets.keys() if s.endswith('/USDT') and markets[s]['contract']]
            logging.info(f"ดึงคู่ USDT ทั้งหมด: {len(self.all_usdt_pairs)} เหรียญ")
        except Exception as e:
            logging.error(f"ดึงคู่ USDT ล้มเหลว: {e}")
            self.all_usdt_pairs = ['BTC/USDT', 'ETH/USDT']  # ค่า default

    async def load_historical_data(self, symbol, years=CONFIG_WS['historical_years']):
        """โหลดข้อมูลย้อนหลังสำหรับโหมดจำลอง"""
        years_ago = datetime.utcnow() - timedelta(days=365 * years)
        with self.db_conn:
            cursor = self.db_conn.execute(
                "SELECT timestamp, open, high, low, close, volume FROM historical_data WHERE symbol=? AND timestamp>=? ORDER BY timestamp ASC",
                (symbol, years_ago.timestamp())
            )
            data = cursor.fetchall()
            if len(data) < 1000:  # สมมติ limit สำหรับ historical
                try:
                    klines = await self.exchange.fetch_ohlcv(symbol, '1h', since=int(years_ago.timestamp() * 1000), limit=1000,
                                                           params={'timestamp': await self.exchange.get_adjusted_timestamp(), 'recvWindow': 5000})
                    for kline in klines:
                        timestamp, open_p, high, low, close, volume = kline
                        self.db_conn.execute(
                            "INSERT OR IGNORE INTO historical_data (symbol, timestamp, open, high, low, close, volume) VALUES (?, ?, ?, ?, ?, ?, ?)",
                            (symbol, timestamp / 1000, open_p, high, low, close, volume)
                        )
                    self.db_conn.commit()
                    logging.info(f"โหลดข้อมูลย้อนหลัง {years} ปีสำหรับ {symbol} สำเร็จ")
                    cursor = self.db_conn.execute(
                        "SELECT timestamp, open, high, low, close, volume FROM historical_data WHERE symbol=? ORDER BY timestamp ASC",
                        (symbol,)
                    )
                    data = cursor.fetchall()
                except Exception as e:
                    logging.error(f"ดึงข้อมูลย้อนหลังสำหรับ {symbol} ล้มเหลว: {e}")
                    data = [(time.time() - i*3600, 10000, 10100, 9900, 10000, 100) for i in range(1000)]  # จำลองข้อมูล
        return data

    async def aggregate_to_timeframe(self, symbol, tf, new_data):
        """รวมข้อมูลเรียลไทม์เป็น OHLCV ตาม timeframe"""
        tf_seconds = self._tf_to_seconds(tf)
        current_time = time.time()
        if current_time - self.last_aggregate_time[tf] >= tf_seconds:
            if symbol in self.data:
                close = new_data.get('close', self.data[symbol].get('close', 0))
                volume = new_data.get('volume', self.data[symbol].get('volume', 0))
                open_p = self.multi_tf_data[tf][-1][1] if self.multi_tf_data[tf] else close
                high = max(open_p, close)
                low = min(open_p, close)
                self.multi_tf_data[tf].append((current_time, open_p, high, low, close, volume))
                self.last_aggregate_time[tf] = current_time
                logging.debug(f"Aggregated data for {symbol} in {tf}")

    def _tf_to_seconds(self, tf):
        """แปลง timeframe เป็นวินาที"""
        units = {'m': 60, 'h': 3600, 'd': 86400}
        num = int(''.join(filter(str.isdigit, tf)))
        unit = tf[-1]
        return num * units.get(unit, 60)

    async def update_symbols(self, symbols):
        """อัพเดทรายการ symbols ที่สมัครรับข้อมูล"""
        new_symbols = [s.lower().replace('/', '') + '@ticker' for s in symbols]
        if set(new_symbols) != self.subscribed_symbols:
            self.subscribed_symbols = set(new_symbols[:1024])  # Binance limit 1024 streams
            if self.running:
                await self.resubscribe()

    async def resubscribe(self, websocket=None):
        """สมัครรับข้อมูล WebSocket ใหม่"""
        if websocket:
            await websocket.send(json.dumps({
                'method': 'SUBSCRIBE',
                'params': ['!userData@arr'] + list(self.subscribed_symbols),
                'id': 1
            }))
            logging.info(f"สมัครรับข้อมูลใหม่: {len(self.subscribed_symbols)} streams")

    @retry(wait=wait_exponential(multiplier=1, min=4, max=CONFIG_WS['reconnect_delay_max']), stop=stop_after_attempt(CONFIG_WS['max_reconnects']))
    async def start(self, symbols):
        """เริ่มต้น WebSocket และรับข้อมูลเรียลไทม์"""
        if not self.all_usdt_pairs:
            await self.fetch_all_usdt_pairs()
        await self.update_symbols(symbols)
        self.running = True
        urls = [self.url, self.backup_url]
        current_url_idx = 0
        while self.running:
            try:
                async with websockets.connect(urls[current_url_idx]) as websocket:
                    await self.resubscribe(websocket)
                    self.reconnect_attempts = 0
                    while self.running:
                        message = await asyncio.wait_for(websocket.recv(), timeout=CONFIG_WS['ws_timeout'])
                        data = json.loads(message)
                        await self._handle_message(data, websocket)
            except (websockets.ConnectionClosed, asyncio.TimeoutError) as e:
                self.reconnect_attempts += 1
                logging.warning(f"WebSocket ล้มเหลว: {e}, พยายามใหม่ครั้งที่ {self.reconnect_attempts}")
                if self.reconnect_attempts >= self.max_reconnects:
                    logging.error("WebSocket ล้มเหลวเกินจำกัด ใช้ข้อมูลสำรอง")
                    await self.use_fallback_data(symbols)
                    break
                await asyncio.sleep(min(5 * self.reconnect_attempts, CONFIG_WS['reconnect_delay_max']))
                current_url_idx = (current_url_idx + 1) % len(urls)
            except Exception as e:
                logging.error(f"ข้อผิดพลาดใน WebSocket: {e}")
                break

    async def stop(self):
        """หยุด WebSocket และปิดฐานข้อมูลอย่างปลอดภัย"""
        self.running = False
        self.db_conn.close()
        logging.info("หยุด WebSocket และปิดฐานข้อมูลอย่างปลอดภัย")

    async def _handle_message(self, data, websocket):
        """จัดการข้อความจาก WebSocket"""
        if 'ping' in data:
            await websocket.send(json.dumps({'pong': data['ping']}))
            logging.debug("ส่ง pong ตอบ ping จาก Binance")
        elif 'e' in data:
            if data['e'] == 'ACCOUNT_UPDATE':
                self._update_balance(data)
                self._update_position(data)
            elif data['e'] == 'ticker':
                symbol = data['s']
                new_data = {
                    'close': float(data.get('c', 0)),
                    'volume': float(data.get('v', 0)),
                    'timestamp': (data.get('E', int(time.time() * 1000)) + self.time_offset) / 1000,
                    'funding_rate': float(data.get('r', 0.0001)),
                    'depth': float(data.get('b', 0)) - float(data.get('a', 0))
                }
                self._update_data(symbol, new_data)
                await self.save_to_sqlite(new_data, symbol)
                for tf in CONFIG_WS['multi_tf_list']:
                    await self.aggregate_to_timeframe(symbol, tf, new_data)

    def _update_balance(self, data):
        """อัพเดทยอดเงินจาก WebSocket"""
        asset = data.get('a', {}).get('B', [{}])[0].get('a', 'USDT')
        if asset == 'USDT':
            self.balance_data = {
                'free': float(data.get('a', {}).get('B', [{}])[0].get('wb', 0)),
                'locked': float(data.get('a', {}).get('B', [{}])[0].get('cw', 0)) - float(data.get('a', {}).get('B', [{}])[0].get('wb', 0))
            }
            logging.debug(f"อัพเดทยอดเงิน USDT: free={self.balance_data['free']}, locked={self.balance_data['locked']}")

    def _update_position(self, data):
        """อัพเดทข้อมูลตำแหน่งจาก WebSocket"""
        positions = data.get('a', {}).get('P', [])
        for pos in positions:
            symbol = pos.get('s')
            if symbol:
                self.position_data[symbol] = {
                    'size': float(pos.get('pa', 0)),
                    'entryPrice': float(pos.get('ep', 0)),
                    'leverage': float(pos.get('l', 1)),
                    'marginMode': pos.get('mt', 'cross').lower()
                }
                logging.debug(f"อัพเดทตำแหน่ง {symbol}: size={self.position_data[symbol]['size']}, leverage={self.position_data[symbol]['leverage']}")

    def _update_data(self, symbol, new_data):
        """อัพเดทข้อมูลเรียลไทม์ใน cache"""
        self.data[symbol] = new_data
        self.cache[symbol] = self.data[symbol]
        if len(self.cache) > CONFIG_WS['cache_size_max']:
            self.cache.pop(next(iter(self.cache)))

    async def save_to_sqlite(self, data, symbol):
        """บันทึกข้อมูล WebSocket ลง SQLite"""
        with self.db_conn:
            self.db_conn.execute(
                "INSERT INTO ws_data (symbol, timestamp, close, volume, funding_rate, depth) VALUES (?, ?, ?, ?, ?, ?)",
                (symbol, data['timestamp'], data['close'], data['volume'], data['funding_rate'], data['depth'])
            )
            self.db_conn.execute(
                "DELETE FROM ws_data WHERE symbol=? AND timestamp NOT IN (SELECT timestamp FROM ws_data WHERE symbol=? ORDER BY timestamp DESC LIMIT ?)",
                (symbol, symbol, CONFIG_WS['data_retention_limit'])
            )
            self.db_conn.commit()

    async def fetch_backup_data(self, symbol):
        """ดึงข้อมูลสำรองจาก SQLite"""
        with self.db_conn:
            cursor = self.db_conn.execute(
                "SELECT close, volume, funding_rate, depth FROM ws_data WHERE symbol=? ORDER BY timestamp DESC LIMIT ?",
                (symbol, CONFIG_WS['data_retention_limit'])
            )
            data = cursor.fetchall()
        if data:
            logging.info(f"ดึงข้อมูลสำรองสำหรับ {symbol}: {len(data)} แถว")
            return data[::-1]
        return []

    async def use_fallback_data(self, symbols):
        """ใช้ข้อมูลสำรองเมื่อ WebSocket ล้มเหลว"""
        for symbol in symbols:
            backup_data = await self.fetch_backup_data(symbol)
            if backup_data:
                last_data = backup_data[-1]
                self.data[symbol] = {
                    'close': last_data[0],
                    'volume': last_data[1],
                    'timestamp': datetime.utcnow().timestamp(),
                    'funding_rate': last_data[2],
                    'depth': last_data[3]
                }
            else:
                try:
                    ticker = await self.exchange.fetch_ticker(symbol, params={'timestamp': await self.exchange.get_adjusted_timestamp(), 'recvWindow': 5000})
                    self.data[symbol] = {
                        'close': ticker['last'],
                        'volume': ticker['quoteVolume'],
                        'timestamp': datetime.utcnow().timestamp(),
                        'funding_rate': 0.0001,
                        'depth': 0
                    }
                except Exception as e:
                    logging.error(f"ดึง ticker สำรองสำหรับ {symbol} ล้มเหลว: {e}")
                    self.data[symbol] = {
                        'close': 10000,
                        'volume': 100,
                        'timestamp': datetime.utcnow().timestamp(),
                        'funding_rate': 0.0001,
                        'depth': 0
                    }
            logging.info(f"ใช้ข้อมูลสำรองสำหรับ {symbol}: ราคา {self.data[symbol]['close']}")

    def get_latest_price(self, symbol):
        """ดึงราคาล่าสุดของเหรียญ"""
        default_price = 10000
        return self.cache.get(symbol.upper(), self.data.get(symbol.upper(), {})).get('close', default_price)

    def get_latest_balance(self):
        """ดึงยอดเงินล่าสุด"""
        return self.balance_data.get('free', 0)

    async def prefetch_data(self, symbols, timeframes):
        """ดึงข้อมูลล่วงหน้าสำหรับ timeframe ที่ระบุ"""
        for symbol in symbols:
            for tf in timeframes:
                try:
                    klines = await self.exchange.fetch_ohlcv(symbol, timeframe=tf, limit=100,
                                                            params={'timestamp': await self.exchange.get_adjusted_timestamp(), 'recvWindow': 5000})
                    for kline in klines:
                        timestamp, open_p, high, low, close, volume = kline
                        self.multi_tf_data[tf].append((timestamp / 1000, open_p, high, low, close, volume))
                    logging.debug(f"ดึงข้อมูลล่วงหน้าสำหรับ {symbol} ใน {tf} สำเร็จ")
                except Exception as e:
                    logging.error(f"ดึงข้อมูลล่วงหน้าสำหรับ {symbol} ใน {tf} ล้มเหลว: {e}")

    async def check_symbol_exists(self, symbol):
        """ตรวจสอบว่าเหรียญมีอยู่ในรายการ USDT pairs"""
        return symbol in self.all_usdt_pairs
