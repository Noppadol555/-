# ===============================================
# main.py ‚Äî ‡∏£‡∏ß‡∏°‡∏ó‡∏∏‡∏Å‡∏Ñ‡∏•‡∏≤‡∏™‡πÅ‡∏•‡∏∞‡∏£‡∏±‡∏ô‡∏£‡∏∞‡∏ö‡∏ö‡πÄ‡∏ó‡∏£‡∏î‡∏´‡∏•‡∏±‡∏Å (‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏° WebSocket + APIManager)
# ===============================================

from config import GlobalConfig
import asyncio, logging, traceback
import numpy as np
import pandas as pd
import torch
import time

# ==============================
# üü¢ ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏£‡∏∞‡∏ö‡∏ö‡πÅ‡∏ö‡∏ö‡πÄ‡∏£‡∏µ‡∏¢‡∏•‡πÑ‡∏ó‡∏°‡πå
# ==============================
async def status_monitor_loop(ws_manager, api_manager, interval=10):
    while True:
        try:
            ws_ok = "‚úÖ" if ws_manager.is_running() else "‚ùå"
            api_ok = "‚úÖ" if api_manager and getattr(api_manager, "exchange", None) else "‚ùå"
            delay = round(time.time() - ws_manager.last_data_time, 1)
            symbol_count = len(ws_manager.data)
            balance = getattr(ws_manager, "balance_data", {}).get("free", 0.0)
            logging.info(
                f"‚è≥ STATUS | WebSocket={ws_ok} | API={api_ok} | Symbols={symbol_count} | Delay={delay}s | Balance={balance:.2f} USDT"
            )
        except Exception as e:
            logging.warning(f"‚ö†Ô∏è ‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏£‡∏∞‡∏ö‡∏ö‡πÑ‡∏°‡πà‡∏™‡∏°‡∏ö‡∏π‡∏£‡∏ì‡πå: {e}")
        await asyncio.sleep(interval)


# ==============================
# üß† ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô Auto Trailing Stop/Take Profit
# ==============================
async def auto_update_trailing(strategy, current_price):
    """
    ‡∏õ‡∏£‡∏±‡∏ö StopLoss / TakeProfit ‡πÅ‡∏ö‡∏ö‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏£‡∏≤‡∏Ñ‡∏≤‡πÄ‡∏Ñ‡∏•‡∏∑‡πà‡∏≠‡∏ô‡πÑ‡∏´‡∏ß‡πÑ‡∏õ‡πÉ‡∏ô‡∏ó‡∏≤‡∏á‡∏ó‡∏µ‡πà‡∏°‡∏µ‡∏Å‡∏≥‡πÑ‡∏£
    ‡πÑ‡∏°‡πà‡∏™‡πà‡∏á API order ‡πÉ‡∏´‡∏°‡πà ‡πÅ‡∏ï‡πà‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡πÉ‡∏ô local memory ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏•‡∏î API weight
    """
    try:
        trailing_callback = GlobalConfig.get('trailing_callback_rate', 0.005)
        if not strategy.get("trailing_stop") or not strategy.get("trailing_take_profit"):
            return strategy  # ‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡πÄ‡∏õ‡∏¥‡∏î‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô trailing

        action = strategy.get("action")
        entry = strategy.get("entry_price", current_price)
        stop_loss = strategy.get("stop_loss")
        take_profit = strategy.get("take_profit")

        # ‚úÖ ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ù‡∏±‡πà‡∏á LONG
        if action in ["LONG", "BUY"]:
            if current_price > entry * (1 + trailing_callback):
                # ‡∏Ç‡∏¢‡∏±‡∏ö SL ‡πÅ‡∏•‡∏∞ TP ‡∏ï‡∏≤‡∏° callback rate
                new_sl = max(stop_loss, current_price * (1 - trailing_callback))
                new_tp = max(take_profit, current_price * (1 + trailing_callback))
                strategy["stop_loss"], strategy["take_profit"] = new_sl, new_tp

        # ‚úÖ ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ù‡∏±‡πà‡∏á SHORT
        elif action in ["SHORT", "SELL"]:
            if current_price < entry * (1 - trailing_callback):
                new_sl = min(stop_loss, current_price * (1 + trailing_callback))
                new_tp = min(take_profit, current_price * (1 - trailing_callback))
                strategy["stop_loss"], strategy["take_profit"] = new_sl, new_tp

    except Exception as e:
        logging.warning(f"‚ö†Ô∏è Auto Trailing Error: {e}")

    return strategy


# ==============================
# ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏´‡∏•‡∏±‡∏Å‡∏Ç‡∏≠‡∏á‡∏£‡∏∞‡∏ö‡∏ö‡πÄ‡∏ó‡∏£‡∏î
# ==============================
async def main():
    logging.info("‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö‡∏Å‡∏≤‡∏£‡πÄ‡∏ó‡∏£‡∏î‡∏î‡πâ‡∏ß‡∏¢ CONFIG ‡∏à‡∏≤‡∏Å GlobalConfig")

    # ---------- ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏≠‡πá‡∏≠‡∏ö‡πÄ‡∏à‡πá‡∏Å‡∏ï‡πå‡∏´‡∏•‡∏±‡∏Å ----------
    api_manager = APIManager()
    ws_manager = WebSocketManager(exchange=api_manager.exchange, time_offset=api_manager.time_offset)
    trader = UnifiedQuantumTrader(GlobalConfig.get('input_dim'))
    risk_guardian = RiskGuardian()

    # üîπ ‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏° WebSocketManager ‡πÅ‡∏•‡∏∞ Exchange ‡πÄ‡∏Ç‡πâ‡∏≤‡∏Å‡∏±‡∏ö Environment
    env = MultiMarketEnv(ws_manager=ws_manager, exchange=api_manager.exchange)
    env.trader = trader

    trader.replay_buffer = ReplayBuffer()
    risk_guardian.env = env
    strategy_gen = StrategyGenerator(trader, env, risk_guardian)
    resource_manager = IntelligentResourceManager()
    kpi_optimizer = KPIOptimizer()
    risk_allocator = DynamicRiskAllocator()
    kpi_tracker = KPITracker()
    bug_fixer = AutomaticBugFixer()

    # ---------- ‡πÄ‡∏ï‡∏£‡∏µ‡∏¢‡∏°‡∏™‡∏ï‡∏£‡∏µ‡∏°‡∏£‡∏≤‡∏Ñ‡∏≤ / ‡πÄ‡∏´‡∏£‡∏µ‡∏¢‡∏ç ----------
    await ws_manager.fetch_all_usdt_pairs()
    await ws_manager.start()

    trader.current_symbols = ws_manager.all_usdt_pairs[: GlobalConfig.get('madrl_agent_count')]
    env.symbols = trader.current_symbols
    env.simulator.update_symbols(env.symbols)
    trader.madrl.update_symbols(env.symbols)

    # ---------- ‡∏á‡∏≤‡∏ô background ----------
    asyncio.create_task(resource_manager.monitor_resources())
    asyncio.create_task(status_monitor_loop(ws_manager, api_manager))  # ‚úÖ Live Status Monitor

    # ---------- ‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏¢‡πâ‡∏≠‡∏ô‡∏´‡∏•‡∏±‡∏á ----------
    for symbol in env.symbols:
        await env.load_historical_data(symbol)

    # ---------- ‡πÄ‡∏£‡∏¥‡πà‡∏° control loop ----------
    control_task = asyncio.create_task(control_loop())

    # ---------- ‡∏ï‡∏±‡πâ‡∏á‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏£‡∏∞‡∏ö‡∏ö ----------
    try:
        GlobalConfig.set('system_running', True)
    except Exception:
        GlobalConfig.CONFIG['system_running'] = True

    step_count = 0
    trader.positions = {}

    # ==================================================
    # üîÅ ‡∏ß‡∏á‡∏£‡∏±‡∏ô‡∏´‡∏•‡∏±‡∏Å‡∏Ç‡∏≠‡∏á‡∏£‡∏∞‡∏ö‡∏ö‡πÄ‡∏ó‡∏£‡∏î (Main Loop)
    # ==================================================
    while GlobalConfig.get('system_running'):
        try:
            if step_count % GlobalConfig.get('checkpoint_interval') == 0:
                torch.save(trader.qnt.state_dict(), 'qnt_checkpoint.pth')
                logging.info(f"‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å checkpoint ‡∏ó‡∏µ‡πà step {step_count}")

            top_symbols = trader.select_top_coins(ws_manager.all_usdt_pairs, ws_manager.data, kpi_tracker)
            if set(top_symbols) != set(env.symbols):
                env.symbols = top_symbols
                env.simulator.update_symbols(top_symbols)
                trader.madrl.update_symbols(top_symbols)
                await ws_manager.update_symbols(top_symbols)

            observation, rewards, done, info = await env.step()

            total_profit = info.get('profit', 0.0)
            await kpi_tracker.update(total_profit)
            kpi_factor = kpi_optimizer.optimize(kpi_tracker.daily_profit)
            env.reinvest_cap = env.initial_balance * kpi_factor

            await risk_guardian.update_dynamic_risk(ws_manager.data)
            risk_weights = await risk_allocator.allocate_risk(env.symbols, ws_manager.data, kpi_factor)

            for i, symbol in enumerate(env.symbols):
                state = observation[i]
                last_close = ws_manager.data.get(symbol, {}).get('close', None)
                series = [last_close] if last_close is not None else [0.0]
                volatility = float(np.std(series)) or 0.01

                strategy = await strategy_gen.generate_strategy(state.reshape(1, -1), symbol, volatility)
                strategy['size'] *= risk_weights.get(symbol, GlobalConfig.get('risk_per_trade'))

                # ‚úÖ ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏£‡∏∞‡∏ö‡∏ö Auto Trailing ‡∏Å‡πà‡∏≠‡∏ô execute
                if last_close is not None:
                    strategy = await auto_update_trailing(strategy, last_close)

                profit = await strategy_gen.execute_strategy(strategy)

                action_type = strategy.get('action', 'HOLD').upper()
                side = strategy.get('side', 'NEUTRAL').upper()
                position_size = strategy.get('size', 0)
                entry_price = strategy.get('entry_price', last_close or 0)

                if action_type == "BUY" or side == "LONG":
                    logging.info(f"üü¢ [{symbol}] ‡πÄ‡∏Ç‡πâ‡∏≤‡∏ã‡∏∑‡πâ‡∏≠ (LONG) | Size={position_size:.4f} | Entry={entry_price}")
                elif action_type == "SELL" or side == "SHORT":
                    logging.info(f"üî¥ [{symbol}] ‡∏Ç‡∏≤‡∏¢/‡πÄ‡∏õ‡∏¥‡∏î SHORT | Size={position_size:.4f} | Entry={entry_price}")
                elif action_type == "HOLD":
                    logging.info(f"‚ö™ [{symbol}] ‡∏ñ‡∏∑‡∏≠‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡πÄ‡∏î‡∏¥‡∏° ‡∏£‡∏≠‡∏™‡∏±‡∏ç‡∏ç‡∏≤‡∏ì‡πÉ‡∏´‡∏°‡πà...")
                else:
                    logging.info(f"üü° [{symbol}] Action={action_type}")

                trader.positions[symbol] = {
                    'side': side,
                    'size': position_size,
                    'entry_price': entry_price,
                    'timestamp': asyncio.get_event_loop().time(),
                }

                multi_tf_data = {
                    tf: env.multi_tf_data[tf].get(symbol, pd.DataFrame()).to_dict()
                    for tf in GlobalConfig.get('multi_tf_list', [])
                }

                pred_discrete, pred_cont = trader.predict(state.reshape(1, -1))
                action_idx = int(np.argmax(pred_discrete[0]))
                cont_vec = pred_cont[0]

                trader.replay_buffer.add(
                    state, action_idx, cont_vec, profit,
                    observation[i], None, None, volatility, multi_tf_data
                )

                await trader.evolve(state.reshape(1, -1), profit, volatility)

            if step_count % 1 == 0:
                active_positions = {s: trader.positions[s]['side'] for s in trader.positions if trader.positions[s]['size'] > 0}
                if active_positions:
                    logging.info(f"üìä ‡∏™‡∏£‡∏∏‡∏õ‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô: {active_positions}")
                else:
                    logging.info("üìä ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡πÄ‡∏õ‡∏¥‡∏î‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏Ç‡∏ì‡∏∞‡∏ô‡∏µ‡πâ (Flat)")

            if step_count % GlobalConfig.get('rl_train_interval') == 0 and getattr(trader.replay_buffer, "buffer", None):
                batch = trader.replay_buffer.sample(32)
                if batch:
                    states, discrete_actions, continuous_actions, rewards, next_states, _, _, atrs, multi_tf_data = batch
                    await trader.train(states, discrete_actions, continuous_actions, rewards, next_states)
                    await trader.adversarial_train(states)

            if step_count % GlobalConfig.get('auto_ml_interval') == 0:
                trader.bayes_opt.maximize(init_points=2, n_iter=GlobalConfig.get('bayes_opt_steps'))
                trader.model_weights = trader.bayes_opt.max['params']
                logging.info(f"‡∏õ‡∏£‡∏±‡∏ö‡∏ô‡πâ‡∏≥‡∏´‡∏ô‡∏±‡∏Å‡πÇ‡∏°‡πÄ‡∏î‡∏•: {trader.model_weights}")

            step_count += 1
            await asyncio.sleep(60)

        except Exception as e:
            if await bug_fixer.analyze_and_fix(e, trader, env):
                logging.info("‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏ö‡∏±‡πä‡∏Å‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à ‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏ï‡πà‡∏≠")
                continue
            logging.critical(f"‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡∏£‡πâ‡∏≤‡∏¢‡πÅ‡∏£‡∏á: {e}")
            traceback.print_exc()
            await risk_guardian.emergency_stop()
            break

    control_task.cancel()


if __name__ == "__main__":
    asyncio.run(main())
