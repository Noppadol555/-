# ===============================================
# ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô main: ‡∏£‡∏ß‡∏°‡∏ó‡∏∏‡∏Å‡∏Ñ‡∏•‡∏≤‡∏™‡πÅ‡∏•‡∏∞‡∏£‡∏±‡∏ô‡∏£‡∏∞‡∏ö‡∏ö‡∏´‡∏•‡∏±‡∏Å
# ‡∏Å‡∏≤‡∏£‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô: ‡∏£‡∏±‡∏ô‡∏£‡∏∞‡∏ö‡∏ö‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î ‡∏£‡∏ß‡∏°‡∏ñ‡∏∂‡∏á‡∏Å‡∏≤‡∏£‡πÄ‡∏ó‡∏£‡∏î‡∏à‡∏£‡∏¥‡∏á/‡∏à‡∏≥‡∏•‡∏≠‡∏á, ‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏±‡∏ö leverage, ‡πÅ‡∏•‡∏∞‡∏Å‡∏≤‡∏£‡∏ã‡∏¥‡∏á‡∏Ñ‡πå‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•
# ===============================================

from config import GlobalConfig
import asyncio, logging, traceback
import numpy as np
import pandas as pd
import torch

async def main():
    # ‡πÇ‡∏´‡∏•‡∏î CONFIG ‡∏à‡∏≤‡∏Å GlobalConfig (‡∏ñ‡πâ‡∏≤‡∏°‡∏µ override ‡∏à‡∏≤‡∏Å‡πÑ‡∏ü‡∏•‡πå‡∏†‡∏≤‡∏¢‡∏ô‡∏≠‡∏Å ‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å GlobalConfig.load_from_file('path/to/config.json'))
    logging.info("‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö‡∏Å‡∏≤‡∏£‡πÄ‡∏ó‡∏£‡∏î‡∏î‡πâ‡∏ß‡∏¢ CONFIG ‡∏à‡∏≤‡∏Å GlobalConfig")

    # ---------- ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏≠‡πá‡∏≠‡∏ö‡πÄ‡∏à‡πá‡∏Å‡∏ï‡πå‡∏´‡∏•‡∏±‡∏Å ----------
    api_manager = APIManager()
    ws_manager = WebSocketManager(exchange=api_manager.exchange, time_offset=api_manager.time_offset)
    trader = UnifiedQuantumTrader(GlobalConfig.get('input_dim'))
    risk_guardian = RiskGuardian()
    env = MultiMarketEnv()
    env.trader = trader
    trader.replay_buffer = ReplayBuffer()
    risk_guardian.env = env
    strategy_gen = StrategyGenerator(trader, env, risk_guardian)
    resource_manager = IntelligentResourceManager()
    kpi_optimizer = KPIOptimizer()
    risk_allocator = DynamicRiskAllocator()
    kpi_tracker = KPITracker()
    bug_fixer = AutomaticBugFixer()

    # ---------- ‡πÄ‡∏ï‡∏£‡∏µ‡∏¢‡∏°‡∏™‡∏ï‡∏£‡∏µ‡∏°‡∏£‡∏≤‡∏Ñ‡∏≤ / ‡πÄ‡∏´‡∏£‡∏µ‡∏¢‡∏ç ----------
    # 1) ‡∏î‡∏∂‡∏á‡∏£‡∏≤‡∏¢‡∏ä‡∏∑‡πà‡∏≠ USDT pairs ‡∏Å‡πà‡∏≠‡∏ô
    await ws_manager.fetch_all_usdt_pairs()
    # 2) ‡πÄ‡∏£‡∏¥‡πà‡∏° WebSocket (‡πÑ‡∏°‡πà‡∏™‡πà‡∏á‡∏≠‡∏≤‡∏£‡πå‡∏Å‡∏¥‡∏ß‡πÄ‡∏°‡∏ô‡∏ï‡πå ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏´‡∏•‡∏µ‡∏Å‡πÄ‡∏•‡∏µ‡πà‡∏¢‡∏á TypeError)
    await ws_manager.start()

    # ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÄ‡∏´‡∏£‡∏µ‡∏¢‡∏ç‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏ï‡∏≤‡∏°‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡πÄ‡∏≠‡πÄ‡∏à‡∏ô‡∏ï‡πå
    trader.current_symbols = ws_manager.all_usdt_pairs[: GlobalConfig.get('madrl_agent_count')]
    env.symbols = trader.current_symbols
    env.simulator.update_symbols(env.symbols)
    trader.madrl.update_symbols(env.symbols)

    # ---------- ‡∏á‡∏≤‡∏ô background ----------
    asyncio.create_task(resource_manager.monitor_resources())

    # ---------- ‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏¢‡πâ‡∏≠‡∏ô‡∏´‡∏•‡∏±‡∏á‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÄ‡∏´‡∏£‡∏µ‡∏¢‡∏ç‡∏ó‡∏µ‡πà‡πÄ‡∏•‡∏∑‡∏≠‡∏Å ----------
    for symbol in env.symbols:
        await env.load_historical_data(symbol)

    # ---------- ‡πÄ‡∏£‡∏¥‡πà‡∏° control loop ----------
    control_task = asyncio.create_task(control_loop())

    # ‡∏ï‡∏±‡πâ‡∏á‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏£‡∏∞‡∏ö‡∏ö‡πÄ‡∏õ‡πá‡∏ô running
    if hasattr(GlobalConfig, "set"):
        GlobalConfig.set('system_running', True)
    else:
        try:
            GlobalConfig.CONFIG['system_running'] = True
        except Exception:
            pass

    step_count = 0

    # ‡∏™‡∏£‡πâ‡∏≤‡∏á dict ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÄ‡∏Å‡πá‡∏ö‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏Å‡∏≤‡∏£‡∏ñ‡∏∑‡∏≠‡∏Ñ‡∏£‡∏≠‡∏á‡∏Ç‡∏≠‡∏á‡πÅ‡∏ï‡πà‡∏•‡∏∞‡πÄ‡∏´‡∏£‡∏µ‡∏¢‡∏ç
    trader.positions = {}

    while GlobalConfig.get('system_running'):
        try:
            # ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å checkpoint ‡∏ï‡∏≤‡∏° interval
            if step_count % GlobalConfig.get('checkpoint_interval') == 0:
                torch.save(trader.qnt.state_dict(), 'qnt_checkpoint.pth')
                logging.info(f"‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å checkpoint ‡∏ó‡∏µ‡πà step {step_count}")

            # ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡πÄ‡∏´‡∏£‡∏µ‡∏¢‡∏ç top coins ‡πÅ‡∏•‡∏∞‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï symbols ‡∏´‡∏≤‡∏Å‡∏°‡∏µ‡∏Å‡∏≤‡∏£‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô
            top_symbols = trader.select_top_coins(ws_manager.all_usdt_pairs, ws_manager.data, kpi_tracker)
            if set(top_symbols) != set(env.symbols):
                env.symbols = top_symbols
                env.simulator.update_symbols(top_symbols)
                trader.madrl.update_symbols(top_symbols)
                await ws_manager.update_symbols(top_symbols)

            # ‡∏ó‡∏≥‡∏´‡∏ô‡∏∂‡πà‡∏á‡∏Å‡πâ‡∏≤‡∏ß‡∏Ç‡∏≠‡∏á‡∏™‡∏†‡∏≤‡∏û‡πÅ‡∏ß‡∏î‡∏•‡πâ‡∏≠‡∏° (‡∏£‡∏ß‡∏° fetch multi_tf_data)
            observation, rewards, done, info = await env.step()

            # ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï KPI ‡πÅ‡∏•‡∏∞‡∏õ‡∏£‡∏±‡∏ö reinvest_cap
            total_profit = info.get('profit', 0.0)
            await kpi_tracker.update(total_profit)
            kpi_factor = kpi_optimizer.optimize(kpi_tracker.daily_profit)
            env.reinvest_cap = env.initial_balance * kpi_factor

            # ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï dynamic risk
            await risk_guardian.update_dynamic_risk(ws_manager.data)

            # ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏ô‡πâ‡∏≥‡∏´‡∏ô‡∏±‡∏Å‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏™‡∏µ‡πà‡∏¢‡∏á‡∏ï‡πà‡∏≠‡πÄ‡∏´‡∏£‡∏µ‡∏¢‡∏ç
            risk_weights = await risk_allocator.allocate_risk(env.symbols, ws_manager.data, kpi_factor)

            # ‡∏Å‡∏•‡∏¢‡∏∏‡∏ó‡∏ò‡πå‡∏£‡∏≤‡∏¢‡πÄ‡∏´‡∏£‡∏µ‡∏¢‡∏ç
            for i, symbol in enumerate(env.symbols):
                state = observation[i]

                # ‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ú‡∏±‡∏ô‡∏ú‡∏ß‡∏ô (‡∏Å‡∏±‡∏ô‡∏´‡∏≤‡∏£‡∏î‡πâ‡∏ß‡∏¢‡∏®‡∏π‡∏ô‡∏¢‡πå)
                last_close = ws_manager.data.get(symbol, {}).get('close', None)
                series = [last_close] if last_close is not None else [0.0]
                volatility = float(np.std(series)) or 0.01

                # ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏Å‡∏•‡∏¢‡∏∏‡∏ó‡∏ò‡πå‡∏à‡∏≤‡∏Å‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏•‡πà‡∏≤‡∏™‡∏∏‡∏î
                strategy = await strategy_gen.generate_strategy(state.reshape(1, -1), symbol, volatility)
                strategy['size'] *= risk_weights.get(symbol, GlobalConfig.get('risk_per_trade'))

                # ‡∏î‡∏≥‡πÄ‡∏ô‡∏¥‡∏ô‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á (‡∏à‡∏≥‡∏•‡∏≠‡∏á‡∏´‡∏£‡∏∑‡∏≠‡∏à‡∏£‡∏¥‡∏á‡∏ï‡∏≤‡∏°‡πÇ‡∏´‡∏°‡∏î)
                profit = await strategy_gen.execute_strategy(strategy)

                # ========== üß† ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏£‡∏∞‡∏ö‡∏ö LOG ‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡πÄ‡∏ó‡∏£‡∏î ==========
                action_type = strategy.get('action', 'HOLD').upper()
                side = strategy.get('side', 'NEUTRAL').upper()
                position_size = strategy.get('size', 0)
                entry_price = strategy.get('entry_price', 0)

                if action_type == "BUY" or side == "LONG":
                    logging.info(f"üü¢ [{symbol}] ‡πÄ‡∏Ç‡πâ‡∏≤‡∏ã‡∏∑‡πâ‡∏≠ (LONG) | Size={position_size:.4f} | Entry={entry_price}")
                elif action_type == "SELL" or side == "SHORT":
                    logging.info(f"üî¥ [{symbol}] ‡∏Ç‡∏≤‡∏¢/‡πÄ‡∏õ‡∏¥‡∏î SHORT | Size={position_size:.4f} | Entry={entry_price}")
                elif action_type == "HOLD":
                    logging.info(f"‚ö™ [{symbol}] ‡∏ñ‡∏∑‡∏≠‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡πÄ‡∏î‡∏¥‡∏° ‡∏£‡∏≠‡∏™‡∏±‡∏ç‡∏ç‡∏≤‡∏ì‡πÉ‡∏´‡∏°‡πà...")
                else:
                    logging.info(f"üü° [{symbol}] ‡∏£‡∏≠‡∏™‡∏±‡∏ç‡∏ç‡∏≤‡∏ì | Action={action_type}")

                # ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô‡∏Ç‡∏≠‡∏á‡πÄ‡∏´‡∏£‡∏µ‡∏¢‡∏ç
                trader.positions[symbol] = {
                    'side': side,
                    'size': position_size,
                    'entry_price': entry_price,
                    'timestamp': asyncio.get_event_loop().time(),
                }

                # ‡πÄ‡∏ï‡∏£‡∏µ‡∏¢‡∏° multi TF data (‡∏ñ‡πâ‡∏≤‡∏°‡∏µ)
                multi_tf_data = {
                    tf: env.multi_tf_data[tf].get(symbol, pd.DataFrame()).to_dict()
                    for tf in GlobalConfig.get('multi_tf_list', [])
                }

                # ‡∏û‡∏¢‡∏≤‡∏Å‡∏£‡∏ì‡πå‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡πÄ‡∏î‡∏µ‡∏¢‡∏ß‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏•‡∏î‡πÇ‡∏´‡∏•‡∏î
                pred_discrete, pred_cont = trader.predict(state.reshape(1, -1))
                action_idx = int(np.argmax(pred_discrete[0]))
                cont_vec = pred_cont[0]

                # ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏•‡∏á replay buffer
                trader.replay_buffer.add(
                    state,
                    action_idx,
                    cont_vec,
                    profit,
                    observation[i],
                    None,
                    None,
                    volatility,
                    multi_tf_data
                )

                # ‡∏û‡∏±‡∏í‡∏ô‡∏≤‡πÇ‡∏°‡πÄ‡∏î‡∏•‡πÅ‡∏ö‡∏ö‡∏≠‡∏≠‡∏ô‡πÑ‡∏•‡∏ô‡πå
                await trader.evolve(state.reshape(1, -1), profit, volatility)

            # üîç ‡πÅ‡∏™‡∏î‡∏á‡∏™‡∏£‡∏∏‡∏õ‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏ó‡∏∏‡∏Å 1 ‡∏£‡∏≠‡∏ö
            if step_count % 1 == 0:
                active_positions = {s: trader.positions[s]['side'] for s in trader.positions if trader.positions[s]['size'] > 0}
                if active_positions:
                    logging.info(f"üìä ‡∏™‡∏£‡∏∏‡∏õ‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô: {active_positions}")
                else:
                    logging.info("üìä ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡πÄ‡∏õ‡∏¥‡∏î‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏Ç‡∏ì‡∏∞‡∏ô‡∏µ‡πâ (Flat)")

            # ‡∏ù‡∏∂‡∏Å‡πÇ‡∏°‡πÄ‡∏î‡∏•‡∏ï‡∏≤‡∏°‡∏ä‡πà‡∏ß‡∏á‡πÄ‡∏ß‡∏•‡∏≤
            if step_count % GlobalConfig.get('rl_train_interval') == 0 and getattr(trader.replay_buffer, "buffer", None):
                batch = trader.replay_buffer.sample(32)
                if batch:
                    states, discrete_actions, continuous_actions, rewards, next_states, _, _, atrs, multi_tf_data = batch
                    await trader.train(states, discrete_actions, continuous_actions, rewards, next_states)
                    await trader.adversarial_train(states)

            # ‡∏õ‡∏£‡∏±‡∏ö‡∏ô‡πâ‡∏≥‡∏´‡∏ô‡∏±‡∏Å‡∏î‡πâ‡∏ß‡∏¢ Bayesian Optimization ‡∏ï‡∏≤‡∏°‡∏ä‡πà‡∏ß‡∏á‡πÄ‡∏ß‡∏•‡∏≤
            if step_count % GlobalConfig.get('auto_ml_interval') == 0:
                trader.bayes_opt.maximize(init_points=2, n_iter=GlobalConfig.get('bayes_opt_steps'))
                trader.model_weights = trader.bayes_opt.max['params']
                logging.info(f"‡∏õ‡∏£‡∏±‡∏ö‡∏ô‡πâ‡∏≥‡∏´‡∏ô‡∏±‡∏Å‡πÇ‡∏°‡πÄ‡∏î‡∏•: {trader.model_weights}")

            step_count += 1
            await asyncio.sleep(60)

        except Exception as e:
            if await bug_fixer.analyze_and_fix(e, trader, env):
                logging.info("‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏ö‡∏±‡πä‡∏Å‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à ‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏ï‡πà‡∏≠")
                continue
            logging.critical(f"‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡∏£‡πâ‡∏≤‡∏¢‡πÅ‡∏£‡∏á: {e}")
            traceback.print_exc()
            await risk_guardian.emergency_stop()
            break

    # ‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å control_task ‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏´‡∏¢‡∏∏‡∏î‡∏£‡∏∞‡∏ö‡∏ö
    control_task.cancel()


if __name__ == "__main__":
    asyncio.run(main())
