# auto_installer_fixed.py
# ปรับปรุงจากต้นฉบับ: แก้บั๊กสำคัญ, ปรับ error handling, ทำให้โค้ดเสถียรขึ้น
import os
import sys
import subprocess
import importlib
import importlib.util
import logging
import json
from typing import Dict, Optional, Set, List, Tuple
import ast
import re
import argparse
import platform
import ctypes
import tempfile
import shutil
from concurrent.futures import ThreadPoolExecutor, as_completed
from functools import lru_cache
from urllib.request import urlopen
from urllib.error import HTTPError, URLError
from packaging import version as pkg_version  # already imported safely at top
from packaging.requirements import Requirement
import time
import psutil
from pathlib import Path

# optional tqdm
try:
    from tqdm import tqdm
except Exception:
    tqdm = None

# ==================== Logging ====================
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(),
        logging.FileHandler("auto_installer.log")
    ]
)
logger = logging.getLogger(__name__)

# ==================== Helpers ====================
def is_admin() -> bool:
    try:
        if platform.system() == "Windows":
            return ctypes.windll.shell32.IsUserAnAdmin() != 0
        else:
            return os.geteuid() == 0
    except Exception:
        return False

def check_system_resources(min_disk_bytes: int = 2 * 1024 * 1024 * 1024, min_mem_bytes: int = 1 * 1024 * 1024 * 1024) -> bool:
    try:
        disk = shutil.disk_usage(os.path.abspath("."))
        if disk.free < min_disk_bytes:
            logger.error("พื้นที่ดิสก์เหลือน้อยเกินไป (<2GB)")
            return False
        mem = psutil.virtual_memory()
        if mem.available < min_mem_bytes:
            logger.error("หน่วยความจำเหลือน้อยเกินไป (<1GB)")
            return False
        return True
    except Exception as e:
        logger.warning(f"ไม่สามารถตรวจสอบทรัพยากรระบบ: {e}")
        return True

def check_python_version(min_version: str = "3.8") -> bool:
    current_version = f"{sys.version_info.major}.{sys.version_info.minor}"
    if pkg_version.parse(current_version) < pkg_version.parse(min_version):
        logger.error(f"ต้องการ Python >= {min_version}, พบ {current_version}")
        return False
    return True

def safe_run(cmd: List[str], timeout: Optional[int] = None) -> subprocess.CompletedProcess:
    """เรียก subprocess โดยไม่ใช้ shell=True"""
    return subprocess.run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, timeout=timeout)

# ==================== Compiler ====================
def check_and_install_compiler() -> bool:
    system = platform.system()
    try:
        if system == "Linux":
            # check gcc
            try:
                res = safe_run(["gcc", "--version"])
                if res.returncode == 0:
                    logger.info("พบ gcc สำหรับการ build source distribution")
                    return True
            except Exception:
                pass
            # try apt-get (best-effort; may fail on non-debian)
            try:
                logger.info("พยายามติดตั้ง build-essential และ cmake (ต้องใช้สิทธิ์ sudo)")
                cmd = ["sudo", "apt-get", "install", "-y", "build-essential", "cmake"]
                subprocess.run(cmd, check=True)
                return True
            except Exception as e:
                logger.error(f"ไม่สามารถติดตั้ง build-essential และ cmake: {e}")
                return False
        elif system == "Darwin":
            try:
                res = safe_run(["clang", "--version"])
                if res.returncode == 0:
                    logger.info("พบ clang สำหรับการ build source distribution")
                    return True
            except Exception:
                pass
            try:
                logger.info("พยายามติดตั้ง Xcode Command Line Tools")
                subprocess.run(["xcode-select", "--install"], check=True)
                return True
            except Exception as e:
                logger.error(f"ไม่สามารถติดตั้ง Xcode Command Line Tools: {e}")
                return False
        elif system == "Windows":
            try:
                res = safe_run(["cl"])
                if res.returncode == 0:
                    logger.info("พบ MSVC สำหรับการ build source distribution")
                    return True
            except Exception:
                pass
            logger.warning("กรุณาติดตั้ง Visual Studio Build Tools สำหรับ source builds")
            return False
    except Exception as e:
        logger.debug(f"check_and_install_compiler exception: {e}")
    return False

# ==================== pip self-update ====================
def self_update() -> bool:
    # update pip, using --user when not admin
    tmp_out = tmp_err = None
    try:
        logger.info("กำลังอัพเดท pip เป็นเวอร์ชันล่าสุด")
        cmd = [sys.executable, "-m", "pip", "install", "--upgrade", "pip"]
        if not is_admin():
            cmd.append("--user")
        with tempfile.NamedTemporaryFile(mode='w+', delete=False, encoding='utf-8') as tmp_out:
            with tempfile.NamedTemporaryFile(mode='w+', delete=False, encoding='utf-8') as tmp_err:
                try:
                    subprocess.run(cmd, stdout=tmp_out, stderr=tmp_err, check=True, text=True)
                finally:
                    pass
        logger.info("อัพเดท pip สำเร็จ")
        try:
            os.unlink(tmp_out.name)
            os.unlink(tmp_err.name)
        except Exception:
            pass
        return True
    except subprocess.CalledProcessError:
        # try to read error if files exist
        try:
            if tmp_err and os.path.exists(tmp_err.name):
                with open(tmp_err.name, 'r', encoding='utf-8') as f:
                    logger.warning(f"ไม่สามารถอัพเดท pip: {f.read()}")
        except Exception:
            pass
        try:
            if tmp_out and os.path.exists(tmp_out.name):
                os.unlink(tmp_out.name)
            if tmp_err and os.path.exists(tmp_err.name):
                os.unlink(tmp_err.name)
        except Exception:
            pass
        return False
    except Exception as e:
        logger.warning(f"ไม่สามารถอัพเดท pip: {e}")
        return False

# ==================== Config ====================
def load_config(config_path: str = "install_config.json") -> Dict:
    config = {
        "max_workers": 4,
        "ignore_patterns": [".venv", "__pycache__", ".git", "tests", "docs"],
        "dry_run": False,
        "cache_ttl": 3600,
        "network_timeout": 10,
        "retry_attempts": 5,
        "max_retries_network": 5,
        "backoff_factor": 2
    }
    if os.path.exists(config_path):
        try:
            with open(config_path, "r", encoding="utf-8") as f:
                config.update(json.load(f))
            logger.info("โหลดไฟล์ตั้งค่าสำเร็จ")
        except Exception as e:
            logger.warning(f"ไม่สามารถโหลด {config_path}: {e}")
    return config

# ==================== PyPI cache ====================
def load_pypi_cache(cache_file: str = "pypi_cache.json") -> Dict[str, Dict]:
    if os.path.exists(cache_file):
        try:
            with open(cache_file, "r", encoding="utf-8") as f:
                cache = json.load(f)
                # validate TTL later by caller
                return cache
        except Exception as e:
            logger.warning(f"ไม่สามารถโหลดแคช PyPI: {e}")
    return {}

def save_pypi_cache(cache: Dict[str, Dict], cache_file: str = "pypi_cache.json") -> None:
    try:
        with open(cache_file, "w", encoding="utf-8") as f:
            json.dump(cache, f)
        logger.debug(f"บันทึกแคช PyPI ไปที่ {cache_file}")
    except Exception as e:
        logger.warning(f"ไม่สามารถบันทึกแคช PyPI: {e}")

# ==================== PyPI info ====================
@lru_cache(maxsize=256)
def get_pypi_info(pkg: str, timeout: int = 10, retry: int = 5, backoff_factor: float = 2, cache_ttl: int = 3600) -> Optional[Dict]:
    pkg_norm = pkg.lower().replace("_", "-")
    cache = load_pypi_cache()
    entry = cache.get(pkg_norm)
    current_time = time.time()
    if entry and entry.get("timestamp", 0) + cache_ttl > current_time:
        return entry

    url = f"https://pypi.org/pypi/{pkg_norm}/json"
    for attempt in range(1, retry + 1):
        try:
            with urlopen(url, timeout=timeout) as response:
                if response.getcode() != 200:
                    raise HTTPError(url, response.getcode(), "HTTP Error", None, None)
                data = json.loads(response.read().decode('utf-8'))
                out = {
                    "version": data["info"]["version"],
                    "requires_dist": data["info"].get("requires_dist", []),
                    "releases": data.get("releases", {}),
                    "timestamp": time.time()
                }
                cache[pkg_norm] = out
                save_pypi_cache(cache)
                return out
        except (HTTPError, URLError, json.JSONDecodeError, Exception) as e:
            logger.debug(f"พยายามครั้งที่ {attempt} ล้มเหลวในการดึงข้อมูลของ {pkg}: {e}")
            if attempt < retry:
                time.sleep(backoff_factor * (2 ** (attempt - 1)))
    logger.warning(f"ไม่สามารถดึงข้อมูลของ {pkg} หลังจากลอง {retry} ครั้ง")
    return None

# ==================== Wheel availability ====================
def check_wheel_availability(pkg: str, version: str, platform_tags: List[str], timeout: int = 10, retry: int = 3) -> bool:
    pkg_norm = pkg.lower().replace("_", "-")
    cache = load_pypi_cache()
    cache_key = f"{pkg_norm}:{version}"
    if cache.get(cache_key) and "wheels" in cache[cache_key]:
        return cache[cache_key]["wheels"]
    url = f"https://pypi.org/pypi/{pkg_norm}/{version}/json"
    for attempt in range(1, retry + 1):
        try:
            with urlopen(url, timeout=timeout) as response:
                if response.getcode() != 200:
                    raise HTTPError(url, response.getcode(), "HTTP Error", None, None)
                data = json.loads(response.read().decode('utf-8'))
                has_wheel = False
                for release in data.get("releases", {}).get(version, []):
                    if release.get("packagetype") == "bdist_wheel":
                        fname = release.get("filename", "")
                        for tag in platform_tags:
                            if tag and tag in fname:
                                has_wheel = True
                                break
                        if has_wheel:
                            break
                cache[cache_key] = {"wheels": has_wheel, "timestamp": time.time()}
                save_pypi_cache(cache)
                return has_wheel
        except Exception as e:
            logger.debug(f"ตรวจ wheel ล้มเหลว (attempt {attempt}) สำหรับ {pkg}=={version}: {e}")
            if attempt < retry:
                time.sleep(2 ** attempt)
    logger.warning(f"ไม่สามารถตรวจสอบ wheel สำหรับ {pkg}=={version}")
    return False

# ==================== Resolve conflicts ====================
def resolve_conflicts(requirements: Dict[str, str], installed_libs: Dict[str, str]) -> Dict[str, str]:
    resolved = requirements.copy()
    for pkg, ver in list(requirements.items()):
        pinfo = get_pypi_info(pkg)
        if not pinfo:
            continue
        for dep in pinfo.get("requires_dist", []):
            try:
                req = Requirement(dep)
                dep_name = req.name.replace("-", "_").lower()
                if dep_name in resolved:
                    dep_version = resolved[dep_name]
                    if not req.specifier.contains(dep_version):
                        logger.warning(f"ความขัดแย้ง: {pkg} ต้องการ {dep}, แต่มี {dep_name}=={dep_version}")
                        # try latest that matches specifier
                        dep_info = get_pypi_info(dep_name)
                        if dep_info:
                            for candidate in sorted(dep_info.get("releases", {}).keys(), key=lambda x: pkg_version.parse(x), reverse=True):
                                if req.specifier.contains(candidate):
                                    resolved[dep_name] = candidate
                                    logger.info(f"แก้ไขโดยใช้ {dep_name}=={candidate}")
                                    break
                            else:
                                logger.warning(f"ไม่สามารถแก้ไขความขัดแย้งสำหรับ {dep_name}")
            except Exception:
                continue
    return resolved

# ==================== Select compatible version ====================
def select_compatible_version(pkg: str, device_type: str, cuda_version: Optional[str], python_tag: str, platform_tags: List[str], installed_libs: Dict[str, str]) -> Optional[str]:
    info = get_pypi_info(pkg)
    if not info:
        return None
    latest = info.get("version")
    # default: prefer latest but check wheel
    if check_wheel_availability(pkg, latest, platform_tags):
        return latest
    # fallback: find newest release that has wheel
    releases = info.get("releases", {})
    for ver in sorted(releases.keys(), key=lambda x: pkg_version.parse(x), reverse=True):
        if check_wheel_availability(pkg, ver, platform_tags):
            return ver
    # as last resort return latest (may require source build)
    return latest

# ==================== Get dependencies recursively ====================
def get_dependencies(pkg: str, visited: Set[str] = None) -> Dict[str, str]:
    if visited is None:
        visited = set()
    name = pkg.lower().replace("_", "-")
    if name in visited:
        return {}
    visited.add(name)
    deps: Dict[str, str] = {}
    pinfo = get_pypi_info(name)
    if not pinfo:
        return deps
    for dep in pinfo.get("requires_dist", []):
        try:
            req = Requirement(dep)
            dep_name = req.name.replace("-", "_").lower()
            if dep_name in {"python", "setuptools", "wheel"}:
                continue
            dep_info = get_pypi_info(dep_name)
            if dep_info:
                dep_ver = dep_info.get("version")
                if dep_ver and (not req.specifier or req.specifier.contains(dep_ver)):
                    deps[dep_name] = dep_ver
                    sub = get_dependencies(dep_name, visited)
                    deps.update(sub)
        except Exception:
            continue
    return deps

# ==================== Generate requirements.txt ====================
def generate_requirements(project_libs: Set[str], device_type: str, cuda_version: Optional[str], python_tag: str, platform_tags: List[str], installed_libs: Dict[str, str], requirements_file: str = "requirements.txt") -> bool:
    try:
        requirements: Dict[str, str] = {}
        for lib in sorted(project_libs):
            ver = select_compatible_version(lib, device_type, cuda_version, python_tag, platform_tags, installed_libs)
            if ver:
                requirements[lib] = ver
                deps = get_dependencies(lib)
                requirements.update(deps)
            else:
                logger.warning(f"ข้าม {lib} เนื่องจากไม่พบเวอร์ชันที่เหมาะสม")
        requirements = resolve_conflicts(requirements, installed_libs)
        with open(requirements_file, "w", encoding="utf-8") as f:
            f.write("# requirements.txt สร้างโดยอัตโนมัติ\n")
            for pkg, ver in sorted(requirements.items()):
                f.write(f"{pkg}=={ver}\n")
        logger.info(f"สร้าง {requirements_file} สำเร็จ มี {len(requirements)} ไลบรารี")
        return True
    except Exception as e:
        logger.error(f"ไม่สามารถสร้าง {requirements_file}: {e}")
        return False

# ==================== pip install helper ====================
def install_package(pkg: str, version: Optional[str] = None, dry_run: bool = False, retry: int = 5, index_url: Optional[str] = None) -> bool:
    # try import to check presence
    try:
        spec = importlib.util.find_spec(pkg)
        if spec:
            module = importlib.import_module(pkg)
            installed_version = getattr(module, '__version__', None)
            if version and installed_version == version:
                logger.info(f"{pkg} เวอร์ชัน {installed_version} ติดตั้งแล้ว")
                return True
            elif not version:
                logger.info(f"{pkg} (เวอร์ชัน {installed_version}) ติดตั้งแล้ว")
                return True
    except Exception:
        pass

    if dry_run:
        logger.info(f"[Dry Run] จะติดตั้ง {pkg} {version or '(ล่าสุด)'}")
        return True

    pkg_spec = f"{pkg}=={version}" if version else pkg
    scopes = ["--user", ""] if not is_admin() else [""]
    for scope in scopes:
        for attempt in range(1, retry + 1):
            tmp_out = tmp_err = None
            try:
                logger.info(f"ติดตั้ง {pkg_spec} {'ใน user scope' if scope else ''} (พยายามครั้งที่ {attempt}/{retry})")
                with tempfile.NamedTemporaryFile(mode='w+', delete=False, encoding='utf-8') as tmp_out:
                    with tempfile.NamedTemporaryFile(mode='w+', delete=False, encoding='utf-8') as tmp_err:
                        cmd = [sys.executable, "-m", "pip", "install"]
                        if scope:
                            cmd.append(scope)
                        if index_url:
                            cmd.extend(["--index-url", index_url])
                        cmd.append(pkg_spec)
                        subprocess.run(cmd, stdout=tmp_out, stderr=tmp_err, check=True, text=True)
                logger.info(f"ติดตั้ง {pkg_spec} {'ใน user scope' if scope else ''} สำเร็จ")
                # cleanup
                try:
                    os.unlink(tmp_out.name)
                    os.unlink(tmp_err.name)
                except Exception:
                    pass
                return True
            except subprocess.CalledProcessError:
                # read error
                try:
                    if tmp_err and os.path.exists(tmp_err.name):
                        with open(tmp_err.name, 'r', encoding='utf-8') as f:
                            error_output = f.read()
                        logger.warning(f"พยายามครั้งที่ {attempt} ล้มเหลวในการติดตั้ง {pkg_spec}: {error_output}")
                except Exception:
                    pass
                try:
                    if tmp_out and os.path.exists(tmp_out.name):
                        os.unlink(tmp_out.name)
                    if tmp_err and os.path.exists(tmp_err.name):
                        os.unlink(tmp_err.name)
                except Exception:
                    pass
                if attempt < retry:
                    time.sleep(2 ** attempt)
            except Exception as e:
                logger.warning(f"ติดตั้ง {pkg_spec} ล้มเหลวด้วย exception: {e}")
                if tmp_out and os.path.exists(tmp_out.name):
                    try:
                        os.unlink(tmp_out.name)
                        os.unlink(tmp_err.name)
                    except Exception:
                        pass
                break
    logger.error(f"ไม่สามารถติดตั้ง {pkg_spec} หลังจากลอง {retry} ครั้ง")
    return False

def ensure_library(lib: str, version: Optional[str] = None, dry_run: bool = False, retry: int = 5, index_url: Optional[str] = None) -> bool:
    try:
        importlib.import_module(lib)
        logger.info(f"{lib} พร้อมใช้งานแล้ว")
        return True
    except ImportError:
        return install_package(lib, version, dry_run, retry, index_url)

# ==================== Extract imports ====================
def extract_imports(file_path: str) -> Set[str]:
    libraries: Set[str] = set()
    try:
        with open(file_path, "r", encoding="utf-8") as f:
            tree = ast.parse(f.read(), filename=file_path)
            for node in ast.walk(tree):
                if isinstance(node, ast.Import):
                    for name in node.names:
                        lib_name = name.name.split('.')[0]
                        libraries.add(lib_name)
                elif isinstance(node, ast.ImportFrom):
                    if node.module:
                        lib_name = node.module.split('.')[0]
                        libraries.add(lib_name)
        return libraries
    except Exception as e:
        logger.debug(f"ไม่สามารถวิเคราะห์ {file_path}: {e}")
        return set()

def scan_project_for_libraries(project_dir: str, ignore_patterns: List[str]) -> Set[str]:
    all_libraries: Set[str] = set()
    project_path = Path(project_dir)
    ignore_regex = [re.compile(pattern) for pattern in ignore_patterns]
    current_script = Path(sys.argv[0]).resolve()
    for file_path in project_path.rglob("*.py"):
        try:
            if file_path.resolve() == current_script:
                continue
        except Exception:
            pass
        if any(any(regex.search(str(part)) for regex in ignore_regex) for part in file_path.parts):
            continue
        libs = extract_imports(str(file_path))
        all_libraries.update(libs)
    logger.info(f"พบ {len(all_libraries)} ไลบรารีในโปรเจ็กต์")
    return all_libraries

# ==================== Detect hardware ====================
def detect_hardware() -> Tuple[str, Optional[str]]:
    try:
        res = safe_run(["nvidia-smi", "--query-gpu=driver_version", "--format=csv,noheader"], timeout=5)
        if res.returncode == 0 and res.stdout.strip():
            # get CUDA version by running nvidia-smi and parse possible "CUDA Version" line
            try:
                out = subprocess.check_output(["nvidia-smi"], text=True)
                m = re.search(r"CUDA Version:\s*([\d\.]+)", out)
                if m:
                    cuda_version = m.group(1)
                    short = "cu" + "".join(cuda_version.split("."))
                    logger.info(f"ตรวจพบ CUDA เวอร์ชัน: {cuda_version}")
                    return "cuda", short
            except Exception:
                return "cuda", None
    except Exception:
        pass
    # check mac mps
    try:
        if platform.system() == "Darwin" and platform.machine().startswith("arm"):
            logger.info("ตรวจพบ Apple Silicon (MPS)")
            return "mps", None
    except Exception:
        pass
    logger.info("ไม่พบ CUDA หรือ MPS ใช้ CPU")
    return "cpu", None

# ==================== Compatibility check ====================
def check_compatibility(lib: str, version: str, installed_libs: Dict[str, str]) -> bool:
    info = get_pypi_info(lib)
    if not info:
        logger.debug(f"ไม่พบ pypi info สำหรับ {lib} — ข้ามการตรวจ")
        return True
    for dep in info.get("requires_dist", []):
        try:
            req = Requirement(dep)
            dep_name = req.name.replace("-", "_").lower()
            if dep_name in installed_libs:
                installed_version = installed_libs[dep_name]
                if not req.specifier.contains(installed_version):
                    logger.warning(f"ความขัดแย้ง: {lib}=={version} ต้องการ {dep}, แต่ติดตั้ง {dep_name}=={installed_version}")
                    return False
        except Exception:
            continue
    return True

# ==================== Torch & Geometric installer ====================
def install_torch_and_geometric(dry_run: bool = False, retry: int = 5, python_tag: str = None, platform_tags: List[str] = None) -> bool:
    cuda_mapping = {
        "10.2": "cu102", "11.0": "cu110", "11.1": "cu111", "11.2": "cu112",
        "11.3": "cu113", "11.4": "cu114", "11.5": "cu115", "11.6": "cu116",
        "11.7": "cu117", "11.8": "cu118", "12.0": "cu120", "12.1": "cu121",
        "12.2": "cu122", "12.3": "cu123", "12.4": "cu124", "12.5": "cu125",
        "12.6": "cu126", "12.7": "cu127", "12.8": "cu128"
    }
    try:
        import torch
        torch_version = torch.__version__.split("+")[0]
        logger.info(f"PyTorch {torch_version} ติดตั้งแล้ว")
    except Exception:
        torch_version = None

    device_type, cuda_short = detect_hardware()
    index_url = None
    if device_type == "cuda" and cuda_short:
        index_url = f"https://download.pytorch.org/whl/{cuda_short}"
    elif device_type == "mps":
        index_url = None
    else:
        cuda_short = "cpu"

    # install torch if not present
    if not torch_version:
        if dry_run:
            logger.info("[Dry Run] จะติดตั้ง PyTorch")
            torch_version = "unknown"
        else:
            # use pip to install torch torchvision torchaudio (index if cuda)
            pkg_spec = ["torch", "torchvision", "torchaudio"]
            for attempt in range(1, retry + 1):
                try:
                    cmd = [sys.executable, "-m", "pip", "install"] + pkg_spec
                    if index_url:
                        cmd += ["--index-url", index_url]
                    subprocess.run(cmd, check=True)
                    import torch as _t
                    torch_version = _t.__version__.split("+")[0]
                    logger.info(f"ติดตั้ง PyTorch สำเร็จ: {torch_version}")
                    break
                except Exception as e:
                    logger.warning(f"ติดตั้ง PyTorch ล้มเหลว (attempt {attempt}): {e}")
                    if attempt < retry:
                        time.sleep(2 ** attempt)
            else:
                logger.error("ไม่สามารถติดตั้ง PyTorch หลังจากลองหลายครั้ง")
                return False

    logger.info(f"ตรวจพบอุปกรณ์: {device_type.upper()} (cuda_short={cuda_short})")

    # torch-geometric and its related libs
    pyg_libs = ["torch_scatter", "torch_sparse", "torch_cluster", "torch_spline_conv", "torch_geometric"]
    # build pyg index URL if needed
    pyg_base = None
    if torch_version and cuda_short:
        # safe fallback
        try:
            pyg_base = f"https://data.pyg.org/whl/torch-{torch_version}+{cuda_short}"
        except Exception:
            pyg_base = None

    for lib in pyg_libs:
        if dry_run:
            logger.info(f"[Dry Run] จะติดตั้ง {lib}")
            continue
        # select version from PyPI or let pip choose
        ver = None
        try:
            info = get_pypi_info(lib)
            if info:
                ver = info.get("version")
        except Exception:
            ver = None
        # check wheel availability
        if ver and not check_wheel_availability(lib, ver, platform_tags or []):
            logger.warning(f"ไม่มี wheel สำหรับ {lib}=={ver} บนแพลตฟอร์มนี้ อาจต้อง build จาก source")
            if not check_and_install_compiler():
                logger.error(f"ไม่สามารถติดตั้ง {lib} เนื่องจากไม่มี compiler")
                return False
        # install
        for attempt in range(1, retry + 1):
            try:
                index = pyg_base if pyg_base else None
                success = install_package(lib, ver, dry_run=False, retry=1, index_url=index)
                if success:
                    logger.info(f"ติดตั้ง {lib} สำเร็จ")
                    break
            except Exception as e:
                logger.warning(f"พยายามติดตั้ง {lib} ล้มเหลว (attempt {attempt}): {e}")
                if attempt < retry:
                    time.sleep(2 ** attempt)
        else:
            logger.error(f"ไม่สามารถติดตั้ง {lib} หลังจากลอง {retry} ครั้ง")
            return False
    return True

# ==================== Read requirements ====================
def read_requirements(requirements_file: str = "requirements.txt") -> Dict[str, str]:
    requirements: Dict[str, str] = {}
    if os.path.exists(requirements_file):
        try:
            with open(requirements_file, "r", encoding="utf-8") as f:
                for line in f:
                    line = line.strip()
                    if line and "==" in line and not line.startswith("#"):
                        pkg, ver = line.split("==", 1)
                        key = pkg.strip().lower().replace("-", "_")
                        requirements[key] = ver.strip()
            logger.info("อ่าน requirements.txt สำเร็จ")
        except Exception as e:
            logger.warning(f"ไม่สามารถอ่าน {requirements_file}: {e}")
    return requirements

# ==================== Main project code (test run) ====================
def main_project_code():
    logger.info("เริ่มรันโค้ดโปรเจ็กต์หลัก")
    try:
        import ccxt
        import tenacity
        import torch
        import numpy as np
        import pandas as pd
        import matplotlib.pyplot as plt
        from sklearn.linear_model import LinearRegression
        import darts
        import ta
        logger.info("ทดสอบการใช้ไลบรารี")
        logger.info(f"CCXT version: {getattr(ccxt, '__version__', 'unknown')}")
        logger.info(f"Tenacity version: {getattr(tenacity, '__version__', 'unknown')}")
        logger.info(f"PyTorch version: {torch.__version__}")
        logger.info(f"Darts version: {getattr(darts, '__version__', 'unknown')}")
        df = pd.DataFrame({"x": [1, 2, 3], "y": [2, 4, 6]})
        logger.info(f"Pandas DataFrame:\n{df}")
        array = np.array([1, 2, 3])
        tensor = torch.tensor([1, 2, 3])
        model = LinearRegression()
        model.fit(df[["x"]], df["y"])
        plt.plot(df["x"], df["y"], 'o')
        plt.title("ตัวอย่างกราฟ")
        plt.xlabel("X")
        plt.ylabel("Y")
        plt.savefig("example_plot.png")
        plt.close()
        logger.info("บันทึกกราฟตัวอย่างสำเร็จ")
        print("โค้ดโปรเจ็กต์หลักทำงานสำเร็จ")
    except Exception as e:
        logger.error(f"เกิดข้อผิดพลาดในโค้ดโปรเจ็กต์หลัก: {e}")
        raise

# ==================== Auto install all ====================
def auto_install_all(project_dir: str = ".", dry_run: bool = False, max_workers: int = 4, skip_install: bool = False, generate_requirements: bool = True):
    if not check_system_resources():
        logger.error("ทรัพยากรระบบไม่เพียงพอ")
        sys.exit(1)
    if not check_python_version("3.8"):
        logger.error("Python version ไม่เข้ากันได้ ต้องการ >=3.8")
        sys.exit(1)

    # update pip unless dry_run or skip_install
    if not skip_install and not dry_run:
        try:
            self_update()
        except Exception:
            pass

    config = load_config()
    dry_run = dry_run or config.get("dry_run", False)
    max_workers = max_workers or config.get("max_workers", 4)
    ignore_patterns = config.get("ignore_patterns", [])
    timeout = config.get("network_timeout", 10)
    retry = config.get("retry_attempts", 5)
    backoff = config.get("backoff_factor", 2)
    cache_ttl = config.get("cache_ttl", 3600)

    python_tag = f"cp{sys.version_info.major}{sys.version_info.minor}"
    platform_tags = [platform.system().lower(), platform.machine()]

    # ensure packaging present (should be, but best-effort)
    try:
        import packaging  # type: ignore
    except Exception:
        ensure_library("packaging", dry_run=dry_run)

    if skip_install and not dry_run:
        main_project_code()
        return

    project_libs = scan_project_for_libraries(project_dir, ignore_patterns)
    base_libs = {
        "ccxt", "tenacity", "torch", "numpy", "pandas", "scikit-learn",
        "bayesian-optimization", "matplotlib", "seaborn", "darts",
        "torch-geometric", "psutil", "gym", "openpyxl", "keyboard", "ta"
    }
    standard_libs = {
        "sys", "os", "logging", "typing", "subprocess", "importlib", "ast",
        "json", "argparse", "urllib", "re", "functools", "concurrent", "pathlib",
        "platform", "ctypes", "datetime", "asyncio", "sqlite3", "tempfile"
    }
    all_libs = set([lib.lower().replace("-", "_") for lib in base_libs.union(project_libs)]) - set([s.lower() for s in standard_libs])

    device_type, cuda_version = detect_hardware()
    installed_libs: Dict[str, str] = {}

    # generate requirements
    if generate_requirements and not dry_run and not os.path.exists("requirements.txt"):
        logger.info("กำลังสร้าง requirements.txt อัตโนมัติ")
        generate_requirements(all_libs, device_type, cuda_version, python_tag, platform_tags, installed_libs)

    required_versions = read_requirements()
    failed_libs: List[str] = []

    def install_with_progress(lib: str) -> bool:
        index_url = None
        if lib in {"torch_scatter", "torch_sparse", "torch_cluster", "torch_spline_conv", "torch_geometric"}:
            index_url = None  # managed in install_torch_and_geometric or set later
        version = required_versions.get(lib) or select_compatible_version(lib, device_type, cuda_version, python_tag, platform_tags, installed_libs)
        if not version:
            logger.error(f"ไม่สามารถหาเวอร์ชันของ {lib}")
            failed_libs.append(lib)
            return False
        if check_compatibility(lib, version, installed_libs):
            success = ensure_library(lib, version, dry_run, retry, index_url)
            if success and not dry_run:
                installed_libs[lib] = version
            return success
        logger.warning(f"ความเข้ากันไม่ได้สำหรับ {lib}=={version}")
        failed_libs.append(lib)
        return False

    logger.info(f"เริ่มติดตั้ง {len(all_libs)} ไลบรารี (Dry Run: {dry_run})")
    if not dry_run:
        with ThreadPoolExecutor(max_workers=max_workers) as executor:
            futures = {executor.submit(install_with_progress, lib): lib for lib in all_libs}
            progress = tqdm(total=len(futures), desc="กำลังติดตั้ง", disable=(tqdm is None))
            for future in as_completed(futures):
                lib = futures[future]
                try:
                    future.result()
                except Exception as e:
                    logger.error(f"เกิดข้อผิดพลาดในการติดตั้ง {lib}: {e}")
                    failed_libs.append(lib)
                if progress:
                    progress.update(1)
            if progress:
                progress.close()

    # torch/geometric special handling
    if "torch" in all_libs or "torch_geometric" in all_libs:
        if not install_torch_and_geometric(dry_run, retry, python_tag, platform_tags):
            failed_libs.append("torch/torch_geometric")

    if failed_libs:
        logger.warning(f"ไม่สามารถติดตั้ง: {', '.join(sorted(set(failed_libs)))}")
        logger.info("กรุณาตรวจสอบ auto_installer.log และติดตั้งไลบรารีที่ล้มเหลวด้วยตนเอง")
    else:
        logger.info("ติดตั้งไลบรารีทั้งหมดสำเร็จ")

    if not dry_run:
        try:
            main_project_code()
            logger.info("รันโค้ดโปรเจ็กต์หลักสำเร็จ")
        except Exception as e:
            logger.error(f"รันโค้ดโปรเจ็กต์หลักล้มเหลว: {e}")

# ==================== CLI ====================
def main():
    parser = argparse.ArgumentParser(description="ติดตั้งไลบรารี Python และรันโค้ดโปรเจ็กต์โดยอัตโนมัติ")
    parser.add_argument("--project-dir", default=".", help="โฟลเดอร์โปรเจ็กต์ที่ต้องการสแกน")
    parser.add_argument("--dry-run", action="store_true", help="จำลองการติดตั้งโดยไม่ดำเนินการจริง")
    parser.add_argument("--max-workers", type=int, default=4, help="จำนวน workers สูงสุดสำหรับการติดตั้งแบบขนาน")
    parser.add_argument("--skip-install", action="store_true", help="ข้ามการติดตั้งไลบรารีและรันโค้ดโปรเจ็กต์ทันที")
    parser.add_argument("--no-generate-requirements", action="store_true", help="ไม่สร้าง requirements.txt อัตโนมัติ")
    args = parser.parse_args()

    try:
        auto_install_all(
            args.project_dir,
            args.dry_run,
            args.max_workers,
            args.skip_install,
            generate_requirements=not args.no_generate_requirements
        )
    except Exception as e:
        logger.error(f"เกิดข้อผิดพลาดในโปรแกรม: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()
