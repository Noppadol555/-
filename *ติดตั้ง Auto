# นำเข้าโมดูลที่จำเป็น
import os
import sys
import subprocess
import importlib
import importlib.util
import logging
import json
from typing import Dict, Optional, Set, List, Tuple
import ast
import re
import argparse
import platform
import ctypes
import tempfile
import shutil
from concurrent.futures import ThreadPoolExecutor, as_completed
from functools import lru_cache
from urllib.request import urlopen
from urllib.error import HTTPError, URLError
from packaging import version as pkg_version
from packaging.requirements import Requirement
import time
import psutil
from pathlib import Path

# นำเข้าโมดูลเสริม (ถ้ามี)
try:
    from tqdm import tqdm
except ImportError:
    tqdm = None

# ==================== การตั้งค่าเริ่มต้น ====================
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(),
        logging.FileHandler("auto_installer.log")
    ]
)
logger = logging.getLogger(__name__)

# ==================== ฟังก์ชันตรวจสอบสิทธิ์ admin ====================
def is_admin() -> bool:
    try:
        if platform.system() == "Windows":
            return ctypes.windll.shell32.IsUserAnAdmin() != 0
        else:
            return os.geteuid() == 0
    except AttributeError:
        return False

# ==================== ฟังก์ชันตรวจสอบทรัพยากรระบบ ====================
def check_system_resources() -> bool:
    """ตรวจสอบ disk space และ RAM"""
    try:
        disk = shutil.disk_usage(os.path.abspath("."))
        if disk.free < 2 * 1024 * 1024 * 1024:  # น้อยกว่า 2GB
            logger.error("พื้นที่ดิสก์เหลือน้อยเกินไป (<2GB)")
            return False
        mem = psutil.virtual_memory()
        if mem.available < 1 * 1024 * 1024 * 1024:  # น้อยกว่า 1GB
            logger.error("หน่วยความจำเหลือน้อยเกินไป (<1GB)")
            return False
        return True
    except Exception as e:
        logger.warning(f"ไม่สามารถตรวจสอบทรัพยากรระบบ: {e}")
        return True

# ==================== ฟังก์ชันตรวจสอบ Python Version ====================
def check_python_version(min_version: str = "3.8") -> bool:
    """ตรวจสอบว่า Python version เข้ากันได้"""
    current_version = f"{sys.version_info.major}.{sys.version_info.minor}"
    if pkg_version.parse(current_version) < pkg_version.parse(min_version):
        logger.error(f"ต้องการ Python >= {min_version}, พบ {current_version}")
        return False
    return True

# ==================== ฟังก์ชันตรวจสอบ Compiler ====================
def check_and_install_compiler() -> bool:
    """ตรวจสอบและติดตั้งเครื่องมือ build ถ้าจำเป็น"""
    system = platform.system()
    if system == "Linux":
        try:
            result = subprocess.run(["gcc", "--version"], capture_output=True, text=True)
            if result.returncode == 0:
                logger.info("พบ gcc สำหรับการ build source distribution")
                return True
            logger.info("กำลังติดตั้ง build-essential และ cmake")
            cmd = ["sudo", "apt-get", "install", "-y", "build-essential", "cmake"]
            subprocess.run(cmd, check=True, capture_output=True, text=True)
            return True
        except subprocess.CalledProcessError as e:
            logger.error(f"ไม่สามารถติดตั้ง build-essential และ cmake: {e}")
            return False
    elif system == "Darwin":
        try:
            result = subprocess.run(["clang", "--version"], capture_output=True, text=True)
            if result.returncode == 0:
                logger.info("พบ clang สำหรับการ build source distribution")
                return True
            logger.info("กำลังติดตั้ง Xcode Command Line Tools")
            cmd = ["xcode-select", "--install"]
            subprocess.run(cmd, check=True, capture_output=True, text=True)
            return True
        except subprocess.CalledProcessError as e:
            logger.error(f"ไม่สามารถติดตั้ง Xcode Command Line Tools: {e}")
            return False
    elif system == "Windows":
        try:
            result = subprocess.run(["cl"], capture_output=True, text=True)
            if result.returncode == 0:
                logger.info("พบ MSVC สำหรับการ build source distribution")
                return True
            logger.warning("กรุณาติดตั้ง Visual Studio Build Tools สำหรับ source builds")
            return False
        except Exception:
            logger.warning("ไม่พบ MSVC อาจต้องติดตั้ง Visual Studio Build Tools")
            return False
    return True

# ==================== ฟังก์ชันอัพเดท pip ====================
def self_update() -> bool:
    try:
        logger.info("กำลังอัพเดท pip เป็นเวอร์ชันล่าสุด")
        cmd = [sys.executable, "-m", "pip", "install", "--upgrade", "pip"]
        if not is_admin():
            cmd.append("--user")
        with tempfile.NamedTemporaryFile(mode='w+', delete=False, encoding='utf-8') as tmp_out, \
             tempfile.NamedTemporaryFile(mode='w+', delete=False, encoding='utf-8') as tmp_err:
            result = subprocess.run(cmd, stdout=tmp_out, stderr=tmp_err, text=True, check=True)
        logger.info("อัพเดท pip สำเร็จ")
        os.unlink(tmp_out.name)
        os.unlink(tmp_err.name)
        return True
    except subprocess.CalledProcessError as e:
        with open(tmp_err.name, 'r', encoding='utf-8') as f:
            error_output = f.read()
        logger.warning(f"ไม่สามารถอัพเดท pip: {error_output}")
        os.unlink(tmp_out.name)
        os.unlink(tmp_err.name)
        return False

# ==================== ฟังก์ชันจัดการการตั้งค่า ====================
def load_config(config_path: str = "install_config.json") -> Dict:
    config = {
        "max_workers": 4,
        "ignore_patterns": [".venv", "__pycache__", ".git", "tests", "docs"],
        "dry_run": False,
        "cache_ttl": 3600,
        "network_timeout": 10,
        "retry_attempts": 5,  # เพิ่ม retry เป็น 5
        "max_retries_network": 5,  # Retry สำหรับเครือข่าย
        "backoff_factor": 2  # Backoff สำหรับเครือข่าย
    }
    if os.path.exists(config_path):
        try:
            with open(config_path, "r", encoding="utf-8") as f:
                config.update(json.load(f))
            logger.info("โหลดไฟล์ตั้งค่าสำเร็จ")
        except Exception as e:
            logger.warning(f"ไม่สามารถโหลด {config_path}: {e}")
    return config

# ==================== ฟังก์ชันจัดการ PyPI Cache ====================
def load_pypi_cache(cache_file: str = "pypi_cache.json") -> Dict[str, Dict]:
    if os.path.exists(cache_file):
        try:
            with open(cache_file, "r", encoding="utf-8") as f:
                cache = json.load(f)
                # ตรวจสอบ TTL
                current_time = time.time()
                valid_cache = {}
                for pkg, data in cache.items():
                    if data.get("timestamp", 0) + 3600 > current_time:
                        valid_cache[pkg] = data
                return valid_cache
        except Exception as e:
            logger.warning(f"ไม่สามารถโหลดแคช PyPI: {e}")
    return {}

def save_pypi_cache(cache: Dict[str, Dict], cache_file: str = "pypi_cache.json") -> None:
    try:
        with open(cache_file, "w", encoding="utf-8") as f:
            json.dump(cache, f)
        logger.debug(f"บันทึกแคช PyPI ไปที่ {cache_file}")
    except Exception as e:
        logger.warning(f"ไม่สามารถบันทึกแคช PyPI: {e}")

# ==================== ฟังก์ชันดึงข้อมูลจาก PyPI ====================
@lru_cache(maxsize=128)
def get_pypi_info(pkg: str, timeout: int = 10, retry: int = 5, backoff_factor: float = 2) -> Optional[Dict]:
    pypi_cache = load_pypi_cache()
    if pkg in pypi_cache:
        logger.debug(f"ใช้ข้อมูลจากแคชสำหรับ {pkg}")
        return pypi_cache[pkg]

    for attempt in range(1, retry + 1):
        try:
            url = f"https://pypi.org/pypi/{pkg}/json"
            with urlopen(url, timeout=timeout) as response:
                if response.getcode() != 200:
                    raise HTTPError(url, response.getcode(), "HTTP Error", None, None)
                data = json.loads(response.read().decode('utf-8'))
                pypi_cache[pkg] = {
                    "version": data["info"]["version"],
                    "requires_dist": data["info"].get("requires_dist", []),
                    "releases": data["releases"],
                    "timestamp": time.time()
                }
                save_pypi_cache(pypi_cache)
                return pypi_cache[pkg]
        except (HTTPError, URLError, json.JSONDecodeError, Exception) as e:
            logger.warning(f"พยายามครั้งที่ {attempt} ล้มเหลวในการดึงข้อมูลของ {pkg}: {e}")
            if attempt < retry:
                time.sleep(backoff_factor * (2 ** (attempt - 1)))
    logger.warning(f"ไม่สามารถดึงข้อมูลของ {pkg} หลังจากลอง {retry} ครั้ง")
    return None

# ==================== ฟังก์ชันตรวจสอบ Wheel Compatibility ====================
def check_wheel_availability(pkg: str, version: str, python_version: str, platform_tags: List[str], timeout: int = 10, retry: int = 5) -> bool:
    pypi_cache = load_pypi_cache()
    cache_key = f"{pkg}:{version}"
    if cache_key in pypi_cache and "wheels" in pypi_cache[cache_key]:
        return pypi_cache[cache_key]["wheels"]

    for attempt in range(1, retry + 1):
        try:
            url = f"https://pypi.org/pypi/{pkg}/{version}/json"
            with urlopen(url, timeout=timeout) as response:
                if response.getcode() != 200:
                    raise HTTPError(url, response.getcode(), "HTTP Error", None, None)
                data = json.loads(response.read().decode('utf-8'))
                for release in data["releases"].get(version, []):
                    if release["packagetype"] == "bdist_wheel":
                        for tag in platform_tags:
                            if tag in release["filename"]:
                                pypi_cache[cache_key] = {"wheels": True}
                                save_pypi_cache(pypi_cache)
                                return True
                pypi_cache[cache_key] = {"wheels": False}
                save_pypi_cache(pypi_cache)
                return False
        except (HTTPError, URLError, json.JSONDecodeError, Exception) as e:
            logger.warning(f"พยายามครั้งที่ {attempt} ล้มเหลวในการตรวจสอบ wheel สำหรับ {pkg}=={version}: {e}")
            if attempt < retry:
                time.sleep(2 * (2 ** (attempt - 1)))
    logger.warning(f"ไม่สามารถตรวจสอบ wheel สำหรับ {pkg}=={version}")
    return False

# ==================== ฟังก์ชันตรวจสอบและแก้ไขความขัดแย้ง ====================
def resolve_conflicts(requirements: Dict[str, str], installed_libs: Dict[str, str]) -> Dict[str, str]:
    resolved = requirements.copy()
    for pkg in requirements:
        pypi_info = get_pypi_info(pkg)
        if not pypi_info:
            continue
        for dep in pypi_info.get("requires_dist", []):
            try:
                req = Requirement(dep)
                dep_name = req.name.replace("-", "_").lower()
                if dep_name in resolved:
                    dep_version = resolved[dep_name]
                    if not req.specifier.contains(dep_version):
                        logger.warning(f"ความขัดแย้ง: {pkg} ต้องการ {dep}, แต่มี {dep_name}=={dep_version}")
                        # ลองเวอร์ชันล่าสุด
                        latest_version = get_pypi_info(dep_name).get("version") if get_pypi_info(dep_name) else None
                        if latest_version and req.specifier.contains(latest_version):
                            resolved[dep_name] = latest_version
                            logger.info(f"แก้ไขโดยใช้ {dep_name}=={latest_version}")
                        else:
                            # ลองเวอร์ชันเก่ากว่า
                            releases = get_pypi_info(dep_name).get("releases", {})
                            for ver in sorted(releases.keys(), key=lambda x: pkg_version.parse(x), reverse=True):
                                if req.specifier.contains(ver):
                                    resolved[dep_name] = ver
                                    logger.info(f"แก้ไขโดยใช้ {dep_name}=={ver}")
                                    break
                            else:
                                logger.warning(f"ไม่สามารถแก้ไขความขัดแย้งสำหรับ {dep_name}")
            except Exception as e:
                logger.debug(f"ข้าม dependency {dep}: {e}")
    return resolved

# ==================== ฟังก์ชันเลือกเวอร์ชันที่เหมาะสม ====================
def select_compatible_version(pkg: str, device_type: str, cuda_version: Optional[str], python_version: str, platform_tags: List[str], installed_libs: Dict[str, str]) -> Optional[str]:
    pypi_info = get_pypi_info(pkg)
    if not pypi_info:
        logger.warning(f"ไม่สามารถหาเวอร์ชันล่าสุดสำหรับ {pkg}")
        return None
    latest_version = pypi_info["version"]

    if not check_wheel_availability(pkg, latest_version, python_version, platform_tags):
        logger.warning(f"ไม่มี wheel สำหรับ {pkg}=={latest_version} บนแพลตฟอร์มนี้")
        if not check_and_install_compiler():
            logger.error(f"ไม่สามารถ build {pkg} จาก source เนื่องจากไม่มี compiler")
            return None
        # ลองเวอร์ชันเก่ากว่าที่มี wheel
        releases = pypi_info.get("releases", {})
        for ver in sorted(releases.keys(), key=lambda x: pkg_version.parse(x), reverse=True):
            if check_wheel_availability(pkg, ver, python_version, platform_tags):
                logger.info(f"เลือก {pkg}=={ver} ที่มี wheel")
                return ver

    if pkg == "torch":
        if device_type == "cuda" and cuda_version:
            return latest_version
        elif device_type == "mps" and pkg_version and pkg_version.parse(latest_version) >= pkg_version.parse("1.12.0"):
            return latest_version
        else:
            return latest_version
    elif pkg == "torch_geometric":
        torch_version = installed_libs.get("torch", get_pypi_info("torch").get("version"))
        return latest_version
    elif pkg in ["torch_scatter", "torch_sparse", "torch_cluster", "torch_spline_conv"]:
        return latest_version
    elif pkg == "darts":
        if pkg_version and pkg_version.parse(latest_version) > pkg_version.parse("0.30.0"):
            return "0.30.0"  # ค่าเริ่มต้นที่รู้ว่าสเถียร
        return latest_version
    elif pkg == "keyboard":
        if platform.system() == "Linux" and not is_admin():
            logger.warning("keyboard อาจต้องติดตั้งด้วย --user หรือ sudo")
        return latest_version
    else:
        return latest_version

# ==================== ฟังก์ชันดึง Dependencies อัตโนมัติ ====================
def get_dependencies(pkg: str, visited: Set[str] = None) -> Dict[str, str]:
    if visited is None:
        visited = set()
    if pkg in visited:
        return {}
    visited.add(pkg)

    dependencies = {}
    pypi_info = get_pypi_info(pkg)
    if not pypi_info:
        return dependencies

    for dep in pypi_info.get("requires_dist", []):
        try:
            req = Requirement(dep)
            dep_name = req.name.replace("-", "_").lower()
            if dep_name in {"python", "setuptools", "wheel"}:
                continue
            dep_version = get_pypi_info(dep_name).get("version") if get_pypi_info(dep_name) else None
            if dep_version and req.specifier.contains(dep_version):
                dependencies[dep_name] = dep_version
                sub_deps = get_dependencies(dep_name, visited)
                dependencies.update(sub_deps)
        except Exception as e:
            logger.debug(f"ข้าม dependency {dep}: {e}")
    return dependencies

# ==================== ฟังก์ชันสร้าง requirements.txt ====================
def generate_requirements(project_libs: Set[str], device_type: str, cuda_version: Optional[str], python_version: str, platform_tags: List[str], installed_libs: Dict[str, str], requirements_file: str = "requirements.txt") -> bool:
    try:
        requirements = {}
        for lib in sorted(project_libs):
            version = select_compatible_version(lib, device_type, cuda_version, python_version, platform_tags, installed_libs)
            if version:
                requirements[lib] = version
                deps = get_dependencies(lib)
                requirements.update(deps)
            else:
                logger.warning(f"ข้าม {lib} เนื่องจากไม่พบเวอร์ชัน")
                continue

        requirements = resolve_conflicts(requirements, installed_libs)

        with open(requirements_file, "w", encoding="utf-8") as f:
            f.write("# requirements.txt สร้างโดยอัตโนมัติ\n")
            for pkg, ver in sorted(requirements.items()):
                f.write(f"{pkg}=={ver}\n")
        logger.info(f"สร้าง {requirements_file} สำเร็จ มี {len(requirements)} ไลบรารี")
        return True
    except Exception as e:
        logger.error(f"ไม่สามารถสร้าง {requirements_file}: {e}")
        return False

# ==================== ฟังก์ชันติดตั้งแพ็กเกจ ====================
def install_package(pkg: str, version: Optional[str] = None, dry_run: bool = False, retry: int = 5, index_url: Optional[str] = None) -> bool:
    try:
        spec = importlib.util.find_spec(pkg)
        if spec:
            module = importlib.import_module(pkg)
            installed_version = getattr(module, '__version__', 'unknown')
            if version and installed_version == version:
                logger.info(f"{pkg} เวอร์ชัน {installed_version} ติดตั้งแล้ว")
                return True
            elif not version:
                logger.info(f"{pkg} (เวอร์ชัน {installed_version}) ติดตั้งแล้ว")
                return True
    except ImportError:
        pass

    if dry_run:
        logger.info(f"[Dry Run] จะติดตั้ง {pkg} {version or '(ล่าสุด)'}")
        return True

    pkg_spec = f"{pkg}=={version}" if version else pkg
    scopes = ["--user", ""] if pkg == "keyboard" or not is_admin() else [""]
    for scope in scopes:
        for attempt in range(1, retry + 1):
            logger.info(f"ติดตั้ง {pkg_spec} {'ใน user scope' if scope else ''} (พยายามครั้งที่ {attempt}/{retry})")
            try:
                with tempfile.NamedTemporaryFile(mode='w+', delete=False, encoding='utf-8') as tmp_out, \
                     tempfile.NamedTemporaryFile(mode='w+', delete=False, encoding='utf-8') as tmp_err:
                    cmd = [sys.executable, "-m", "pip", "install"]
                    if scope:
                        cmd.append(scope)
                    if index_url:
                        cmd.extend(["--index-url", index_url])
                    cmd.append(pkg_spec)
                    result = subprocess.run(cmd, stdout=tmp_out, stderr=tmp_err, text=True, check=True)
                    logger.info(f"ติดตั้ง {pkg_spec} {'ใน user scope' if scope else ''} สำเร็จ")
                    os.unlink(tmp_out.name)
                    os.unlink(tmp_err.name)
                    return True
            except subprocess.CalledProcessError as e:
                with open(tmp_err.name, 'r', encoding='utf-8') as f:
                    error_output = f.read()
                logger.warning(f"พยายามครั้งที่ {attempt} ล้มเหลวในการติดตั้ง {pkg_spec} {'ใน user scope' if scope else ''}: {error_output}")
                os.unlink(tmp_out.name)
                os.unlink(tmp_err.name)
                if attempt < retry:
                    time.sleep(2 * (2 ** (attempt - 1)))
    logger.error(f"ไม่สามารถติดตั้ง {pkg_spec} หลังจากลอง {retry} ครั้งในทุก scope")
    return False

# ==================== ฟังก์ชันตรวจสอบและติดตั้งไลบรารี ====================
def ensure_library(lib: str, version: Optional[str] = None, dry_run: bool = False, retry: int = 5, index_url: Optional[str] = None) -> bool:
    try:
        importlib.import_module(lib)
        logger.info(f"{lib} พร้อมใช้งานแล้ว")
        return True
    except ImportError:
        return install_package(lib, version, dry_run, retry, index_url)

# ==================== ฟังก์ชันสแกน imports จากไฟล์ Python ====================
def extract_imports(file_path: str) -> Set[str]:
    libraries: Set[str] = set()
    try:
        with open(file_path, "r", encoding="utf-8") as f:
            tree = ast.parse(f.read(), filename=file_path)
            for node in ast.walk(tree):
                if isinstance(node, ast.Import):
                    for name in node.names:
                        lib_name = name.name.split('.')[0]
                        libraries.add(lib_name)
                elif isinstance(node, ast.ImportFrom):
                    if node.module:
                        lib_name = node.module.split('.')[0]
                        libraries.add(lib_name)
        logger.debug(f"วิเคราะห์ {file_path}: พบ {len(libraries)} ไลบรารี")
        return libraries
    except Exception as e:
        logger.error(f"ไม่สามารถวิเคราะห์ {file_path}: {e}")
        return set()

# ==================== ฟังก์ชันสแกนโปรเจ็กต์ ====================
def scan_project_for_libraries(project_dir: str, ignore_patterns: List[str]) -> Set[str]:
    all_libraries: Set[str] = set()
    project_path = Path(project_dir)
    ignore_regex = [re.compile(pattern) for pattern in ignore_patterns]

    for file_path in project_path.rglob("*.py"):
        if str(file_path) == str(Path(sys.argv[0]).resolve()):
            continue
        if any(any(regex.search(str(part)) for regex in ignore_regex) for part in file_path.parts):
            continue
        libraries = extract_imports(str(file_path))
        all_libraries.update(libraries)

    logger.info(f"พบ {len(all_libraries)} ไลบรารีในโปรเจ็กต์")
    return all_libraries

# ==================== ฟังก์ชันตรวจจับฮาร์ดแวร์ ====================
def detect_hardware() -> Tuple[str, Optional[str]]:
    try:
        output = subprocess.check_output("nvidia-smi", shell=True, text=True)
        match = re.search(r"CUDA Version:\s*(\d+\.\d+)", output)
        if match:
            cuda_version = match.group(1)
            short_version = "".join(cuda_version.split("."))
            logger.info(f"ตรวจพบ CUDA เวอร์ชัน: {cuda_version}")
            return "cuda", f"cu{short_version}"
    except Exception:
        pass
    try:
        if platform.system() == "Darwin" and subprocess.run("sysctl -n machdep.cpu.brand_string", shell=True, capture_output=True, text=True).returncode == 0:
            logger.info("ตรวจพบ Apple Silicon (MPS)")
            return "mps", None
    except Exception:
        pass
    logger.info("ไม่พบ CUDA หรือ MPS ใช้ CPU")
    return "cpu", None

# ==================== ฟังก์ชันตรวจสอบความเข้ากันได้ ====================
def check_compatibility(lib: str, version: str, installed_libs: Dict[str, str]) -> bool:
    pypi_info = get_pypi_info(lib)
    if not pypi_info:
        logger.warning(f"ไม่สามารถตรวจสอบความเข้ากันได้สำหรับ {lib}")
        return True

    for dep in pypi_info.get("requires_dist", []):
        try:
            req = Requirement(dep)
            dep_name = req.name.replace("-", "_").lower()
            if dep_name in installed_libs:
                installed_version = installed_libs[dep_name]
                if not req.specifier.contains(installed_version):
                    logger.warning(f"ความขัดแย้ง: {lib}=={version} ต้องการ {dep}, แต่ติดตั้ง {dep_name}=={installed_version}")
                    return False
        except Exception as e:
            logger.debug(f"ข้ามการตรวจสอบ dependency {dep}: {e}")
    return True

# ==================== ฟังก์ชันติดตั้ง PyTorch และ Torch-Geometric ====================
def install_torch_and_geometric(dry_run: bool = False, retry: int = 5, python_version: str = None, platform_tags: List[str] = None) -> bool:
    cuda_mapping = {
        "10.2": "cu102", "11.0": "cu110", "11.1": "cu111", "11.2": "cu112",
        "11.3": "cu113", "11.4": "cu114", "11.5": "cu115", "11.6": "cu116",
        "11.7": "cu117", "11.8": "cu118", "12.0": "cu120", "12.1": "cu121",
        "12.2": "cu122", "12.3": "cu123", "12.4": "cu124", "12.5": "cu125",
        "12.6": "cu126", "12.7": "cu127", "12.8": "cu128"
    }
    try:
        import torch
        torch_version = torch.__version__.split("+")[0]
        logger.info(f"PyTorch {torch_version} ติดตั้งแล้ว")
        device_type, cuda_short = detect_hardware()
    except ImportError:
        if dry_run:
            logger.info("[Dry Run] จะติดตั้ง PyTorch")
            return True
        device_type, cuda_short = detect_hardware()
        index_url = None
        if device_type == "cuda" and cuda_short in cuda_mapping.values():
            index_url = f"https://download.pytorch.org/whl/{cuda_short}"
        elif device_type == "cuda":
            cuda_version = cuda_short[2:] if cuda_short else None
            if cuda_version:
                cuda_version_float = float(".".join(list(cuda_version)[:2]))
                supported_versions = sorted([float(v) for v in cuda_mapping.keys()])
                closest_version = min(supported_versions, key=lambda x: abs(x - cuda_version_float))
                cuda_short = cuda_mapping[str(closest_version)]
                index_url = f"https://download.pytorch.org/whl/{cuda_short}"
                logger.info(f"เลือก CUDA เวอร์ชันใกล้เคียงที่สุด: {closest_version}")
            else:
                cuda_short = "cpu"
        elif device_type == "mps":
            index_url = None
        else:
            cuda_short = "cpu"

        pkg_spec = "torch torchvision torchaudio"
        for attempt in range(1, retry + 1):
            logger.info(f"ติดตั้ง PyTorch (พยายามครั้งที่ {attempt}/{retry})")
            try:
                with tempfile.NamedTemporaryFile(mode='w+', delete=False, encoding='utf-8') as tmp_out, \
                     tempfile.NamedTemporaryFile(mode='w+', delete=False, encoding='utf-8') as tmp_err:
                    cmd = [sys.executable, "-m", "pip", "install"] + pkg_spec.split()
                    if index_url:
                        cmd.extend(["--index-url", index_url])
                    result = subprocess.run(cmd, stdout=tmp_out, stderr=tmp_err, text=True, check=True)
                    logger.info(f"ติดตั้ง PyTorch สำเร็จ")
                    os.unlink(tmp_out.name)
                    os.unlink(tmp_err.name)
                    import torch
                    torch_version = torch.__version__.split("+")[0]
                    break
            except subprocess.CalledProcessError as e:
                with open(tmp_err.name, 'r', encoding='utf-8') as f:
                    error_output = f.read()
                logger.warning(f"พยายามครั้งที่ {attempt} ล้มเหลวในการติดตั้ง PyTorch: {error_output}")
                os.unlink(tmp_out.name)
                os.unlink(tmp_err.name)
                if attempt < retry:
                    time.sleep(2 * (2 ** (attempt - 1)))
        else:
            logger.error(f"ไม่สามารถติดตั้ง PyTorch หลังจากลอง {retry} ครั้ง")
            return False

    logger.info(f"ตรวจพบอุปกรณ์: {device_type.upper()}")

    # ติดตั้ง Torch-Geometric และ dependencies
    required_versions = read_requirements()
    pyg_version = required_versions.get("torch_geometric") or get_pypi_info("torch_geometric").get("version")
    pyg_url = f"https://data.pyg.org/whl/torch-{torch_version}+{cuda_short or 'cpu' if device_type != 'mps' else 'cpu'}"
    pyg_libs = [
        "torch_scatter", "torch_sparse", "torch_cluster",
        "torch_spline_conv", "torch_geometric"
    ]
    for lib in pyg_libs:
        if dry_run:
            logger.info(f"[Dry Run] จะติดตั้ง {lib} {required_versions.get(lib) or '(ล่าสุด)'} สำหรับ {device_type}")
            continue
        version = required_versions.get(lib) or get_pypi_info(lib).get("version")
        if not check_wheel_availability(lib, version, python_version, platform_tags):
            logger.warning(f"ไม่มี wheel สำหรับ {lib}=={version} อาจต้อง build จาก source")
            if not check_and_install_compiler():
                logger.error(f"ไม่สามารถติดตั้ง {lib} เนื่องจากไม่มี compiler")
                return False
        for attempt in range(1, retry + 1):
            try:
                ensure_library(lib, version, dry_run, retry=1, index_url=pyg_url)
                logger.info(f"ติดตั้ง {lib} สำหรับ {device_type} สำเร็จ")
                break
            except subprocess.CalledProcessError as e:
                logger.warning(f"พยายามครั้งที่ {attempt} ล้มเหลวในการติดตั้ง {lib}: {e}")
                if attempt < retry:
                    time.sleep(2 * (2 ** (attempt - 1)))
        else:
            logger.error(f"ไม่สามารถติดตั้ง {lib} หลังจากลอง {retry} ครั้ง")
            return False
    return True

# ==================== ฟังก์ชันอ่าน requirements.txt ====================
def read_requirements(requirements_file: str = "requirements.txt") -> Dict[str, str]:
    requirements: Dict[str, str] = {}
    if os.path.exists(requirements_file):
        try:
            with open(requirements_file, "r", encoding="utf-8") as f:
                for line in f:
                    line = line.strip()
                    if line and "==" in line and not line.startswith("#"):
                        pkg, ver = line.split("==")
                        requirements[pkg.strip()] = ver.strip()
            logger.info("อ่าน requirements.txt สำเร็จ")
        except Exception as e:
            logger.warning(f"ไม่สามารถอ่าน {requirements_file}: {e}")
    return requirements

# ==================== ฟังก์ชันโค้ดโปรเจ็กต์หลัก ====================
def main_project_code():
    logger.info("เริ่มรันโค้ดโปรเจ็กต์หลัก")
    try:
        import ccxt
        import tenacity
        import torch
        import numpy as np
        import pandas as pd
        import matplotlib.pyplot as plt
        from sklearn.linear_model import LinearRegression
        import darts
        import ta

        logger.info("ทดสอบการใช้ไลบรารี")
        logger.info(f"CCXT version: {ccxt.__version__}")
        logger.info(f"Tenacity version: {tenacity.__version__}")
        logger.info(f"PyTorch version: {torch.__version__}")
        logger.info(f"Darts version: {darts.__version__}")
        logger.info(f"TA version: {ta.__version__}")

        df = pd.DataFrame({"x": [1, 2, 3], "y": [2, 4, 6]})
        logger.info(f"Pandas DataFrame:\n{df}")

        array = np.array([1, 2, 3])
        logger.info(f"NumPy array: {array}")

        tensor = torch.tensor([1, 2, 3])
        logger.info(f"PyTorch tensor: {tensor}")

        model = LinearRegression()
        model.fit(df[["x"]], df["y"])
        logger.info(f"Scikit-learn model coefficient: {model.coef_}")

        plt.plot(df["x"], df["y"], 'o')
        plt.title("ตัวอย่างกราฟ")
        plt.xlabel("X")
        plt.ylabel("Y")
        plt.savefig("example_plot.png")
        plt.close()
        logger.info("บันทึกกราฟตัวอย่างสำเร็จ")

        print("โค้ดโปรเจ็กต์หลักทำงานสำเร็จ")
    except Exception as e:
        logger.error(f"เกิดข้อผิดพลาดในโค้ดโปรเจ็กต์หลัก: {e}")
        raise

# ==================== ฟังก์ชันติดตั้งทุกไลบรารีและรันโปรเจ็กต์ ====================
def auto_install_all(project_dir: str = ".", dry_run: bool = False, max_workers: int = 4, skip_install: bool = False, generate_requirements: bool = True) -> None:
    if not check_system_resources():
        logger.error("ทรัพยากรระบบไม่เพียงพอ กรุณาตรวจสอบ disk space และ RAM")
        sys.exit(1)

    if not check_python_version("3.8"):
        logger.error("Python version ไม่เข้ากันได้ ต้องการ >=3.8")
        sys.exit(1)

    if not skip_install and not dry_run:
        self_update()

    config = load_config()
    dry_run = dry_run or config["dry_run"]
    max_workers = max_workers or config["max_workers"]
    ignore_patterns = config["ignore_patterns"]
    timeout = config["network_timeout"]
    retry = config["retry_attempts"]
    backoff_factor = config["backoff_factor"]

    # ตรวจสอบ Python version และ platform tags
    python_version = f"cp{sys.version_info.major}{sys.version_info.minor}"
    platform_tags = [platform.system().lower(), platform.machine()]
    if platform.system() == "Darwin" and platform.machine() == "arm64":
        platform_tags.append("macosx_11_0_arm64")

    # ติดตั้ง packaging ถ้ายังไม่มี
    if not pkg_version and not dry_run and not skip_install:
        ensure_library("packaging")
        from packaging import version as pkg_version
        from packaging.requirements import Requirement

    if skip_install and not dry_run:
        logger.info("ข้ามการติดตั้งไลบรารี ไปรันโค้ดโปรเจ็กต์หลัก")
        main_project_code()
        return

    # สแกนโปรเจ็กต์เพื่อหาไลบรารี
    project_libs = scan_project_for_libraries(project_dir, ignore_patterns)
    base_libs = {
        "ccxt", "tenacity", "torch", "numpy", "pandas", "scikit-learn",
        "bayesian-optimization", "matplotlib", "seaborn", "darts",
        "torch-geometric", "psutil", "gym", "openpyxl", "keyboard", "ta"
    }
    standard_libs = {
        "sys", "os", "logging", "typing", "subprocess", "importlib", "ast",
        "json", "argparse", "urllib", "re", "functools", "concurrent", "pathlib",
        "platform", "ctypes", "datetime", "asyncio", "sqlite3", "tempfile"
    }
    all_libs = base_libs.union(project_libs) - standard_libs

    # ตรวจจับฮาร์ดแวร์
    device_type, cuda_version = detect_hardware()
    installed_libs: Dict[str, str] = {}

    # สร้าง requirements.txt ถ้าต้องการ
    if generate_requirements and not dry_run and not os.path.exists("requirements.txt"):
        logger.info("กำลังสร้าง requirements.txt อัตโนมัติ")
        generate_requirements(all_libs, device_type, cuda_version, python_version, platform_tags, installed_libs)

    required_versions = read_requirements()
    failed_libs: List[str] = []

    def install_with_progress(lib: str) -> bool:
        index_url = None
        if lib in ["torch_scatter", "torch_sparse", "torch_cluster", "torch_spline_conv", "torch_geometric"]:
            index_url = f"https://data.pyg.org/whl/torch-{installed_libs.get('torch', '2.4.1')}+{cuda_version or 'cpu' if device_type != 'mps' else 'cpu'}"
        version = required_versions.get(lib) or select_compatible_version(lib, device_type, cuda_version, python_version, platform_tags, installed_libs)
        if not version:
            logger.error(f"ไม่สามารถหาเวอร์ชันของ {lib}")
            return False
        if check_compatibility(lib, version, installed_libs):
            success = ensure_library(lib, version, dry_run, retry, index_url)
            if success and not dry_run:
                installed_libs[lib] = version
            return success
        failed_libs.append(lib)
        return False

    logger.info(f"เริ่มติดตั้ง {len(all_libs)} ไลบรารี (Dry Run: {dry_run})")
    if not dry_run:
        with ThreadPoolExecutor(max_workers=max_workers) as executor:
            futures = {executor.submit(install_with_progress, lib): lib for lib in all_libs}
            progress = tqdm(futures, total=len(futures), desc="กำลังติดตั้ง", disable=not tqdm)
            for future in as_completed(futures):
                lib = futures[future]
                try:
                    future.result()
                except Exception as e:
                    logger.error(f"เกิดข้อผิดพลาดในการติดตั้ง {lib}: {e}")
                    failed_libs.append(lib)
                if progress:
                    progress.update(1)
            if progress:
                progress.close()

    if "torch" in all_libs or "torch_geometric" in all_libs:
        if not install_torch_and_geometric(dry_run, retry, python_version, platform_tags):
            failed_libs.append("torch/torch_geometric")

    if failed_libs:
        logger.warning(f"ไม่สามารถติดตั้ง: {', '.join(failed_libs)}")
        logger.info("กรุณาตรวจสอบ auto_installer.log และติดตั้งไลบรารีที่ล้มเหลวด้วยตนเอง")
    else:
        logger.info("ติดตั้งไลบรารีทั้งหมดสำเร็จ")

    # รันโค้ดโปรเจ็กต์หลัก
    if not dry_run:
        try:
            main_project_code()
            logger.info("รันโค้ดโปรเจ็กต์หลักสำเร็จ")
        except Exception as e:
            logger.error(f"รันโค้ดโปรเจ็กต์หลักล้มเหลว: {e}")

# ==================== ฟังก์ชันหลัก ====================
def main():
    parser = argparse.ArgumentParser(description="ติดตั้งไลบรารี Python และรันโค้ดโปรเจ็กต์โดยอัตโนมัติ")
    parser.add_argument("--project-dir", default=".", help="โฟลเดอร์โปรเจ็กต์ที่ต้องการสแกน")
    parser.add_argument("--dry-run", action="store_true", help="จำลองการติดตั้งโดยไม่ดำเนินการจริง")
    parser.add_argument("--max-workers", type=int, default=4, help="จำนวน workers สูงสุดสำหรับการติดตั้งแบบขนาน")
    parser.add_argument("--skip-install", action="store_true", help="ข้ามการติดตั้งไลบรารีและรันโค้ดโปรเจ็กต์ทันที")
    parser.add_argument("--no-generate-requirements", action="store_true", help="ไม่สร้าง requirements.txt อัตโนมัติ")
    args = parser.parse_args()

    try:
        auto_install_all(
            args.project_dir,
            args.dry_run,
            args.max_workers,
            args.skip_install,
            generate_requirements=not args.no_generate_requirements
        )
    except Exception as e:
        logger.error(f"เกิดข้อผิดพลาดในโปรแกรม: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()
