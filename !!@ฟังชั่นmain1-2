# ===============================================
# main.py â€” à¸£à¸§à¸¡à¸—à¸¸à¸à¸„à¸¥à¸²à¸ªà¹à¸¥à¸°à¸£à¸±à¸™à¸£à¸°à¸šà¸šà¹€à¸—à¸£à¸”à¸«à¸¥à¸±à¸ (à¹€à¸Šà¸·à¹ˆà¸­à¸¡ WebSocket + APIManager)
# ===============================================

from config import GlobalConfig
import asyncio, logging, traceback, os, keyboard
import numpy as np
import pandas as pd
import torch
import time


# ==============================
# ðŸ”„ à¸Ÿà¸±à¸‡à¸à¹Œà¸Šà¸±à¸™à¸‹à¸´à¸‡à¸„à¹Œ GlobalConfig à¹à¸šà¸šà¹€à¸£à¸µà¸¢à¸¥à¹„à¸—à¸¡à¹Œ
# ==============================
async def sync_global_config_loop(interval=15):
    """à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¹à¸¥à¸°à¸­à¸±à¸›à¹€à¸”à¸•à¸„à¹ˆà¸²à¸ˆà¸²à¸ GlobalConfig à¸—à¸¸à¸à¹† interval à¸§à¸´à¸™à¸²à¸—à¸µ"""
    prev_config = GlobalConfig.CONFIG.copy()
    while True:
        try:
            # à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¸£à¸°à¸”à¸±à¸š log
            current_level = getattr(logging, GlobalConfig.get('log_level', 'INFO').upper(), logging.INFO)
            if logging.getLogger().level != current_level:
                logging.getLogger().setLevel(current_level)
                logging.info(f"ðŸ› ï¸ à¸­à¸±à¸›à¹€à¸”à¸• log level à¹€à¸›à¹‡à¸™ {GlobalConfig.get('log_level')}")

            # à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸š trade log file
            trade_log_file = GlobalConfig.get('trade_log_file', 'trade_log.xlsx')
            if not os.path.exists(trade_log_file):
                pd.DataFrame(columns=['Time', 'Symbol', 'Action', 'Price', 'PnL']).to_excel(trade_log_file, index=False)
                logging.info(f"ðŸ“˜ à¸ªà¸£à¹‰à¸²à¸‡à¹„à¸Ÿà¸¥à¹Œà¸šà¸±à¸™à¸—à¸¶à¸à¹€à¸—à¸£à¸”à¹ƒà¸«à¸¡à¹ˆ: {trade_log_file}")

            # à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¸„à¹ˆà¸²à¸—à¸µà¹ˆà¹€à¸›à¸¥à¸µà¹ˆà¸¢à¸™à¸ˆà¸²à¸à¸„à¸£à¸±à¹‰à¸‡à¸à¹ˆà¸­à¸™
            for k, v in GlobalConfig.CONFIG.items():
                if prev_config.get(k) != v:
                    logging.info(f"ðŸ” à¸„à¹ˆà¸² CONFIG '{k}' à¹€à¸›à¸¥à¸µà¹ˆà¸¢à¸™à¸ˆà¸²à¸ {prev_config.get(k)} â†’ {v}")
                    prev_config[k] = v

        except Exception as e:
            logging.warning(f"âš ï¸ GlobalConfig Sync Error: {e}")

        await asyncio.sleep(interval)


# ==============================
# ðŸŸ¢ à¸Ÿà¸±à¸‡à¸à¹Œà¸Šà¸±à¸™à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¸ªà¸–à¸²à¸™à¸°à¸£à¸°à¸šà¸šà¹à¸šà¸šà¹€à¸£à¸µà¸¢à¸¥à¹„à¸—à¸¡à¹Œ
# ==============================
async def status_monitor_loop(ws_manager, api_manager, interval=10):
    while True:
        try:
            ws_ok = "âœ…" if ws_manager.is_running() else "âŒ"
            api_ok = "âœ…" if api_manager and getattr(api_manager, "exchange", None) else "âŒ"
            delay = round(time.time() - getattr(ws_manager, "last_data_time", time.time()), 1)
            symbol_count = len(getattr(ws_manager, "data", {}))
            balance = getattr(ws_manager, "balance_data", {}).get("free", 0.0)
            logging.info(
                f"â³ STATUS | WebSocket={ws_ok} | API={api_ok} | Symbols={symbol_count} | Delay={delay}s | Balance={balance:.2f} USDT"
            )
        except Exception as e:
            logging.warning(f"âš ï¸ à¸ªà¸–à¸²à¸™à¸°à¸£à¸°à¸šà¸šà¹„à¸¡à¹ˆà¸ªà¸¡à¸šà¸¹à¸£à¸“à¹Œ: {e}")
        await asyncio.sleep(interval)


# ==============================
# ðŸ§  à¸Ÿà¸±à¸‡à¸à¹Œà¸Šà¸±à¸™ Auto Trailing Stop/Take Profit (à¸ˆà¸³à¸¥à¸­à¸‡)
# ==============================
async def auto_update_trailing(strategy, current_price):
    try:
        trailing_callback = GlobalConfig.get('trailing_callback_rate', 0.005)
        if not strategy.get("trailing_stop") or not strategy.get("trailing_take_profit"):
            return strategy

        action = strategy.get("action")
        entry = strategy.get("entry_price", current_price)
        stop_loss = strategy.get("stop_loss")
        take_profit = strategy.get("take_profit")

        if action in ["LONG", "BUY"]:
            if current_price > entry * (1 + trailing_callback):
                new_sl = max(stop_loss, current_price * (1 - trailing_callback))
                new_tp = max(take_profit, current_price * (1 + trailing_callback))
                strategy["stop_loss"], strategy["take_profit"] = new_sl, new_tp
                mode = "ðŸ§ª à¹€à¸—à¸£à¸”à¸ˆà¸³à¸¥à¸­à¸‡" if GlobalConfig.get("dry_run") else "ðŸ’° à¹€à¸—à¸£à¸”à¸ˆà¸£à¸´à¸‡"
                logging.info(f"{mode} | ðŸŸ¢ Trailing LONG | {strategy['symbol']} | SL={new_sl:.4f} | TP={new_tp:.4f}")

        elif action in ["SHORT", "SELL"]:
            if current_price < entry * (1 - trailing_callback):
                new_sl = min(stop_loss, current_price * (1 + trailing_callback))
                new_tp = min(take_profit, current_price * (1 - trailing_callback))
                strategy["stop_loss"], strategy["take_profit"] = new_sl, new_tp
                mode = "ðŸ§ª à¹€à¸—à¸£à¸”à¸ˆà¸³à¸¥à¸­à¸‡" if GlobalConfig.get("dry_run") else "ðŸ’° à¹€à¸—à¸£à¸”à¸ˆà¸£à¸´à¸‡"
                logging.info(f"{mode} | ðŸ”´ Trailing SHORT | {strategy['symbol']} | SL={new_sl:.4f} | TP={new_tp:.4f}")

    except Exception as e:
        logging.warning(f"âš ï¸ Auto Trailing Error: {e}")

    return strategy


# ==============================
# ðŸ“¡ à¸Ÿà¸±à¸‡à¸à¹Œà¸Šà¸±à¸™ Real Trailing Sync à¸ªà¸³à¸«à¸£à¸±à¸šà¹€à¸—à¸£à¸”à¸ˆà¸£à¸´à¸‡
# ==============================
async def sync_real_trailing_orders(ws_manager, api_manager, trader, interval=30):
    while True:
        try:
            trailing_callback = GlobalConfig.get('trailing_callback_rate', 0.005)
            if not getattr(trader, "positions", {}):
                await asyncio.sleep(interval)
                continue

            for symbol, pos in trader.positions.items():
                side = pos.get("side", "FLAT")
                entry_price = pos.get("entry_price", 0)
                if entry_price <= 0:
                    continue

                current_price = ws_manager.data.get(symbol, {}).get("close")
                if not current_price:
                    continue

                if side == "LONG" and current_price > entry_price * (1 + trailing_callback):
                    new_sl = current_price * (1 - trailing_callback)
                    new_tp = current_price * (1 + trailing_callback)
                    await api_manager.update_stop_take_profit(symbol, new_sl, new_tp)
                    logging.info(f"ðŸ’° à¹€à¸—à¸£à¸”à¸ˆà¸£à¸´à¸‡ | ðŸŸ¢ Trailing LONG | {symbol} | SL={new_sl:.4f} | TP={new_tp:.4f}")

                elif side == "SHORT" and current_price < entry_price * (1 - trailing_callback):
                    new_sl = current_price * (1 + trailing_callback)
                    new_tp = current_price * (1 - trailing_callback)
                    await api_manager.update_stop_take_profit(symbol, new_sl, new_tp)
                    logging.info(f"ðŸ’° à¹€à¸—à¸£à¸”à¸ˆà¸£à¸´à¸‡ | ðŸ”´ Trailing SHORT | {symbol} | SL={new_sl:.4f} | TP={new_tp:.4f}")

        except Exception as e:
            logging.warning(f"âš ï¸ Real Trailing Sync Error: {e}")

        await asyncio.sleep(interval)


# ===============================================
# ðŸ§© à¸Ÿà¸±à¸‡à¸à¹Œà¸Šà¸±à¸™ control_loop â€” à¸«à¸¢à¸¸à¸”à¸£à¸°à¸šà¸šà¹€à¸¡à¸·à¹ˆà¸­à¸à¸” 'q'
# ===============================================
async def control_loop(ws_manager, api_manager, risk_guardian):
    """à¸•à¸£à¸§à¸ˆà¸ªà¸­à¸šà¸à¸²à¸£à¸à¸” 'q' à¹€à¸žà¸·à¹ˆà¸­à¸«à¸¢à¸¸à¸”à¸£à¸°à¸šà¸šà¸­à¸¢à¹ˆà¸²à¸‡à¸›à¸¥à¸­à¸”à¸ à¸±à¸¢"""
    while GlobalConfig.get('system_running'):
        try:
            if keyboard.is_pressed('q'):
                GlobalConfig.set('system_running', False)
                logging.info("ðŸ›‘ à¸•à¸£à¸§à¸ˆà¸žà¸šà¸à¸²à¸£à¸à¸” 'q': à¸à¸³à¸¥à¸±à¸‡à¸«à¸¢à¸¸à¸”à¸£à¸°à¸šà¸šà¸­à¸¢à¹ˆà¸²à¸‡à¸›à¸¥à¸­à¸”à¸ à¸±à¸¢...")
                await ws_manager.stop()
                if hasattr(api_manager, 'exchange'):
                    await api_manager.exchange.close()
                await risk_guardian.emergency_stop()
                logging.info("âœ… à¸£à¸°à¸šà¸šà¸«à¸¢à¸¸à¸”à¸—à¸³à¸‡à¸²à¸™à¹à¸¥à¸°à¸›à¸´à¸”à¸—à¸¸à¸à¸ªà¹ˆà¸§à¸™à¸­à¸¢à¹ˆà¸²à¸‡à¸›à¸¥à¸­à¸”à¸ à¸±à¸¢à¹à¸¥à¹‰à¸§")
                break
        except Exception as e:
            logging.warning(f"âš ï¸ Control Loop Error: {e}")
        await asyncio.sleep(0.1)


# ==============================
# à¸Ÿà¸±à¸‡à¸à¹Œà¸Šà¸±à¸™à¸«à¸¥à¸±à¸à¸‚à¸­à¸‡à¸£à¸°à¸šà¸šà¹€à¸—à¸£à¸”
# ==============================
async def main():
    logging.info("à¹€à¸£à¸´à¹ˆà¸¡à¸•à¹‰à¸™à¸£à¸°à¸šà¸šà¸à¸²à¸£à¹€à¸—à¸£à¸”à¸”à¹‰à¸§à¸¢ CONFIG à¸ˆà¸²à¸ GlobalConfig")

    log_level_str = GlobalConfig.get('log_level', 'INFO').upper()
    logging.getLogger().setLevel(getattr(logging, log_level_str, logging.INFO))

    api_manager = APIManager()
    ws_manager = WebSocketManager(exchange=api_manager.exchange, time_offset=api_manager.time_offset)
    trader = UnifiedQuantumTrader(GlobalConfig.get('input_dim'))
    risk_guardian = RiskGuardian()
    env = MultiMarketEnv(ws_manager=ws_manager, exchange=api_manager.exchange)
    env.trader = trader

    trader.replay_buffer = ReplayBuffer()
    risk_guardian.env = env
    strategy_gen = StrategyGenerator(trader, env, risk_guardian)
    resource_manager = IntelligentResourceManager()
    kpi_optimizer = KPIOptimizer()
    risk_allocator = DynamicRiskAllocator()
    kpi_tracker = KPITracker()
    bug_fixer = AutomaticBugFixer()

    await ws_manager.fetch_all_usdt_pairs()
    await ws_manager.start()

    trader.current_symbols = ws_manager.all_usdt_pairs[: GlobalConfig.get('madrl_agent_count')]
    env.symbols = trader.current_symbols
    env.simulator.update_symbols(env.symbols)
    trader.madrl.update_symbols(env.symbols)

    # âœ… à¸ªà¸£à¹‰à¸²à¸‡ Task à¸—à¸±à¹‰à¸‡à¸«à¸¡à¸”
    asyncio.create_task(resource_manager.monitor_resources())
    asyncio.create_task(status_monitor_loop(ws_manager, api_manager))
    asyncio.create_task(sync_global_config_loop())
    asyncio.create_task(sync_real_trailing_orders(ws_manager, api_manager, trader))
    asyncio.create_task(control_loop(ws_manager, api_manager, risk_guardian))  # âœ… à¹€à¸žà¸´à¹ˆà¸¡ control_loop

    for symbol in env.symbols:
        await env.load_historical_data(symbol)

    try:
        GlobalConfig.set('system_running', True)
    except Exception:
        GlobalConfig.CONFIG['system_running'] = True

    trader.positions = {}

    while GlobalConfig.get('system_running'):
        try:
            mode = "ðŸ§ª à¹€à¸—à¸£à¸”à¸ˆà¸³à¸¥à¸­à¸‡" if GlobalConfig.get('dry_run') else "ðŸ’° à¹€à¸—à¸£à¸”à¸ˆà¸£à¸´à¸‡"
            for symbol in env.symbols:
                current_price = ws_manager.data.get(symbol, {}).get("close", 0)
                if not current_price:
                    continue

                action = np.random.choice(["LONG", "SHORT", "CLOSE_LONG", "CLOSE_SHORT", "HOLD"])
                lev = np.random.randint(1, 100)
                tp = current_price * 1.01
                sl = current_price * 0.99

                if action == "LONG":
                    logging.info(f"{mode} | ðŸŸ¢ LONG OPEN | {symbol} @ {current_price:.2f} | Lev={lev}x | TP={tp:.2f} | SL={sl:.2f}")
                elif action == "SHORT":
                    logging.info(f"{mode} | ðŸ”´ SHORT OPEN | {symbol} @ {current_price:.2f} | Lev={lev}x | TP={tp:.2f} | SL={sl:.2f}")
                elif action == "CLOSE_LONG":
                    logging.info(f"{mode} | ðŸŸ£ CLOSE LONG | {symbol} @ {current_price:.2f}")
                elif action == "CLOSE_SHORT":
                    logging.info(f"{mode} | ðŸŸ£ CLOSE SHORT | {symbol} @ {current_price:.2f}")
                else:
                    logging.info(f"{mode} | âšª HOLD | {symbol} | Price={current_price:.2f}")

            await asyncio.sleep(60)

        except Exception as e:
            if await bug_fixer.analyze_and_fix(e, trader, env):
                logging.info("à¹à¸à¹‰à¹„à¸‚à¸šà¸±à¹Šà¸à¸ªà¸³à¹€à¸£à¹‡à¸ˆ à¸—à¸³à¸‡à¸²à¸™à¸•à¹ˆà¸­")
                continue
            logging.critical(f"à¸‚à¹‰à¸­à¸œà¸´à¸”à¸žà¸¥à¸²à¸”à¸£à¹‰à¸²à¸¢à¹à¸£à¸‡: {e}")
            traceback.print_exc()
            await risk_guardian.emergency_stop()
            break


if __name__ == "__main__":
    asyncio.run(main())
