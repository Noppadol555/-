# ===============================================
# main.py — รวมทุกคลาสและรันระบบเทรดหลัก (เชื่อม WebSocket + APIManager)
# ===============================================

from config import GlobalConfig
import asyncio, logging, traceback, os, keyboard
import numpy as np
import pandas as pd
import torch
import time


# ==============================
# 🔄 ฟังก์ชันซิงค์ GlobalConfig แบบเรียลไทม์
# ==============================
async def sync_global_config_loop(interval=15):
    """ตรวจสอบและอัปเดตค่าจาก GlobalConfig ทุกๆ interval วินาที"""
    prev_config = GlobalConfig.CONFIG.copy()
    while True:
        try:
            # ตรวจสอบระดับ log
            current_level = getattr(logging, GlobalConfig.get('log_level', 'INFO').upper(), logging.INFO)
            if logging.getLogger().level != current_level:
                logging.getLogger().setLevel(current_level)
                logging.info(f"🛠️ อัปเดต log level เป็น {GlobalConfig.get('log_level')}")

            # ตรวจสอบ trade log file
            trade_log_file = GlobalConfig.get('trade_log_file', 'trade_log.xlsx')
            if not os.path.exists(trade_log_file):
                pd.DataFrame(columns=['Time', 'Symbol', 'Action', 'Price', 'PnL']).to_excel(trade_log_file, index=False)
                logging.info(f"📘 สร้างไฟล์บันทึกเทรดใหม่: {trade_log_file}")

            # ตรวจสอบค่าที่เปลี่ยนจากครั้งก่อน
            for k, v in GlobalConfig.CONFIG.items():
                if prev_config.get(k) != v:
                    logging.info(f"🔁 ค่า CONFIG '{k}' เปลี่ยนจาก {prev_config.get(k)} → {v}")
                    prev_config[k] = v

        except Exception as e:
            logging.warning(f"⚠️ GlobalConfig Sync Error: {e}")

        await asyncio.sleep(interval)


# ==============================
# 🟢 ฟังก์ชันตรวจสอบสถานะระบบแบบเรียลไทม์
# ==============================
async def status_monitor_loop(ws_manager, api_manager, interval=10):
    while True:
        try:
            ws_ok = "✅" if ws_manager.is_running() else "❌"
            api_ok = "✅" if api_manager and getattr(api_manager, "exchange", None) else "❌"
            delay = round(time.time() - getattr(ws_manager, "last_data_time", time.time()), 1)
            symbol_count = len(getattr(ws_manager, "data", {}))
            balance = getattr(ws_manager, "balance_data", {}).get("free", 0.0)
            logging.info(
                f"⏳ STATUS | WebSocket={ws_ok} | API={api_ok} | Symbols={symbol_count} | Delay={delay}s | Balance={balance:.2f} USDT"
            )
        except Exception as e:
            logging.warning(f"⚠️ สถานะระบบไม่สมบูรณ์: {e}")
        await asyncio.sleep(interval)


# ==============================
# 🧠 ฟังก์ชัน Auto Trailing Stop/Take Profit (จำลอง)
# ==============================
async def auto_update_trailing(strategy, current_price):
    try:
        trailing_callback = GlobalConfig.get('trailing_callback_rate', 0.005)
        if not strategy.get("trailing_stop") or not strategy.get("trailing_take_profit"):
            return strategy

        action = strategy.get("action")
        entry = strategy.get("entry_price", current_price)
        stop_loss = strategy.get("stop_loss")
        take_profit = strategy.get("take_profit")

        if action in ["LONG", "BUY"]:
            if current_price > entry * (1 + trailing_callback):
                new_sl = max(stop_loss, current_price * (1 - trailing_callback))
                new_tp = max(take_profit, current_price * (1 + trailing_callback))
                strategy["stop_loss"], strategy["take_profit"] = new_sl, new_tp
                mode = "🧪 เทรดจำลอง" if GlobalConfig.get("dry_run") else "💰 เทรดจริง"
                logging.info(f"{mode} | 🟢 Trailing LONG | {strategy['symbol']} | SL={new_sl:.4f} | TP={new_tp:.4f}")

        elif action in ["SHORT", "SELL"]:
            if current_price < entry * (1 - trailing_callback):
                new_sl = min(stop_loss, current_price * (1 + trailing_callback))
                new_tp = min(take_profit, current_price * (1 - trailing_callback))
                strategy["stop_loss"], strategy["take_profit"] = new_sl, new_tp
                mode = "🧪 เทรดจำลอง" if GlobalConfig.get("dry_run") else "💰 เทรดจริง"
                logging.info(f"{mode} | 🔴 Trailing SHORT | {strategy['symbol']} | SL={new_sl:.4f} | TP={new_tp:.4f}")

    except Exception as e:
        logging.warning(f"⚠️ Auto Trailing Error: {e}")

    return strategy


# ==============================
# 📡 ฟังก์ชัน Real Trailing Sync สำหรับเทรดจริง
# ==============================
async def sync_real_trailing_orders(ws_manager, api_manager, trader, interval=30):
    while True:
        try:
            trailing_callback = GlobalConfig.get('trailing_callback_rate', 0.005)
            if not getattr(trader, "positions", {}):
                await asyncio.sleep(interval)
                continue

            for symbol, pos in trader.positions.items():
                side = pos.get("side", "FLAT")
                entry_price = pos.get("entry_price", 0)
                if entry_price <= 0:
                    continue

                current_price = ws_manager.data.get(symbol, {}).get("close")
                if not current_price:
                    continue

                if side == "LONG" and current_price > entry_price * (1 + trailing_callback):
                    new_sl = current_price * (1 - trailing_callback)
                    new_tp = current_price * (1 + trailing_callback)
                    await api_manager.update_stop_take_profit(symbol, new_sl, new_tp)
                    logging.info(f"💰 เทรดจริง | 🟢 Trailing LONG | {symbol} | SL={new_sl:.4f} | TP={new_tp:.4f}")

                elif side == "SHORT" and current_price < entry_price * (1 - trailing_callback):
                    new_sl = current_price * (1 + trailing_callback)
                    new_tp = current_price * (1 - trailing_callback)
                    await api_manager.update_stop_take_profit(symbol, new_sl, new_tp)
                    logging.info(f"💰 เทรดจริง | 🔴 Trailing SHORT | {symbol} | SL={new_sl:.4f} | TP={new_tp:.4f}")

        except Exception as e:
            logging.warning(f"⚠️ Real Trailing Sync Error: {e}")

        await asyncio.sleep(interval)


# ===============================================
# 🧩 ฟังก์ชัน control_loop — หยุดระบบเมื่อกด 'q'
# ===============================================
async def control_loop(ws_manager, api_manager, risk_guardian):
    """ตรวจสอบการกด 'q' เพื่อหยุดระบบอย่างปลอดภัย"""
    while GlobalConfig.get('system_running'):
        try:
            if keyboard.is_pressed('q'):
                GlobalConfig.set('system_running', False)
                logging.info("🛑 ตรวจพบการกด 'q': กำลังหยุดระบบอย่างปลอดภัย...")
                await ws_manager.stop()
                if hasattr(api_manager, 'exchange'):
                    await api_manager.exchange.close()
                await risk_guardian.emergency_stop()
                logging.info("✅ ระบบหยุดทำงานและปิดทุกส่วนอย่างปลอดภัยแล้ว")
                break
        except Exception as e:
            logging.warning(f"⚠️ Control Loop Error: {e}")
        await asyncio.sleep(0.1)


# ==============================
# ฟังก์ชันหลักของระบบเทรด
# ==============================
async def main():
    logging.info("เริ่มต้นระบบการเทรดด้วย CONFIG จาก GlobalConfig")

    log_level_str = GlobalConfig.get('log_level', 'INFO').upper()
    logging.getLogger().setLevel(getattr(logging, log_level_str, logging.INFO))

    api_manager = APIManager()
    ws_manager = WebSocketManager(exchange=api_manager.exchange, time_offset=api_manager.time_offset)
    trader = UnifiedQuantumTrader(GlobalConfig.get('input_dim'))
    risk_guardian = RiskGuardian()
    env = MultiMarketEnv(ws_manager=ws_manager, exchange=api_manager.exchange)
    env.trader = trader

    trader.replay_buffer = ReplayBuffer()
    risk_guardian.env = env
    strategy_gen = StrategyGenerator(trader, env, risk_guardian)
    resource_manager = IntelligentResourceManager()
    kpi_optimizer = KPIOptimizer()
    risk_allocator = DynamicRiskAllocator()
    kpi_tracker = KPITracker()
    bug_fixer = AutomaticBugFixer()

    await ws_manager.fetch_all_usdt_pairs()
    await ws_manager.start()

    trader.current_symbols = ws_manager.all_usdt_pairs[: GlobalConfig.get('madrl_agent_count')]
    env.symbols = trader.current_symbols
    env.simulator.update_symbols(env.symbols)
    trader.madrl.update_symbols(env.symbols)

    # ✅ สร้าง Task ทั้งหมด
    asyncio.create_task(resource_manager.monitor_resources())
    asyncio.create_task(status_monitor_loop(ws_manager, api_manager))
    asyncio.create_task(sync_global_config_loop())
    asyncio.create_task(sync_real_trailing_orders(ws_manager, api_manager, trader))
    asyncio.create_task(control_loop(ws_manager, api_manager, risk_guardian))  # ✅ เพิ่ม control_loop

    for symbol in env.symbols:
        await env.load_historical_data(symbol)

    try:
        GlobalConfig.set('system_running', True)
    except Exception:
        GlobalConfig.CONFIG['system_running'] = True

    trader.positions = {}

    while GlobalConfig.get('system_running'):
        try:
            mode = "🧪 เทรดจำลอง" if GlobalConfig.get('dry_run') else "💰 เทรดจริง"
            for symbol in env.symbols:
                current_price = ws_manager.data.get(symbol, {}).get("close", 0)
                if not current_price:
                    continue

                action = np.random.choice(["LONG", "SHORT", "CLOSE_LONG", "CLOSE_SHORT", "HOLD"])
                lev = np.random.randint(1, 100)
                tp = current_price * 1.01
                sl = current_price * 0.99

                if action == "LONG":
                    logging.info(f"{mode} | 🟢 LONG OPEN | {symbol} @ {current_price:.2f} | Lev={lev}x | TP={tp:.2f} | SL={sl:.2f}")
                elif action == "SHORT":
                    logging.info(f"{mode} | 🔴 SHORT OPEN | {symbol} @ {current_price:.2f} | Lev={lev}x | TP={tp:.2f} | SL={sl:.2f}")
                elif action == "CLOSE_LONG":
                    logging.info(f"{mode} | 🟣 CLOSE LONG | {symbol} @ {current_price:.2f}")
                elif action == "CLOSE_SHORT":
                    logging.info(f"{mode} | 🟣 CLOSE SHORT | {symbol} @ {current_price:.2f}")
                else:
                    logging.info(f"{mode} | ⚪ HOLD | {symbol} | Price={current_price:.2f}")

            await asyncio.sleep(60)

        except Exception as e:
            if await bug_fixer.analyze_and_fix(e, trader, env):
                logging.info("แก้ไขบั๊กสำเร็จ ทำงานต่อ")
                continue
            logging.critical(f"ข้อผิดพลาดร้ายแรง: {e}")
            traceback.print_exc()
            await risk_guardian.emergency_stop()
            break


if __name__ == "__main__":
    asyncio.run(main())
