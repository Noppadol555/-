# ===============================================
# main.py ‚Äî ‡∏£‡∏ß‡∏°‡∏ó‡∏∏‡∏Å‡∏Ñ‡∏•‡∏≤‡∏™‡πÅ‡∏•‡∏∞‡∏£‡∏±‡∏ô‡∏£‡∏∞‡∏ö‡∏ö‡πÄ‡∏ó‡∏£‡∏î‡∏´‡∏•‡∏±‡∏Å (‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏° WebSocket + APIManager)
# ===============================================

from config import GlobalConfig
import asyncio, logging, traceback, os, keyboard
import numpy as np
import pandas as pd
import torch
import time

# ==============================
# üîÑ ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ã‡∏¥‡∏á‡∏Ñ‡πå GlobalConfig ‡πÅ‡∏ö‡∏ö‡πÄ‡∏£‡∏µ‡∏¢‡∏•‡πÑ‡∏ó‡∏°‡πå
# ==============================
async def sync_global_config_loop(interval=15):
    prev_config = GlobalConfig.CONFIG.copy()
    while True:
        try:
            current_level = getattr(logging, GlobalConfig.get('log_level', 'INFO').upper(), logging.INFO)
            if logging.getLogger().level != current_level:
                logging.getLogger().setLevel(current_level)
                logging.info(f"üõ†Ô∏è ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï log level ‡πÄ‡∏õ‡πá‡∏ô {GlobalConfig.get('log_level')}")

            trade_log_file = GlobalConfig.get('trade_log_file', 'trade_log.xlsx')
            if not os.path.exists(trade_log_file):
                pd.DataFrame(columns=['Time', 'Symbol', 'Action', 'Price', 'PnL']).to_excel(trade_log_file, index=False)
                logging.info(f"üìò ‡∏™‡∏£‡πâ‡∏≤‡∏á‡πÑ‡∏ü‡∏•‡πå‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÄ‡∏ó‡∏£‡∏î‡πÉ‡∏´‡∏°‡πà: {trade_log_file}")

            for k, v in GlobalConfig.CONFIG.items():
                if prev_config.get(k) != v:
                    logging.info(f"üîÅ ‡∏Ñ‡πà‡∏≤ CONFIG '{k}' ‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏à‡∏≤‡∏Å {prev_config.get(k)} ‚Üí {v}")
                    prev_config[k] = v

        except Exception as e:
            logging.warning(f"‚ö†Ô∏è GlobalConfig Sync Error: {e}")
        await asyncio.sleep(interval)


# ==============================
# üü¢ ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏£‡∏∞‡∏ö‡∏ö‡πÅ‡∏ö‡∏ö‡πÄ‡∏£‡∏µ‡∏¢‡∏•‡πÑ‡∏ó‡∏°‡πå
# ==============================
async def status_monitor_loop(ws_manager, api_manager, interval=10):
    while True:
        try:
            ws_ok = "‚úÖ" if ws_manager.is_running() else "‚ùå"
            api_ok = "‚úÖ" if api_manager and getattr(api_manager, "exchange", None) else "‚ùå"
            delay = round(time.time() - getattr(ws_manager, "last_data_time", time.time()), 1)
            symbol_count = len(getattr(ws_manager, "data", {}))
            balance = getattr(ws_manager, "balance_data", {}).get("free", 0.0)
            logging.info(
                f"‚è≥ STATUS | WebSocket={ws_ok} | API={api_ok} | Symbols={symbol_count} | Delay={delay}s | Balance={balance:.2f} USDT"
            )
        except Exception as e:
            logging.warning(f"‚ö†Ô∏è ‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏£‡∏∞‡∏ö‡∏ö‡πÑ‡∏°‡πà‡∏™‡∏°‡∏ö‡∏π‡∏£‡∏ì‡πå: {e}")
        await asyncio.sleep(interval)


# ===============================================
# üß© ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô control_loop ‚Äî ‡∏´‡∏¢‡∏∏‡∏î‡∏£‡∏∞‡∏ö‡∏ö‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏Å‡∏î 'q'
# ===============================================
async def control_loop(ws_manager, api_manager, risk_guardian):
    while GlobalConfig.get('system_running'):
        try:
            if keyboard.is_pressed('q'):
                GlobalConfig.set('system_running', False)
                logging.info("üõë ‡∏ï‡∏£‡∏ß‡∏à‡∏û‡∏ö‡∏Å‡∏≤‡∏£‡∏Å‡∏î 'q': ‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏´‡∏¢‡∏∏‡∏î‡∏£‡∏∞‡∏ö‡∏ö‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏õ‡∏•‡∏≠‡∏î‡∏†‡∏±‡∏¢...")
                await ws_manager.stop()
                if hasattr(api_manager, 'exchange'):
                    await api_manager.exchange.close()
                await risk_guardian.emergency_stop()
                logging.info("‚úÖ ‡∏£‡∏∞‡∏ö‡∏ö‡∏´‡∏¢‡∏∏‡∏î‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡πÅ‡∏•‡∏∞‡∏õ‡∏¥‡∏î‡∏ó‡∏∏‡∏Å‡∏™‡πà‡∏ß‡∏ô‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏õ‡∏•‡∏≠‡∏î‡∏†‡∏±‡∏¢‡πÅ‡∏•‡πâ‡∏ß")
                break
        except Exception as e:
            logging.warning(f"‚ö†Ô∏è Control Loop Error: {e}")
        await asyncio.sleep(0.1)


# ==============================
# üß† ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏´‡∏•‡∏±‡∏Å (MAIN)
# ==============================
async def main():
    logging.info("‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö‡∏Å‡∏≤‡∏£‡πÄ‡∏ó‡∏£‡∏î‡∏î‡πâ‡∏ß‡∏¢ CONFIG ‡∏à‡∏≤‡∏Å GlobalConfig")

    # ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤ log level
    log_level_str = GlobalConfig.get('log_level', 'INFO').upper()
    logging.getLogger().setLevel(getattr(logging, log_level_str, logging.INFO))

    # ‚úÖ ‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏≠‡∏¥‡∏ô‡∏™‡πÅ‡∏ï‡∏ô‡∏ã‡πå‡∏´‡∏•‡∏±‡∏Å‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î
    api_manager = APIManager()
    ws_manager = WebSocketManager(exchange=api_manager.exchange, time_offset=api_manager.time_offset)
    trader = UnifiedQuantumTrader(GlobalConfig.get('input_dim'))
    risk_guardian = RiskGuardian()
    env = MultiMarketEnv(ws_manager=ws_manager, exchange=api_manager.exchange)
    env.trader = trader

    trader.replay_buffer = None
    risk_guardian.env = env
    strategy_gen = StrategyGenerator(trader, env, risk_guardian)
    resource_manager = IntelligentResourceManager()
    kpi_optimizer = KPIOptimizer()
    risk_allocator = DynamicRiskAllocator()
    kpi_tracker = KPITracker()
    bug_fixer = AutomaticBugFixer()

    await ws_manager.fetch_all_usdt_pairs()
    await ws_manager.start()

    trader.current_symbols = ws_manager.all_usdt_pairs[: GlobalConfig.get('madrl_agent_count')]
    env.symbols = trader.current_symbols
    env.simulator.update_symbols(env.symbols)
    trader.madrl.update_symbols(env.symbols)

    # ‚úÖ ‡∏™‡∏£‡πâ‡∏≤‡∏á Tasks background
    asyncio.create_task(resource_manager.monitor_resources())
    asyncio.create_task(status_monitor_loop(ws_manager, api_manager))
    asyncio.create_task(sync_global_config_loop())
    asyncio.create_task(api_manager.monitor_trailing_orders())  # ‚úÖ ‡πÄ‡∏û‡∏¥‡πà‡∏° Trailing Manager
    asyncio.create_task(control_loop(ws_manager, api_manager, risk_guardian))

    # ‡πÇ‡∏´‡∏•‡∏î‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏¢‡πâ‡∏≠‡∏ô‡∏´‡∏•‡∏±‡∏á
    for symbol in env.symbols:
        await env.load_historical_data(symbol)

    # ‡πÄ‡∏õ‡∏¥‡∏î‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡∏£‡∏∞‡∏ö‡∏ö
    GlobalConfig.set('system_running', True)
    trader.positions = {}

    # ============================================================
    # üîÅ MAIN TRADING LOOP (‡πÄ‡∏ä‡∏∑‡πà‡∏≠‡∏° APIManager)
    # ============================================================
    while GlobalConfig.get('system_running'):
        try:
            mode = "üß™ ‡πÄ‡∏ó‡∏£‡∏î‡∏à‡∏≥‡∏•‡∏≠‡∏á" if GlobalConfig.get('dry_run') else "üí∞ ‡πÄ‡∏ó‡∏£‡∏î‡∏à‡∏£‡∏¥‡∏á"
            for symbol in env.symbols:
                current_price = ws_manager.data.get(symbol, {}).get("close", 0)
                if not current_price:
                    continue

                action = np.random.choice(["LONG", "SHORT", "CLOSE_LONG", "CLOSE_SHORT", "HOLD"])
                lev = np.random.randint(1, 100)
                tp = current_price * 1.01
                sl = current_price * 0.99

                # ‚úÖ ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì Trailing Stop ‡πÅ‡∏•‡∏∞‡∏™‡πà‡∏á‡πÉ‡∏´‡πâ API
                trailing_callback = GlobalConfig.get('trailing_callback_rate', 0.005)
                if action == "LONG":
                    trailing_tp = current_price * (1 + trailing_callback)
                    trailing_sl = current_price * (1 - trailing_callback)
                    logging.info(
                        f"{mode} | üü¢ LONG OPEN | {symbol} @ {current_price:.2f} | Lev={lev}x "
                        f"| TP={tp:.2f} | SL={sl:.2f} | TR_TP={trailing_tp:.2f} | TR_SL={trailing_sl:.2f}"
                    )
                    await api_manager.execute_limit_order(
                        symbol, "buy", 0.01, current_price,
                        take_profit=tp, stop_loss=sl,
                        trailing_tp=trailing_tp, trailing_sl=trailing_sl,
                        leverage=lev
                    )

                elif action == "SHORT":
                    trailing_tp = current_price * (1 - trailing_callback)
                    trailing_sl = current_price * (1 + trailing_callback)
                    logging.info(
                        f"{mode} | üî¥ SHORT OPEN | {symbol} @ {current_price:.2f} | Lev={lev}x "
                        f"| TP={tp:.2f} | SL={sl:.2f} | TR_TP={trailing_tp:.2f} | TR_SL={trailing_sl:.2f}"
                    )
                    await api_manager.execute_limit_order(
                        symbol, "sell", 0.01, current_price,
                        take_profit=tp, stop_loss=sl,
                        trailing_tp=trailing_tp, trailing_sl=trailing_sl,
                        leverage=lev
                    )

                elif action == "CLOSE_LONG":
                    logging.info(f"{mode} | üü£ CLOSE LONG | {symbol} @ {current_price:.2f}")
                    await api_manager.close_position(symbol, "buy", 0.01)

                elif action == "CLOSE_SHORT":
                    logging.info(f"{mode} | üü£ CLOSE SHORT | {symbol} @ {current_price:.2f}")
                    await api_manager.close_position(symbol, "sell", 0.01)

                else:
                    logging.info(f"{mode} | ‚ö™ HOLD | {symbol} | Price={current_price:.2f}")

            await asyncio.sleep(60)

        except Exception as e:
            if await bug_fixer.analyze_and_fix(e, trader, env):
                logging.info("‡πÅ‡∏Å‡πâ‡πÑ‡∏Ç‡∏ö‡∏±‡πä‡∏Å‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à ‡∏ó‡∏≥‡∏á‡∏≤‡∏ô‡∏ï‡πà‡∏≠")
                continue
            logging.critical(f"‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡∏£‡πâ‡∏≤‡∏¢‡πÅ‡∏£‡∏á: {e}")
            traceback.print_exc()
            await risk_guardian.emergency_stop()
            break


if __name__ == "__main__":
    asyncio.run(main())
