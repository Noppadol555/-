# ==========================================================
# MultiMarketEnv (Enhanced — HOLD / LONG / SHORT / CLOSE / TP / SL / TSL)
# ==========================================================

import os
import time
import gymnasium as gym
import pandas as pd
import numpy as np
import openpyxl  # noqa: F401
import sqlite3
from datetime import datetime, timedelta
import asyncio
import logging
import keyboard  # noqa: F401
from collections import deque  # noqa: F401
from config import GlobalConfig  # ✅ ใช้งานจริงในคลาสนี้

# ---------------------- ค่าเริ่มต้น ----------------------
TIMESTEPS = GlobalConfig.get('timesteps', 10)
TAKER_FEE = GlobalConfig.get('taker_fee', 0.0004)
SLIPPAGE_DEFAULT = GlobalConfig.get('slippage_default', 0.0005)

# ---------------------- Fallback Classes ----------------------
class RealTimeSimulator:
    def __init__(self, symbols):
        self.data = {s: pd.DataFrame() for s in symbols}
    def simulate_step(self):
        pass
    def reset(self):
        self.data = {s: pd.DataFrame() for s in self.data.keys()}
    def get_data(self, symbol):
        return np.zeros(10), None, np.zeros(10), None, None, pd.DataFrame()

class KPITracker:
    def __init__(self):
        self.total_profit = 0
    async def update(self, profit):
        self.total_profit += profit

class KPIOptimizer:
    def optimize(self, val):
        return 1.0

class DynamicIndicatorGenerator:
    def __init__(self, *_, **__):
        pass
    def generate_synthetic_indicators(self, symbol):
        return {
            tf: {
                "base": {"ATR": 0, "RSI": 0, "MACD": 0, "EMA": 0,
                         "BB_upper": 0, "BB_lower": 0, "SMA": 0,
                         "Stoch_RSI": 0, "OBV": 0, "Volume": 0},
                "synthetic": np.zeros(10),
                "gnn_correlations": np.zeros(5)
            } for tf in GlobalConfig.get('multi_tf_list', [])
        }

# ==========================================================
# คลาสหลัก MultiMarketEnv
# ==========================================================
class MultiMarketEnv(gym.Env):
    def __init__(
        self,
        account_balance=GlobalConfig.get('initial_balance'),
        risk_per_trade=GlobalConfig.get('risk_per_trade'),
        dry_run=GlobalConfig.get('dry_run'),
        ws_manager=None,
        exchange=None,
    ):
        super().__init__()
        self.account_balance = account_balance
        self.available_balance = account_balance
        self.reinvest_cap = account_balance * 2
        self.initial_balance = GlobalConfig.get('initial_balance')
        self.risk_per_trade = risk_per_trade
        self.dry_run = dry_run

        self.symbols = []
        self.positions = {}  # {symbol: {'side': 'LONG', 'entry': 50000, 'size': 0.1, ...}}
        self.current_step = 0
        self.day_start = datetime.utcnow().replace(hour=0, minute=0, second=0, microsecond=0)

        # เชื่อมอ็อบเจ็กต์ภายนอก
        self.ws_manager = ws_manager
        self.exchange = exchange
        self.simulator = RealTimeSimulator(self.symbols)

        self.data, self.raw_data, self.scalers = {}, {}, {}
        self.trader = None

        # SQLite + Excel
        self.trade_log_file = GlobalConfig.get('trade_log_file')
        self.db_conn = sqlite3.connect('env_history.db', timeout=10)
        self.db_conn.execute(
            "CREATE TABLE IF NOT EXISTS returns (id INTEGER PRIMARY KEY, step INT, return REAL, timestamp REAL)"
        )
        self.db_conn.execute(
            "CREATE TABLE IF NOT EXISTS historical_data (id INTEGER PRIMARY KEY, symbol TEXT, timestamp REAL, close REAL, volume REAL, funding_rate REAL, depth REAL)"
        )

        if self.trade_log_file and not os.path.exists(self.trade_log_file):
            pd.DataFrame(
                columns=['DateTime', 'Symbol', 'TradeType', 'BuyPrice', 'SellPrice',
                         'Quantity', 'Capital', 'ProfitLoss']
            ).to_excel(self.trade_log_file, index=False)

        self.min_kpi_threshold = GlobalConfig.get('min_daily_kpi')
        self.multi_tf_data = {tf: {} for tf in GlobalConfig.get('multi_tf_list', [])}
        self.kpi_tracker = KPITracker()
        self.kpi_optimizer = KPIOptimizer()
        self.balance_last_updated = 0

    # ==========================================================
    # Helper: ปลอดภัยเวลาไม่มี websocket
    # ==========================================================
    def safe_get_price(self, symbol):
        if self.ws_manager and hasattr(self.ws_manager, "get_latest_price"):
            try:
                return float(self.ws_manager.get_latest_price(symbol))
            except Exception as e:
                logging.error(f"safe_get_price error: {e}")
                return 0.0
        return 0.0

    # ==========================================================
    # โหลดข้อมูลย้อนหลัง
    # ==========================================================
    async def load_historical_data(self, symbol, years=GlobalConfig.get('historical_years', 1)):
        years_ago = datetime.utcnow() - timedelta(days=365 * years)
        with self.db_conn:
            cursor = self.db_conn.execute(
                "SELECT timestamp, close, volume, funding_rate, depth FROM historical_data WHERE symbol=? AND timestamp>=? ORDER BY timestamp ASC",
                (symbol, years_ago.timestamp()),
            )
            data = cursor.fetchall()

        if len(data) < TIMESTEPS and not self.dry_run and self.exchange:
            try:
                klines = await self.exchange.fetch_ohlcv(symbol, timeframe='1h', since=int(years_ago.timestamp() * 1000), limit=17520)
                for kline in klines:
                    timestamp, _, _, _, close, volume = kline
                    self.db_conn.execute(
                        "INSERT INTO historical_data (symbol, timestamp, close, volume, funding_rate, depth) VALUES (?, ?, ?, ?, ?, ?)",
                        (symbol, timestamp / 1000, close, volume, 0.0001, 0),
                    )
                self.db_conn.commit()
            except Exception as e:
                logging.error(f"โหลดข้อมูลย้อนหลังล้มเหลว: {e}")

        return pd.DataFrame(data, columns=['timestamp', 'close', 'volume', 'funding_rate', 'depth']) if data else pd.DataFrame()

    # ==========================================================
    # โอนเงิน Spot → Futures (จำลอง)
    # ==========================================================
    async def transfer_from_spot_to_futures(self):
        if self.dry_run:
            shortfall = max(0, GlobalConfig.get('initial_balance') - self.account_balance)
            self.account_balance += shortfall
            self.available_balance += shortfall
            return shortfall
        return 0

    # ==========================================================
    # Execute Trade — รองรับ LONG / SHORT / CLOSE / HOLD / TP / SL / Trailing
    # ==========================================================
    async def execute_trade_async(
        self, symbol, action, size, leverage, stop_loss, take_profit,
        trailing_stop=None, trailing_take_profit=None
    ):
        price = self.safe_get_price(symbol)
        if price <= 0:
            return 0.0

        # อัปเดต Balance ทุก 60 วินาที
        current_time = time.time()
        if current_time - self.balance_last_updated > 60:
            if self.ws_manager and hasattr(self.ws_manager, "get_latest_balance"):
                self.account_balance = self.ws_manager.get_latest_balance()
            self.balance_last_updated = current_time

        pos = self.positions.get(symbol, None)
        profit = 0.0

        # HOLD — ไม่ทำอะไร
        if action == "HOLD":
            return 0.0

        # เปิด LONG
        if action == "LONG":
            entry_cost = (size * price) / leverage * (1 + TAKER_FEE + SLIPPAGE_DEFAULT)
            if entry_cost > self.available_balance:
                logging.warning(f"Margin ไม่พอสำหรับ {symbol}")
                return 0.0
            self.positions[symbol] = {
                'side': 'LONG', 'entry_price': price, 'size': size, 'leverage': leverage,
                'stop_loss': price * (1 - stop_loss),
                'take_profit': price * (1 + take_profit),
                'trailing_stop': trailing_stop,
                'trailing_tp': trailing_take_profit
            }
            self.available_balance -= entry_cost
            return 0.0

        # เปิด SHORT
        if action == "SHORT":
            entry_cost = (size * price) / leverage * (1 + TAKER_FEE + SLIPPAGE_DEFAULT)
            if entry_cost > self.available_balance:
                logging.warning(f"Margin ไม่พอสำหรับ {symbol}")
                return 0.0
            self.positions[symbol] = {
                'side': 'SHORT', 'entry_price': price, 'size': size, 'leverage': leverage,
                'stop_loss': price * (1 + stop_loss),
                'take_profit': price * (1 - take_profit),
                'trailing_stop': trailing_stop,
                'trailing_tp': trailing_take_profit
            }
            self.available_balance -= entry_cost
            return 0.0

        # ปิด LONG
        if action == "CLOSE_LONG" and pos and pos['side'] == 'LONG':
            entry = pos['entry_price']
            pnl = ((price - entry) * pos['size'] * pos['leverage']) / entry
            profit = pnl - (TAKER_FEE + SLIPPAGE_DEFAULT)
            self.account_balance += profit
            self.available_balance += pos['size'] * price / pos['leverage']
            del self.positions[symbol]
            return profit

        # ปิด SHORT
        if action == "CLOSE_SHORT" and pos and pos['side'] == 'SHORT':
            entry = pos['entry_price']
            pnl = ((entry - price) * pos['size'] * pos['leverage']) / entry
            profit = pnl - (TAKER_FEE + SLIPPAGE_DEFAULT)
            self.account_balance += profit
            self.available_balance += pos['size'] * price / pos['leverage']
            del self.positions[symbol]
            return profit

        # ตรวจสอบ TP / SL / Trailing Stop
        if pos:
            if pos['side'] == 'LONG':
                if price <= pos['stop_loss']:
                    return await self.execute_trade_async(symbol, "CLOSE_LONG", size, leverage, stop_loss, take_profit)
                elif price >= pos['take_profit']:
                    return await self.execute_trade_async(symbol, "CLOSE_LONG", size, leverage, stop_loss, take_profit)
                elif pos['trailing_stop'] and price > pos['entry_price']:
                    new_sl = price * (1 - pos['trailing_stop'])
                    if new_sl > pos['stop_loss']:
                        pos['stop_loss'] = new_sl
                elif pos['trailing_tp'] and price > pos['entry_price']:
                    new_tp = price * (1 + pos['trailing_tp'])
                    if new_tp > pos['take_profit']:
                        pos['take_profit'] = new_tp

            elif pos['side'] == 'SHORT':
                if price >= pos['stop_loss']:
                    return await self.execute_trade_async(symbol, "CLOSE_SHORT", size, leverage, stop_loss, take_profit)
                elif price <= pos['take_profit']:
                    return await self.execute_trade_async(symbol, "CLOSE_SHORT", size, leverage, stop_loss, take_profit)
                elif pos['trailing_stop'] and price < pos['entry_price']:
                    new_sl = price * (1 + pos['trailing_stop'])
                    if new_sl < pos['stop_loss']:
                        pos['stop_loss'] = new_sl
                elif pos['trailing_tp'] and price < pos['entry_price']:
                    new_tp = price * (1 - pos['trailing_tp'])
                    if new_tp < pos['take_profit']:
                        pos['take_profit'] = new_tp

        return profit

    # ==========================================================
    # Step
    # ==========================================================
    async def step(self):
        if self.dry_run:
            self.simulator.simulate_step()

        if self.ws_manager:
            logging.debug(f"WebSocket active: {len(self.ws_manager.data)} symbols")
        else:
            logging.warning("⚠️ ws_manager ยังไม่ถูกเชื่อม")

        rewards, total_profit = [], 0
        for s in self.symbols:
            price = self.safe_get_price(s)
            rewards.append(price / 100000)
        total_profit = sum(rewards)

        self.current_step += 1
        done = self.current_step >= 10
        return np.array(rewards), rewards, done, {'profit': total_profit}

    # ==========================================================
    def get_observation(self):
        return np.zeros((len(self.symbols), 20))

    def reset(self):
        self.account_balance = self.initial_balance
        self.available_balance = self.initial_balance
        self.positions = {s: None for s in self.symbols}
        self.current_step = 0
        if self.dry_run:
            self.simulator.reset()
