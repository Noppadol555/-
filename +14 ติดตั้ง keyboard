# ติดตั้งไลบรารีที่ต้องใช้สำหรับคลาสนี้ (รันคำสั่งเหล่านี้ใน terminal ก่อนใช้งาน)
# pip install gym pandas numpy openpyxl gym sqlite3 datetime asyncio keyboard

import gym
import pandas as pd
import numpy as np
import openpyxl
import sqlite3
from datetime import datetime, timedelta
import asyncio
import logging
import keyboard
from collections import deque
#from config import GlobalConfig

class MultiMarketEnv(gym.Env):
    def __init__(self, account_balance=GlobalConfig.get('initial_balance'), risk_per_trade=GlobalConfig.get('risk_per_trade'), dry_run=GlobalConfig.get('dry_run'), ws_manager=None, exchange=None):
        super().__init__()
        self.account_balance = account_balance
        self.available_balance = account_balance
        self.reinvest_cap = account_balance * 2
        self.initial_balance = GlobalConfig.get('initial_balance')
        self.risk_per_trade = risk_per_trade
        self.dry_run = dry_run
        self.symbols = []
        self.positions = {}
        self.current_step = 0
        self.day_start = datetime.utcnow().replace(hour=0, minute=0, second=0, microsecond=0)
        self.ws_manager = ws_manager  # เชื่อมจาก main
        self.exchange = exchange      # เชื่อมจาก main
        self.simulator = RealTimeSimulator(self.symbols)  # เชื่อมจาก main
        self.data = {}
        self.raw_data = {}
        self.scalers = {}
        self.trader = None  # เชื่อมจาก main
        self.trade_log_file = GlobalConfig.get('trade_log_file')
        self.db_conn = sqlite3.connect('env_history.db', timeout=10)
        self.db_conn.execute("CREATE TABLE IF NOT EXISTS returns (id INTEGER PRIMARY KEY, step INT, return REAL, timestamp REAL)")
        self.db_conn.execute("CREATE TABLE IF NOT EXISTS historical_data (id INTEGER PRIMARY KEY, symbol TEXT, timestamp REAL, close REAL, volume REAL, funding_rate REAL, depth REAL)")
        if not os.path.exists(self.trade_log_file):
            pd.DataFrame(columns=['DateTime', 'Symbol', 'TradeType', 'BuyPrice', 'SellPrice', 'Quantity', 'Capital', 'ProfitLoss']).to_excel(self.trade_log_file, index=False)
        self.min_kpi_threshold = GlobalConfig.get('min_daily_kpi')
        self.multi_tf_data = {tf: {} for tf in GlobalConfig.get('multi_tf_list')}
        self.kpi_tracker = KPITracker()  # เชื่อมจาก main
        self.kpi_optimizer = KPIOptimizer()  # เชื่อมจาก main
        self.balance_last_updated = 0

    async def load_historical_data(self, symbol, years=GlobalConfig.get('historical_years')):
        years_ago = datetime.utcnow() - timedelta(days=365 * years)
        with self.db_conn:
            cursor = self.db_conn.execute("SELECT timestamp, close, volume, funding_rate, depth FROM historical_data WHERE symbol=? AND timestamp>=? ORDER BY timestamp ASC",
                                         (symbol, years_ago.timestamp()))
            data = cursor.fetchall()
            if len(data) < TIMESTEPS and not self.dry_run:
                klines = await exchange.fetch_ohlcv(symbol, timeframe='1h', since=int(years_ago.timestamp() * 1000), limit=17520)
                for kline in klines:
                    timestamp, _, _, _, close, volume = kline
                    self.db_conn.execute("INSERT INTO historical_data (symbol, timestamp, close, volume, funding_rate, depth) VALUES (?, ?, ?, ?, ?, ?)",
                                        (symbol, timestamp / 1000, close, volume, 0.0001, 0))
                self.db_conn.commit()
                cursor = self.db_conn.execute("SELECT timestamp, close, volume, funding_rate, depth FROM historical_data WHERE symbol=? AND timestamp>=? ORDER BY timestamp ASC",
                                             (symbol, years_ago.timestamp()))
                data = cursor.fetchall()
        return pd.DataFrame(data, columns=['timestamp', 'close', 'volume', 'funding_rate', 'depth']) if data else pd.DataFrame()

    async def transfer_from_spot_to_futures(self):
        if self.dry_run:
            shortfall = max(0, GlobalConfig.get('initial_balance') - self.account_balance)
            self.account_balance += shortfall
            self.available_balance += shortfall
            return shortfall
        spot_balance = await exchange.fetch_balance(params={'type': 'spot'})['USDT']['free']
        shortfall = max(0, GlobalConfig.get('initial_balance') - self.account_balance)
        if shortfall > 0 and spot_balance >= shortfall:
            await exchange.transfer('USDT', shortfall, 'spot', 'futures')
            self.account_balance += shortfall
            self.available_balance += shortfall
            logging.info(f"โอน {shortfall:.2f} USDT จาก Spot ไป Futures")
            return shortfall
        else:
            logging.warning(f"ยอด Spot ไม่เพียงพอ: มี {spot_balance:.2f}, ต้องการ {shortfall:.2f}")
            return 0

    async def execute_trade_async(self, symbol, side, size, leverage, stop_loss, take_profit, trailing_stop=None, trailing_take_profit=None):
        current_time = time.time()
        if current_time - self.balance_last_updated > 60:
            self.account_balance = self.ws_manager.get_latest_balance()
            self.available_balance = self.account_balance
            if GlobalConfig.get('reinvest_profits'):
                self.available_balance += self.kpi_tracker.total_profit * 0.5
            self.balance_last_updated = current_time

        price = self.ws_manager.get_latest_price(symbol) if not self.dry_run else self.raw_data[symbol]['close'].iloc[-1]
        required_margin = (size * price) / leverage * (1 + TAKER_FEE + SLIPPAGE_DEFAULT)
        if required_margin > self.available_balance:
            logging.warning(f"Margin ไม่พอสำหรับ {symbol}: ต้องการ {required_margin:.2f}, มี {self.available_balance:.2f}")
            return 0

        if not self.trader.risk_guardian.evaluate_position(symbol, price, price, size, leverage, side):
            logging.warning(f"ตำแหน่ง {symbol} ไม่ผ่านการประเมินความเสี่ยง")
            return 0

        if self.dry_run:
            future_step = min(self.current_step + 10, len(self.raw_data[symbol]) - 1)
            future_price = self.raw_data[symbol]['close'].iloc[future_step]
            profit = (future_price - price) * size * leverage * (1 - TAKER_FEE - SLIPPAGE_DEFAULT) * (-1 if side == 'SELL' else 1)
        else:
            await api_manager.set_margin_mode(symbol)
            await api_manager.set_leverage(symbol, leverage)
            callback_rate = GlobalConfig.get('trailing_callback_rate') if trailing_stop else None
            order = await api_manager.create_limit_order_with_trailing(symbol, side, size, price, callback_rate)
            if order:
                profit = 0  # คำนวณจริงจาก close_position
            else:
                return 0

        self.positions[symbol] = {
            'size': size, 'entry': price, 'leverage': leverage, 
            'stop_loss': price * (1 - stop_loss if side == 'BUY' else 1 + stop_loss),
            'take_profit': price * (1 + take_profit if side == 'BUY' else 1 - take_profit), 
            'side': side, 'trailing_stop': trailing_stop, 'trailing_take_profit': trailing_take_profit,
            'highest_price': price if side == 'BUY' else float('inf'),
            'lowest_price': price if side == 'SELL' else float('-inf')
        }
        self.account_balance -= required_margin
        self.available_balance -= required_margin
        self.account_balance += profit
        if GlobalConfig.get('reinvest_profits') and profit > 0:
            reinvest_amount = min(profit * 0.5, self.reinvest_cap - self.available_balance)
            self.available_balance += reinvest_amount
            logging.info(f"Reinvest กำไร {reinvest_amount:.2f} USDT")
        trade_log = pd.DataFrame([{
            'วันที่': datetime.utcnow(), 
            'เหรียญ': symbol, 
            'ประเภทการเทรด': side, 
            'ราคาซื้อ': price if side == 'BUY' else 0, 
            'ราคาขาย': price if side == 'SELL' else 0, 
            'ปริมาณ': size, 
            'ทุน': self.account_balance, 
            'กำไร/ขาดทุน': profit,
            'โหมด': 'จำลอง' if self.dry_run else 'จริง'
        }])
        with pd.ExcelWriter(self.trade_log_file, mode='a', if_sheet_exists='overlay') as writer:
            trade_log.to_excel(writer, index=False, header=False)
        return profit

    async def close_position_async(self, symbol, current_price):
        if self.positions.get(symbol):
            size = self.positions[symbol]['size']
            leverage = self.positions[symbol]['leverage']
            profit = (current_price - self.positions[symbol]['entry']) * size * leverage * (1 - TAKER_FEE) * \
                     (-1 if self.positions[symbol]['side'] == 'SELL' else 1)
            self.account_balance += profit + (size * self.positions[symbol]['entry'] / leverage)
            self.available_balance += (size * self.positions[symbol]['entry'] / leverage)
            del self.positions[symbol]
            return profit
        return 0

    async def process_symbol(self, symbol):
        if not self.ws_manager and not self.dry_run:
            logging.error("ws_manager ไม่ได้กำหนด")
            return 0, 0
        current_price = self.ws_manager.get_latest_price(symbol) if not self.dry_run else self.raw_data[symbol]['close'].iloc[-1]
        position = self.positions.get(symbol)
        profit = 0
        if position:
            if position['trailing_stop']:
                if position['side'] == 'BUY' and current_price > position['highest_price']:
                    position['highest_price'] = current_price
                    position['stop_loss'] = current_price - position['trailing_stop']
                elif position['side'] == 'SELL' and current_price < position['lowest_price']:
                    position['lowest_price'] = current_price
                    position['stop_loss'] = current_price + position['trailing_stop']
            if position['trailing_take_profit']:
                if position['side'] == 'BUY' and current_price > position['highest_price']:
                    position['highest_price'] = current_price
                    position['take_profit'] = current_price - position['trailing_take_profit']
                elif position['side'] == 'SELL' and current_price < position['lowest_price']:
                    position['lowest_price'] = current_price
                    position['take_profit'] = current_price + position['trailing_take_profit']
            if (position['side'] == 'BUY' and (current_price <= position['stop_loss'] or current_price >= position['take_profit'])) or \
               (position['side'] == 'SELL' and (current_price >= position['stop_loss'] or current_price <= position['take_profit'])):
                profit = await self.close_position_async(symbol, current_price)
        reward = profit / self.initial_balance if profit != 0 else 0
        return reward, profit

    async def fetch_multi_tf_data(self, symbol):
        if not self.exchange and not self.dry_run:
            logging.error("exchange ไม่ได้กำหนด")
            return
        for tf in GlobalConfig.get('multi_tf_list'):
            if self.dry_run:
                df = self.simulator.data.get(symbol, pd.DataFrame())
                if df.empty:
                    logging.warning(f"ไม่มีข้อมูลจำลองสำหรับ {symbol} ใน {tf}")
                    self.multi_tf_data[tf][symbol] = pd.DataFrame()
                else:
                    self.multi_tf_data[tf][symbol] = df.resample(tf).last().tail(10)
            else:
                try:
                    klines = await self.exchange.fetch_ohlcv(symbol, timeframe=tf, limit=10)
                    df = pd.DataFrame(klines, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])
                    self.multi_tf_data[tf][symbol] = df
                except Exception as e:
                    logging.error(f"ดึงข้อมูล {symbol} ใน {tf} ล้มเหลว: {e}")
                    self.multi_tf_data[tf][symbol] = pd.DataFrame()
            if tf not in self.multi_tf_data or symbol not in self.multi_tf_data[tf]:
                logging.warning(f"ข้อมูลสำหรับ {symbol} ใน {tf} ไม่ได้ถูกตั้งค่า")
                self.multi_tf_data[tf][symbol] = pd.DataFrame()

    async def step(self):
        if self.dry_run:
            self.simulator.simulate_step()
            for symbol in self.symbols:
                state_lstm, _, state_ensemble, _, scaler, raw = self.simulator.get_data(symbol)
                self.data[symbol] = {'lstm': state_lstm, 'ensemble': state_ensemble}
                self.scalers[symbol] = scaler
                self.raw_data[symbol] = raw
        await asyncio.gather(*(self.fetch_multi_tf_data(symbol) for symbol in self.symbols))
        if self.account_balance < GlobalConfig.get('initial_balance') * 0.9:
            await self.transfer_from_spot_to_futures()
        await self.check_new_day()
        rewards = []
        total_profit = 0
        tasks = [self.process_symbol(symbol) for symbol in self.symbols]
        results = await asyncio.gather(*tasks, return_exceptions=True)
        for i, result in enumerate(results):
            if isinstance(result, Exception):
                logging.error(f"Error processing {self.symbols[i]}: {result}")
                rewards.append(0)
                total_profit += 0
            else:
                reward, profit = result
                rewards.append(reward)
                total_profit += profit
        self.current_step += 1
        done = self.current_step >= 1440 or self.account_balance < self.initial_balance * (1 - GlobalConfig.get('max_drawdown')) or not GlobalConfig.get('system_running')
        with self.db_conn:
            self.db_conn.execute("INSERT INTO returns (step, return, timestamp) VALUES (?, ?, ?)",
                               (self.current_step, total_profit, time.time()))
        if done:
            self.reset()
        return self.get_observation(), rewards, done, {'profit': total_profit}

    async def check_new_day(self):
        now = datetime.utcnow()
        if now >= self.day_start + timedelta(days=1):
            excess = max(0, self.account_balance - self.initial_balance)
            if excess > 0 and not self.dry_run:
                await exchange.fapiPrivate_post_transfer({'asset': 'USDT', 'amount': excess, 'type': 2})
                self.account_balance -= excess
                logging.info(f"โอนกำไรส่วนเกิน {excess:.2f} USDT ไป Spot")
            self.day_start = now.replace(hour=0, minute=0, second=0, microsecond=0)

    def get_observation(self):
        dyn_gen = DynamicIndicatorGenerator(self.trader.evogan, self.trader.gnn, self.multi_tf_data)
        observations = []
        for symbol in self.symbols:
            ind = dyn_gen.generate_synthetic_indicators(symbol)
            obs = []
            for tf in GlobalConfig.get('multi_tf_list'):
                tf_ind = ind.get(tf, {
                    'base': {k: 0 for k in ['ATR', 'RSI', 'MACD', 'EMA', 'BB_upper', 'BB_lower', 'SMA', 'Stoch_RSI', 'OBV', 'Volume']},
                    'synthetic': np.zeros(10),
                    'gnn_correlations': np.zeros(5)
                })
                base_values = list(tf_ind['base'].values())
                synthetic_values = list(tf_ind['synthetic'].flatten()[:10])
                gnn_values = list(tf_ind['gnn_correlations'].flatten()[:5])
                obs.extend(base_values + synthetic_values + gnn_values)
            observations.append(np.array(obs))
        return np.array(observations)

    def reset(self):
        self.account_balance = self.initial_balance
        self.available_balance = self.initial_balance
        self.positions = {s: None for s in self.symbols}
        self.current_step = 0
        if self.dry_run:
            self.simulator.reset()
