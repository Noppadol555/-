import sys
import subprocess
import logging
import os
import shutil
import tempfile
import platform
import json
from contextlib import contextmanager
from typing import Optional, Set, List, Tuple
import pkg_resources

# Configure logging with detailed format
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - [%(funcName)s] - %(message)s",
    handlers=[
        logging.StreamHandler(),
        logging.FileHandler("auto_uninstaller_complete_v3.log")
    ]
)
logger = logging.getLogger(__name__)

# List of libraries to remove (including known dependencies)
LIBS_TO_REMOVE = [
    "ccxt", "tenacity", "torch", "numpy", "pandas", "scikit-learn",
    "bayesian-optimization", "matplotlib", "seaborn", "darts",
    "torch-geometric", "torch-scatter", "torch-sparse", "torch-cluster",
    "torch-spline-conv", "psutil", "gym", "openpyxl", "keyboard", "ta"
]

@contextmanager
def temp_file(suffix: str = '.txt') -> str:
    """Context manager for creating and safely deleting a temporary file."""
    temp = tempfile.NamedTemporaryFile(mode='w', suffix=suffix, delete=False)
    try:
        yield temp.name
    finally:
        temp.close()
        if os.path.exists(temp.name):
            try:
                os.unlink(temp.name)
                logger.debug(f"Deleted temporary file: {temp.name}")
            except OSError as e:
                logger.warning(f"Failed to delete temporary file {temp.name}: {e}")

def run_command(args: List[str], capture_output: bool = True, shell: bool = False) -> Optional[str]:
    """Run a command and handle errors."""
    try:
        result = subprocess.run(
            args, check=True, stdout=subprocess.PIPE, stderr=subprocess.PIPE,
            text=True, capture_output=capture_output, shell=shell
        )
        return result.stdout.strip() if capture_output else True
    except subprocess.CalledProcessError as e:
        logger.error(f"Command failed: {' '.join(args)} - {e.stderr}")
        return None
    except FileNotFoundError:
        logger.error(f"Command not found: {' '.join(args)}")
        return None

def run_pip_command(args: List[str], capture_output: bool = True) -> Optional[str]:
    """Run a pip command."""
    return run_command([sys.executable, "-m", "pip"] + args, capture_output)

def run_conda_command(args: List[str], capture_output: bool = True) -> Optional[str]:
    """Run a conda command."""
    return run_command(["conda"] + args, capture_output)

def get_active_conda_env() -> Optional[str]:
    """Get the active conda environment name."""
    output = run_conda_command(["env", "list", "--json"], capture_output=True)
    if output:
        try:
            envs = json.loads(output)
            for env in envs.get("envs", []):
                if env.endswith(os.sep + "conda-meta"):
                    env = env.rsplit(os.sep, 2)[0]
                if os.path.abspath(sys.prefix) == os.path.abspath(env):
                    return os.path.basename(env)
        except json.JSONDecodeError:
            logger.error("Failed to parse conda env list output")
    return None

def get_installed_packages() -> Set[str]:
    """Get list of installed packages from pip or conda."""
    installed = set()
    pip_output = run_pip_command(["list", "--format=freeze"])
    if pip_output:
        installed.update(line.split("==")[0].lower() for line in pip_output.split("\n") if line and "==" in line)

    conda_env = get_active_conda_env()
    if conda_env:
        conda_output = run_conda_command(["list", "--name", conda_env], capture_output=True)
        if conda_output:
            for line in conda_output.split("\n"):
                if line and not line.startswith("#"):
                    parts = line.split()
                    if len(parts) > 0:
                        installed.add(parts[0].lower())
    return installed

def get_dependencies(pkg: str, installed: Set[str]) -> Set[str]:
    """Get dependencies of a package using pkg_resources."""
    try:
        dist = pkg_resources.get_distribution(pkg)
        return {dep.name.lower() for dep in dist.requires() if dep.name.lower() in installed and dep.name.lower() not in LIBS_TO_REMOVE}
    except pkg_resources.DistributionNotFound:
        return set()

def create_temp_requirements(installed_packages: Set[str]) -> str:
    """Create temporary requirements.txt for packages and their dependencies."""
    with temp_file() as temp_file:
        packages_to_remove = set()
        for pkg in LIBS_TO_REMOVE:
            if pkg.lower() in installed_packages:
                packages_to_remove.add(pkg)
                packages_to_remove.update(get_dependencies(pkg, installed_packages))

        with open(temp_file, 'w') as f:
            for pkg in packages_to_remove:
                f.write(f"{pkg}\n")
        return temp_file

def purge_cache() -> None:
    """Purge pip and torch cache."""
    logger.info("Purging pip cache...")
    run_pip_command(["cache", "purge"])

    cache_dirs = [
        os.path.expanduser("~/.cache/torch"),
        os.path.expanduser("~/.cache/pip")
    ]
    for cache_dir in cache_dirs:
        if os.path.exists(cache_dir):
            try:
                shutil.rmtree(cache_dir)
                logger.info(f"Deleted cache directory: {cache_dir}")
            except OSError as e:
                logger.warning(f"Failed to delete cache directory {cache_dir}: {e}")

def check_environment() -> Tuple[str, bool]:
    """Check if running in a virtual environment or conda."""
    if hasattr(sys, 'real_prefix') or (hasattr(sys, 'base_prefix') and sys.base_prefix != sys.prefix):
        logger.info("Detected virtual environment: Safe for uninstallation")
        return "venv", True
    elif get_active_conda_env():
        logger.info(f"Detected conda environment: {get_active_conda_env()}")
        return "conda", True
    else:
        logger.warning("Detected global environment: May affect other projects")
        return "global", False

def check_cuda_toolkit() -> bool:
    """Check for CUDA toolkit and provide removal instructions."""
    system = platform.system()
    cuda_paths = []
    if system == "Linux":
        cuda_paths = ["/usr/local/cuda", "/opt/nvidia/cuda", "/usr/lib/cuda"]
    elif system == "Windows":
        cuda_paths = ["C:\\Program Files\\NVIDIA GPU Computing Toolkit\\CUDA", "C:\\NVIDIA\\CUDA"]
    elif system == "Darwin":
        cuda_paths = ["/Developer/NVIDIA/CUDA", "/usr/local/cuda"]

    cuda_found = False
    for path in cuda_paths:
        if os.path.exists(path):
            cuda_found = True
            logger.warning(
                f"Found CUDA toolkit at {path}. To remove, use system-specific tools:\n"
                f"- Linux: 'sudo apt remove --purge cuda*' or 'sudo yum remove cuda*'\n"
                f"- Windows: Use NVIDIA uninstaller from Control Panel\n"
                f"- macOS: Use NVIDIA uninstall script or 'sudo rm -rf {path}'"
            )
    return cuda_found

def check_permissions() -> bool:
    """Check if the program has write permissions for log and cache directories."""
    try:
        with tempfile.NamedTemporaryFile(mode='w', delete=True) as f:
            f.write("test")
        log_file = "auto_uninstaller_complete_v3.log"
        with open(log_file, 'a') as f:
            f.write("")
        return True
    except PermissionError as e:
        logger.error(f"Permission error: {e}. Ensure you have write access to log and cache directories.")
        return False
    except OSError as e:
        logger.error(f"OS error checking permissions: {e}")
        return False

def main() -> None:
    """Main function to perform complete uninstallation of specified libraries."""
    logger.info("Starting complete uninstallation process...")

    if not check_permissions():
        logger.error("Insufficient permissions. Run with sudo/admin or check directory access.")
        return

    env_type, is_safe = check_environment()
    if not is_safe:
        try:
            confirm = input("Confirm uninstallation in global environment? (y/N): ")
            if confirm.lower() != 'y':
                logger.info("Uninstallation cancelled by user")
                return
        except KeyboardInterrupt:
            logger.info("Uninstallation cancelled by keyboard interrupt")
            return

    cuda_found = check_cuda_toolkit()
    if cuda_found:
        logger.warning("pip/conda uninstallation will not remove system-level CUDA toolkit. Remove manually.")

    installed = get_installed_packages()
    logger.info(f"Found {len(installed)} installed packages: {sorted(installed)}")

    temp_req = create_temp_requirements(installed)
    logger.info(f"Created temporary requirements file: {temp_req}")

    removed_count = 0
    failed_packages = []
    if env_type == "conda":
        output = run_conda_command(["remove", "-y", "--file", temp_req])
        if output:
            removed_count = len([pkg for pkg in LIBS_TO_REMOVE if pkg.lower() in installed])
            logger.info(f"Successfully uninstalled {removed_count}/{len(LIBS_TO_REMOVE)} packages with conda")
        else:
            failed_packages = [pkg for pkg in LIBS_TO_REMOVE if pkg.lower() in installed]
    else:
        with open(temp_req, 'r') as f:
            packages = [line.strip() for line in f if line.strip()]
        for pkg in packages:
            output = run_pip_command(["uninstall", "-y", pkg])
            if output:
                logger.info(f"Uninstalled package: {pkg}")
                removed_count += 1
            else:
                logger.warning(f"Failed to uninstall package: {pkg}")
                failed_packages.append(pkg)

    purge_cache()

    remaining = get_installed_packages()
    remaining_to_remove = [pkg for pkg in LIBS_TO_REMOVE if pkg.lower() in remaining]
    if remaining_to_remove:
        logger.warning(f"Remaining packages: {remaining_to_remove}. May be system dependencies or failed uninstall.")
    else:
        logger.info("Successfully uninstalled all Python packages in this environment.")

    logger.info(f"Uninstallation complete. {removed_count} removed, {len(failed_packages)} failed: {failed_packages}")
    if cuda_found:
        logger.warning("Note: CUDA toolkit is still present. Remove manually using system tools.")
    logger.info("Verify with 'pip list' or 'conda list' to confirm.")

if __name__ == "__main__":
    main()
