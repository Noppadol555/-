# ==========================================================
# StrategyGenerator (Enhanced Version - Full Futures Mode + Auto Trailing)
# ==========================================================
# ‡∏ï‡∏¥‡∏î‡∏ï‡∏±‡πâ‡∏á‡πÑ‡∏•‡∏ö‡∏£‡∏≤‡∏£‡∏µ‡∏ó‡∏µ‡πà‡∏ï‡πâ‡∏≠‡∏á‡πÉ‡∏ä‡πâ‡∏Å‡πà‡∏≠‡∏ô:
# pip install numpy

import numpy as np
import logging
from config import GlobalConfig  # ‚úÖ ‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡∏à‡∏£‡∏¥‡∏á‡πÉ‡∏ô‡∏Ñ‡∏•‡∏≤‡∏™‡∏ô‡∏µ‡πâ

class StrategyGenerator:
    def __init__(self, trader, env, risk_guardian):
        self.trader = trader
        self.env = env
        self.risk_guardian = risk_guardian

        # ‚úÖ ‡∏Ñ‡∏£‡∏≠‡∏ö‡∏Ñ‡∏•‡∏∏‡∏° Action ‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î‡∏Ç‡∏≠‡∏á Futures
        self.action_map = {
            0: 'HOLD',
            1: 'LONG',
            2: 'SHORT',
            3: 'CLOSE_LONG',
            4: 'CLOSE_SHORT',
        }

    # ==========================================================
    # üîπ generate_strategy()
    # ==========================================================
    async def generate_strategy(self, state, symbol, volatility):
        """
        ‡πÉ‡∏ä‡πâ‡πÇ‡∏°‡πÄ‡∏î‡∏•‡∏ó‡∏≥‡∏ô‡∏≤‡∏¢ action ‡πÅ‡∏•‡∏∞ continuous output (‡πÄ‡∏ä‡πà‡∏ô leverage, size)
        ‡∏à‡∏≤‡∏Å‡∏ô‡∏±‡πâ‡∏ô‡∏™‡∏£‡πâ‡∏≤‡∏á dict ‡∏Å‡∏•‡∏¢‡∏∏‡∏ó‡∏ò‡πå‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏î‡∏≥‡πÄ‡∏ô‡∏¥‡∏ô‡∏Å‡∏≤‡∏£‡πÉ‡∏ô‡∏ï‡∏•‡∏≤‡∏î Futures
        """
        discrete_pred, continuous_pred = self.trader.predict(state)
        action_idx = int(np.argmax(discrete_pred[0]))
        action = self.action_map.get(action_idx, 'HOLD')

        leverage, size = continuous_pred[0]

        # ‚úÖ ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ó‡∏¥‡∏®‡∏ó‡∏≤‡∏á (side)
        if action == 'LONG':
            side = 'LONG'
        elif action == 'SHORT':
            side = 'SHORT'
        elif action == 'CLOSE_LONG':
            side = 'CLOSE_LONG'
        elif action == 'CLOSE_SHORT':
            side = 'CLOSE_SHORT'
        else:
            side = 'FLAT'

        # ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì Stop Loss / Take Profit ‡∏ï‡∏≤‡∏° volatility
        stop_loss = GlobalConfig.get('stop_loss_percentage') * (
            1 + volatility / max(GlobalConfig.get('min_volatility_threshold'), 1e-8)
        )
        take_profit = stop_loss * 2

        # ‚úÖ ‡∏Å‡∏≥‡∏´‡∏ô‡∏î trailing ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏ï‡∏≤‡∏° volatility
        trailing_stop = (
            stop_loss if volatility > GlobalConfig.get('min_volatility_threshold') else None
        )
        trailing_take_profit = (
            take_profit if volatility > GlobalConfig.get('min_volatility_threshold') else None
        )

        return {
            'action': action,
            'side': side,
            'symbol': symbol,
            'size': float(size),
            'leverage': min(
                float(leverage),
                GlobalConfig.get('max_leverage_per_symbol', {}).get(symbol, 125)
            ),
            'stop_loss': stop_loss,
            'take_profit': take_profit,
            'trailing_stop': trailing_stop,
            'trailing_take_profit': trailing_take_profit,
        }

    # ==========================================================
    # üîπ execute_strategy()
    # ==========================================================
    async def execute_strategy(self, strategy):
        """
        ‡∏î‡∏≥‡πÄ‡∏ô‡∏¥‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏ó‡∏£‡∏î‡∏ï‡∏≤‡∏°‡∏Å‡∏•‡∏¢‡∏∏‡∏ó‡∏ò‡πå‡∏ó‡∏µ‡πà‡πÑ‡∏î‡πâ‡∏£‡∏±‡∏ö:
        HOLD ‚Üí ‡∏Ç‡πâ‡∏≤‡∏°
        LONG ‚Üí ‡πÄ‡∏õ‡∏¥‡∏î Long
        SHORT ‚Üí ‡πÄ‡∏õ‡∏¥‡∏î Short
        CLOSE_LONG / CLOSE_SHORT ‚Üí ‡∏õ‡∏¥‡∏î‡∏™‡∏ñ‡∏≤‡∏ô‡∏∞‡πÄ‡∏î‡∏¥‡∏°
        """
        # ‚úÖ HOLD ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà‡∏ú‡πà‡∏≤‡∏ô Risk Check ‡∏à‡∏∞‡πÑ‡∏°‡πà‡∏ó‡∏≥‡∏Å‡∏≤‡∏£‡πÄ‡∏ó‡∏£‡∏î
        if strategy['action'] == 'HOLD' or not self.risk_guardian.assess_risk(
            self.env.account_balance, self.env.initial_balance
        ):
            return 0

        # ‚úÖ ‡∏£‡∏∞‡∏ö‡∏∏‡∏ó‡∏¥‡∏®‡∏ó‡∏≤‡∏á‡∏Ñ‡∏≥‡∏™‡∏±‡πà‡∏á‡∏ó‡∏µ‡πà‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏™‡∏°‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Futures
        if strategy['action'] in ['LONG', 'CLOSE_SHORT']:
            order_side = 'BUY'
        elif strategy['action'] in ['SHORT', 'CLOSE_LONG']:
            order_side = 'SELL'
        else:
            order_side = 'HOLD'

        # ‚úÖ ‡∏î‡∏≥‡πÄ‡∏ô‡∏¥‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏ó‡∏£‡∏î‡∏ú‡πà‡∏≤‡∏ô Environment (‡∏à‡∏≥‡∏•‡∏≠‡∏á‡∏´‡∏£‡∏∑‡∏≠‡∏à‡∏£‡∏¥‡∏á)
        profit = await self.env.execute_trade_async(
            strategy['symbol'],
            order_side,
            strategy['size'],
            strategy['leverage'],
            strategy['stop_loss'],
            strategy['take_profit'],
            strategy['trailing_stop'],
            strategy['trailing_take_profit'],
        )

        # ‚úÖ ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥‡∏Å‡∏≤‡∏£‡πÄ‡∏ó‡∏£‡∏î‡πÉ‡∏ô RiskGuardian
        self.risk_guardian.total_trades += 1
        if profit < 0:
            self.risk_guardian.failed_trades += 1

        return profit

    # ==========================================================
    # üîπ auto_update_trailing()
    # ==========================================================
    async def auto_update_trailing(self, strategy, current_price):
        """
        ‡∏õ‡∏£‡∏±‡∏ö stop_loss ‡πÅ‡∏•‡∏∞ take_profit ‡∏≠‡∏±‡∏ï‡πÇ‡∏ô‡∏°‡∏±‡∏ï‡∏¥‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏£‡∏≤‡∏Ñ‡∏≤‡∏Ç‡∏¢‡∏±‡∏ö
        ‡πÉ‡∏ä‡πâ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏• local ‡πÄ‡∏ó‡πà‡∏≤‡∏ô‡∏±‡πâ‡∏ô ‚Üí ‡πÑ‡∏°‡πà‡πÇ‡∏î‡∏ô API Limit
        """
        callback_rate = GlobalConfig.get('trailing_callback_rate', 0.5) / 100
        updated = False

        if strategy['side'] == 'LONG':
            # ‡∏õ‡∏£‡∏±‡∏ö stop-loss ‡∏Ç‡∏∂‡πâ‡∏ô‡∏ï‡∏≤‡∏°‡∏£‡∏≤‡∏Ñ‡∏≤‡πÄ‡∏°‡∏∑‡πà‡∏≠‡∏£‡∏≤‡∏Ñ‡∏≤‡∏™‡∏π‡∏á‡∏Ç‡∏∂‡πâ‡∏ô
            if current_price >= strategy.get('take_profit', 0):
                new_sl = current_price * (1 - callback_rate)
                if new_sl > strategy.get('stop_loss', 0):
                    strategy['stop_loss'] = new_sl
                    updated = True

        elif strategy['side'] == 'SHORT':
            # ‡∏õ‡∏£‡∏±‡∏ö stop-loss ‡∏•‡∏á‡∏ï‡∏≤‡∏°‡∏£‡∏≤‡∏Ñ‡∏≤‡∏•‡∏î‡∏•‡∏á
            if current_price <= strategy.get('take_profit', float('inf')):
                new_sl = current_price * (1 + callback_rate)
                if new_sl < strategy.get('stop_loss', float('inf')):
                    strategy['stop_loss'] = new_sl
                    updated = True

        if updated:
            # ‚úÖ ‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô KeyError ‡∏Å‡∏£‡∏ì‡∏µ symbol ‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÉ‡∏ô dict
            logging.debug(
                f"üîÑ ‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï Trailing SL {strategy.get('symbol', '?')} ‚Üí {strategy.get('stop_loss', 0):.4f}"
            )

        return strategy
